var MM = {
    _magicMountain: false,
    _isUpdating: false,
    _baseContentHeight: "100%",

    init: function () {

        Root.initiateCopy();

        if(document.getElementById("menu") != null){
            document.getElementById("menu").style.display = "none"; //For switching between light/dark mode. Hide screen while resources are loading
        }

        MM.ellipsisText();
        MM.calcSwipeDeleteSize();
        MM.setDivWidth();
        MM.headerNoShadow();
        MM.headerOverlay();
        MM.switcherInputInit();
        MM.sliderLoad();
        MM.wrapPagerInParent();
        MM.popupHeaderFooterHide();
        MM.structuredContainerHeaderFooterCalc();
        MM.scrollParallaxContainer();
        MM.mapInit();
        MM.multiMarkersMapInit();
        MM.mapSetHeight();
        MM.iOSHelpTabQuirk();
        MM.messageReplayLongPress();
        MM.sortableGridContainerInit();
        MM.donutGraph();
        MM.initMMLineGraph();
        MM.countDownTimer();
        MM.setVirtualCard();
        MM.setBarGraph();
        MM.setMeetingCalendar();
        MM.checkDisplayOfScrollToBottomBtn();
        MM.onLoadInputTimer();
        BankMail.checkSelectedTextOptions();
        lotto_Powerball.checkIfLotto();
        MM.applyHighlightToMention();
        MM.tabContainerSelect();
        MM.setRadialGraphStyling();
        MM.removeStylingForAutoLoadContainer();
        MM.frontEndConversationTimer();
        MM.calculateFrontEndConversationTimerAndNotificationHeight();
        voicenotes.autoDownloadVNs();
        MM.frontEndRemoveHeaderNotification();
        MM.correctTextAreaSize();
        MM.removeHeaderSubtitleWithTtl();
        MM.powerCardViewPin();
        MM.FullScreenPanelContainer();
        MM.setPagerHeightUFF();
        MM.disableRightButtonBeforeSelection();
        MM.addHiddenMessagingHeaderInput();
        MM.setupImageViewerCarousel();
        MM.SpinnerUpdateInputValue();
        MM.loadSpinnerData();
        MM.maintainIntrinsicSizeofImageWallet();
        MM.setWindowHeightWithoutKeyboard();
        sharesGraph.setDefaultLandingSharesGraph();
        MM.setCollapsableContainer();
        MM.cardFill();
        MM.setBaseContentHeight();
        MM.setNavigationOptionsForUff();
        MM.setPasteListener();
        MM.setListenersForSelectedTextOptions();
        MM.saveCopyableText();
        MM.markupTextToHTML();
        MM.markupSavedComposeText();
        MM.threeTextNumericSelect();
        voicenotes.switchSendRecordImage();

        if(document.getElementById("menu") != null){
            document.getElementById("menu").style.display = "block"; //For switching between light/dark mode. Hide screen while resources are loading
        }

        MM.scrollToMe(); //Always last
    },

    setMagicMountain: function () {
        MM._magicMountain = true;
    },

    isMagicMountain: function () {
        return MM._magicMountain;
    },

    animateExitElement: function (element) {

        if (element.getAttribute("data-animation-exit") != "null") {
            var classes = element.classList;

            if (classes.length == 1) {
                element.className = "";
                element.className = "animation_" + element.getAttribute("data-animation-exit") + "_out";
            } else {
                for (var classCount = 0; classCount < classes.length; classCount++) {

                    if (classes[classCount].indexOf("animation_") > -1 && classes[classCount].indexOf("_in") > -1) {

                        element.classList.remove(classes[classCount]);

                        if(element.getAttribute("data-animation-exit") !== '') {
                            element.classList.add(element.getAttribute("data-animation-exit"));
                        }
                    }
                }
            }
        }
    },

    animateExit: function () {
        var elements = document.querySelectorAll("[data-animation-exit]");
        for (allElementCount = 0; allElementCount < elements.length; ++allElementCount) {
            var element = elements[allElementCount];
            MM.animateExitElement(element);
        }
    },

    setBaseContentHeight: function () {

        var baseContent = document.getElementById("base-content");

        if(baseContent != null){
            var headerAndMarginHeightUFF = 13.2;
            var headerAndMarginHeight = 11.2;
            var footerAndMarginHeight = 13;
            var footerAndMarginHeightUFF = 2;
            var footer = document.getElementById("footer");
            var header = document.getElementById("headerFixed");
            var bodyHeightInIframe = document.body.clientHeight;
            var ifUFF = Root.applyIfUFF(600);

            if(window.self != window.top){//embedded
                if(document.getElementById("footer") == null){
                    if(ifUFF == true){
                        _baseContentHeight = "calc("+bodyHeightInIframe+" - ("+headerAndMarginHeightUFF+" + "+footerAndMarginHeightUFF+") * var(--maxUnitBase))";
                        baseContent.style.height = _baseContentHeight;
                    }else if(ifUFF == false){
                        if(header != null && header.classList.contains("contentBehind")){
                            _baseContentHeight = ""+bodyHeightInIframe+"";
                            baseContent.style.height = _baseContentHeight;
                        }else{
                            _baseContentHeight = "calc("+bodyHeightInIframe+" - "+headerAndMarginHeight+" * var(--unit))";
                            baseContent.style.height = _baseContentHeight;
                        }
                    }
                }else if(footer != null){
                    if(ifUFF == true){
                        _baseContentHeight = "calc("+bodyHeightInIframe+" - ("+headerAndMarginHeightUFF+" + "+footerAndMarginHeightUFF+") * var(--maxUnitBase))";
                        baseContent.style.height = _baseContentHeight;
                    }else if(ifUFF == false){
                        if(header != null && header.classList.contains("contentBehind")){
                            _baseContentHeight = ""+bodyHeightInIframe+"";
                            baseContent.style.height = _baseContentHeight;
                        }else{
                            _baseContentHeight = "calc("+bodyHeightInIframe+" - ("+headerAndMarginHeight+" + "+footerAndMarginHeight+") * var(--unit))";
                            baseContent.style.height = _baseContentHeight;
                        }
                    }
                }
            }else if(document.getElementById("footer") == null){
                if(ifUFF == true){
                    _baseContentHeight = "calc(100vh - ("+headerAndMarginHeightUFF+" + "+footerAndMarginHeightUFF+") * var(--maxUnitBase))";
                    baseContent.style.height = _baseContentHeight;
                }else if(ifUFF == false){
                    if(header != null && header.classList.contains("contentBehind")){
                        _baseContentHeight = window.innerHeight + "px";
                        baseContent.style.height = _baseContentHeight;
                    }else{
                        _baseContentHeight = "calc(" + window.innerHeight + "px - "+headerAndMarginHeight+" * var(--unit))";
                        baseContent.style.height = _baseContentHeight;
                    }
                }
            }else if(footer != null){
                if(ifUFF == true){
                    _baseContentHeight = "calc(100vh - ("+headerAndMarginHeightUFF+" + "+footerAndMarginHeightUFF+") * var(--maxUnitBase))";
                    baseContent.style.height = _baseContentHeight;
                }else if(ifUFF == false){
                    if(header != null && header.classList.contains("contentBehind")){
                        _baseContentHeight = window.innerHeight + "px";
                        baseContent.style.height = _baseContentHeight;
                    }else{
                        _baseContentHeight = "calc("+ window.innerHeight +"px - ("+headerAndMarginHeight+" + "+footerAndMarginHeight+") * var(--unit))";
                        baseContent.style.height = _baseContentHeight;
                    }
                }
            }
        }

    },

    /** Correct as is: Used for the scroll to the flagged symbol. **/
    scrollToMe: function () {
        var scrollToMeArray = document.querySelectorAll("[data-scroll-to-me='true']");
        var base = document.getElementById("base-content");
        var head = document.getElementById("headerFixed");

        if (scrollToMeArray.length != 0) {
            var target = scrollToMeArray[scrollToMeArray.length - 1];

            //Fix for Scroll to me clashing with animation_Right_in for messageBubbleContainer specifically
            //Added delay to scrollIntoView to allow for animation to finish first (0.3s)
            if (target.querySelector(".messaging") != null) {
                setTimeout(function () {
                    target.scrollIntoView();
                }, 300);
            } else {
                target.scrollIntoView();
            }

            scrollToMeArray[scrollToMeArray.length - 1].setAttribute("data-scroll-to-me", "false");

            if (target.classList.contains("messaging")) {
                target.parentElement.setAttribute("data-scroll-to-me", "false");
            }

            //Move element below header
            if (head != null && base != null) {
                base.scrollTop -= parseFloat(window.getComputedStyle(head).height);
            }
        }
    },

    countDownTimer: function () {

        var timeObject = document.querySelector(".countDownTimerContainer");

        if (timeObject === null || timeObject.getAttribute("data-refreshFlag") === "true") {
            return;
        }

        timeObject.setAttribute("data-refreshFlag", "true");

        var time = timeObject.getAttribute("data-time");
        var timerType = timeObject.getAttribute("data-type");
        var timerUIID = timeObject.getAttribute("data-uiid");

        var flag = -1;
        var pie = 3.14;
        var centreX = 125;
        var rootUnit;

        //For Universal Form Factor
        if (window.matchMedia("(min-width: 500px)").matches) {
            rootUnit = Root._maxUnit;// 6.3;
        } else {
            rootUnit = (Root.unit());
        }

        var imageHeight = rootUnit * 9.0;
        var imageWidth = rootUnit * 8.0;
        var r = 14 * rootUnit;
        if (r >= 100) {
            r = 90;
        }
        var anim = "";
        var bottomText = document.getElementById("bottomText");
        var image = document.getElementById("image");
        var greenCircle = document.getElementById("greenCircle");
        var topText = document.getElementById("topText");
        var greyCircle = document.getElementById("greyCircle");
        var image = document.getElementById("image");
        image.setAttribute("height", imageHeight);
        image.setAttribute("width", imageWidth);
        topText.innerHTML = time;

        //Outside grey circle
        greyCircle.setAttribute("r", r + (rootUnit));
        greyCircle.setAttribute("cx", centreX);
        greyCircle.setAttribute("cy", r);

        //Time display
        topText.setAttribute("x", centreX);
        topText.setAttribute("y", r - (4 * rootUnit));

        // Main text display
        bottomText.setAttribute("x", centreX);
        bottomText.setAttribute("y", r);


        //Image positioning
        image.setAttribute("x", centreX - (4 * rootUnit));
        image.setAttribute("y", r + (rootUnit));

        // Green animated circle
        anim = "M 125,  " + r + " m0 -" + r + " a" + r + " " + r + " 1 0 1 0 " + (r * 2) + " a" + r + " " + r + " 1 0 1 0 -" + (r * 2);
        greenCircle.setAttribute('d', anim);
        greenCircle.style.strokeDasharray = (pie * 2 * r);
        greenCircle.style.animationName = "smooth";
        greenCircle.style.animationDuration = time + "s";
        greenCircle.style.animationTimingFunction = "linear";
        greenCircle.style.animationIterationCount = 1;
        topText.innerHTML = time--;

        var timerId = setInterval(function () {

            topText.innerHTML = time--;
            if (time <= flag) {
                Timers.clearOne(timerId);

                var element = document.getElementById("greenCircle");

                if (element !== null) {
                    element.parentNode.removeChild(element);
                }

                if (timerType === "UPDATE") {
                    MM.partialUpdate(timeObject);
                } else if (timerType === "NAVIGATE") {
                    Form.navigate(timerUIID);
                }
            }

        }, 1000);
        Timers.register(timerId);
    },
    onLoadInputTimer: function () {

        var allInputTimerObject = document.querySelectorAll(".dateTimeWrapper");
        for (count = 0; count < allInputTimerObject.length; ++count) {

            var inputTimerObject = allInputTimerObject[count];

            if (inputTimerObject === null || inputTimerObject.length === 0) {
                return;
            }

            var val = inputTimerObject.getAttribute("data-value");
            var key = inputTimerObject.getAttribute("data-key");
            var enabled = inputTimerObject.getAttribute("data-enabled");

            if (val !== "" || val !== "") {
                MM.dateFormatter(null, parseInt(val), "dateTimePickerInput_" + key);
                MM.timeFormatter(parseInt(val), "dateTimePickerTimeInput_" + key);
                MM.epochToDateTimePicker(parseInt(val), key);
            }
            if (enabled === "N") {
                document.getElementById("dateTimePickerInput_" + key).disabled = true;
                document.getElementById("dateTimePickerTimeInput_" + key).disabled = true;
                document.getElementById("dateTimePickerInput_" + key).parentElement.style.paddingLeft = ((Root.unit()) * 4).toString() + "px";

            }
        }
    },
    labelBlur: function (labelId, errorColor, defaultColor, errorText) {

        var label = document.getElementById(labelId);
        if (errorText != "") {
            label.style.color = errorColor;
        } else {
            label.style.color = defaultColor;
        }
    },
    labelFocus: function (labelId, focusColor) {

        var label = document.getElementById(labelId);
        label.style.color = focusColor;
    },
    inputFocusBlur: function (dateId, timeId, color) {

        var inputDate = document.getElementById(dateId);
        var inputTime = document.getElementById(timeId);
        inputDate.style.borderBottomColor = color;
        inputTime.style.borderBottomColor = color;

    },
    epochToDateTimePicker: function (dateTime, dataKey) {

        var newDate = new Date(dateTime);
        var date = newDate.toISOString().substring(0, 10);
        var time = newDate.toTimeString().substring(0, 5);

        var dateTimeArray = [{flag: "DATE", value: date},
            {flag: "TIME", value: time}];

        dateTimeArray.forEach(function (obj) {
            MM.dateTimePickerConcatenator(obj.value, obj.flag, dataKey);
        });
    },
    timeFormatter: function (time, id) {

        var newDate = new Date(time);
        var hours = newDate.getHours();
        var minutes = newDate.getMinutes();
        if (hours.toString().length === 1) {
            hours = "0" + newDate.getHours();
        }
        if (minutes.toString().length === 1) {
            minutes = "0" + newDate.getMinutes();
        }
        var finalTime = hours + ":" + minutes;
        var timeInput = document.getElementById(id);
        timeInput.value = finalTime;
    },

    dateFormatter: function (el, date, id) {

        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;

        if (iOS) {
            if (el == null || el.textContent != null && el.textContent != "") {
                MM.dateFormatterHelper(date,id);
            }
        } else {
            MM.dateFormatterHelper(date,id);
        }

    },

    dateFormatterHelper: function (date, id) {
        var inputTimerObject = document.getElementById(id);
        var enabled = inputTimerObject.getAttribute("data-enabled");

        // var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
        // if (!iOS || enabled == "N") {
        var newDate = new Date(date);
        var dayName = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
        var dateInput = document.getElementById(id);
        dateInput.type = "text";
        var finaleDate = dayName[newDate.getDay()] + ", " + newDate.getDate() + " " + monthName[newDate.getMonth()] + " " + newDate.getFullYear();
        dateInput.value = finaleDate;
        dateInput.blur();
        // }
    },

    setInputTypeToDate : function(el){
        el.type ='date';
    },

    dateTimePickerConcatenator: function (dateTime, flag, dataKey) {

        var hiddenDate = document.getElementById("hiddenDate_" + dataKey);
        var hiddenTime = document.getElementById("hiddenTime_" + dataKey);

        if (flag === "DATE") {
            hiddenDate.setAttribute("value", dateTime.replace(/_/g, "-"));
        } else if (flag === "TIME") {
            hiddenTime.setAttribute("value", dateTime + ':00');
        }

        if(!hiddenDate.value == "" && !hiddenTime.value == ""){
            var finalDateTime = hiddenDate.getAttribute("value") +"T"+ hiddenTime.getAttribute("value");
            MM.dateTimePickerToEpoch(finalDateTime, "DATETIME",dataKey);
        }

    },
    dateTimePickerToEpoch: function (e, flag, dataKey) {

        var hiddenDateTime = document.getElementById("hiddenDateTime_" + dataKey);

        var dateString = "1970-01-01";
        var timeString = "00:00:00";
        var finalDateTime = "";

        if (flag === "DATE") {
            dateString = e.replace(/_/g, "-");
            finalDateTime = dateString + ' ' + timeString;
        } else if (flag === "TIME") {
            timeString = e + ':00';
            finalDateTime = dateString + ' ' + timeString;
        } else if (flag === "DATETIME") {
            finalDateTime = e;
        }

        var epoch = Math.floor((new Date(finalDateTime) / 1)); // to get milliseconds representation
        hiddenDateTime.setAttribute("value", epoch)
    },
    /**Use function to set delay on partial update for an input: set data-timerValue="" and data-inputType**/
    timerInput: function (e) {

        var timerCheck = e.getAttribute("data-timerValue");
        var ghostText = document.querySelector(".inputlabel");
        var textBox = document.getElementById("inputGridValue");

        if (textBox != null) {           //added null pointer
            if (textBox.value != "") {
                ghostText.innerHTML = "";
            } else {
                ghostText.innerHTML = textBox.getAttribute("data-ghostText");
            }
        }

        if (timerCheck == null || timerCheck == "") {

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                if (e.getAttribute("data-inputType") == "singleSlider") {
                    MM.sliderInputEmptyCheck(e);
                } else if (e.getAttribute("data-inputType") == "dualSlider") {
                    MM.dualSliderInputEmptyCheck(e);
                } else if (e.getAttribute("data-inputType") == "searchInput" || e.getAttribute("data-inputType") == "messagingInput") {
                    MM.setKeyStrokesValue(e);
                }

            }, 2000);
            Timers.register(timerId);
            e.setAttribute("data-timerValue", timerId);
        } else {

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                if (e.getAttribute("data-inputType") == "singleSlider") {
                    MM.sliderInputEmptyCheck(e);
                } else if (e.getAttribute("data-inputType") == "dualSlider") {
                    MM.dualSliderInputEmptyCheck(e);
                } else if (e.getAttribute("data-inputType") == "searchInput" || e.getAttribute("data-inputType") == "messagingInput") {
                    MM.setKeyStrokesValue(e);
                }

            }, 2000);
            Timers.register(timerId);

            Timers.clearOne(timerCheck);
            e.setAttribute("data-timerValue", timerId);
        }
    },
    /**End of: timerInput**/

    /**Set the min key strokes, and do a partial Update once after key strokes are reached**/
    setKeyStrokesValue: function (e) {

        var text = e.value;
        if (text == null)
            text = e.innerHTML;

        var size = text.length;

        e.setAttribute("data-keyStrokesCheck", size);

        MM.searchValue(e);
    },

    searchValue: function (e) {

        if (e.getAttribute("data-type") == "UPDATE" && (parseInt(e.getAttribute("data-keyStrokesCheck")) >= parseInt(e.getAttribute("data-defaultKeyStrokes")))) {

            MM.partialUpdate(e);
            e.setAttribute("data-keyStrokesCheck", 0);
        } else if ((e.getAttribute("data-type") == "UPDATEFE" || e.getAttribute("data-type") == "SUBMITFE") && (parseInt(e.getAttribute("data-keyStrokesCheck")) >= parseInt(e.getAttribute("data-defaultKeyStrokes")))) {

            if (e.getAttribute("data-inputType") == "messagingInput") {
                //MM.saveText(e);
            } else {
                MM._partialUpdateFrontEnd(e, null, null);
            }
            e.setAttribute("data-keyStrokesCheck", 0);
        }
    },
    /**End of: Min Key Strokes functions**/

    /** checkBox value Set attribute **/

    checkBox: function (e) {

        var check = e.getAttribute("value");
        if (check == "N") {
            e.setAttribute("value", "Y");
        } else {
            e.setAttribute("value", "N");
        }

    },

    switcherInputInit: function () {

        var switchers = document.getElementsByClassName(" switcherInput");

        for (var switcher = 0; switcher < switchers.length; switcher++) {

            var check = switchers[switcher].getAttribute("value");

            switchers[switcher].setAttribute("value", check);

        }
    },

    /** End of: checkBox value Set attribute  **/


    /** iframe **/

    resizeIframe: function (iframe) {
        var clientHeight = iframe.parentElement.parentElement.clientHeight;
        var innerHeight = iframe.ownerDocument.body.scrollHeight;
        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;

        var useSpecialHeight = (innerHeight > clientHeight);
        if (useSpecialHeight) {
            iframe.style.height = "-webkit-fill-available";
        } else {
            iframe.style.height = innerHeight + "px";
        }

        if (iOS) {
            iframe.style.height = 0;
            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                if (useSpecialHeight) {
                    iframe.style.height = "-webkit-fill-available";
                } else {
                    iframe.style.height = innerHeight + "px";
                }

            }, 1000);
            Timers.register(timerId);
        }

    },

    /** End of: iframe **/

    /**Fix for blank screen, iOS version 10**/

    iOSHelpTabQuirk: function () {


        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
        var hamburgerCheck = document.querySelector(".hamburger");

        if (hamburgerCheck != null) {
            if (iOS) {

                var timerId = setInterval(function () {
                    Timers.clearOne(timerId);

                    Hamburger.toggle();
                    Hamburger.toggle();

                }, 500);
                Timers.register(timerId);
            }
        }
    },

    /**End of: Fix for blank screen, iOS version 10**/

    /**Suggestion Button Active State**/
    suggestionButtonActive: function (e) {

        var selectedBorderColour = e.getAttribute("data-selectedBorderColour");
        var selectedColour = e.getAttribute("data-selectedColour");
        var selectedTextColour = e.getAttribute("data-selectedTextColour");
        var defaultBorderColour = e.getAttribute("data-BorderColour");
        var defaultColour = e.getAttribute("data-Colour");
        var defaultTextColour = e.getAttribute("data-TextColour");
        var suggestionButtons = e.parentElement.parentElement.parentElement.querySelectorAll(".suggestionButton");

        for (var suggestButton = 0; suggestButton < suggestionButtons.length; suggestButton++) {

            suggestionButtons[suggestButton].style.borderColor = "1px " + defaultBorderColour + " solid";
            suggestionButtons[suggestButton].style.backgroundColor = defaultColour;
            suggestionButtons[suggestButton].style.color = defaultTextColour;
        }

        e.style.borderColor = "1px " + selectedBorderColour + " solid";
        e.style.backgroundColor = selectedColour;
        e.style.color = selectedTextColour;
    },
    /**End of: Suggestion Button **/

    /**Option Indicator Arrow and Swipe Left**/
    optionIndicator: function (e) {

        if (e.onclick != null) {
            var clickStatus = e.getAttribute("data-clicked");
            var optionLine = e.children[0];
            var optionIcon = e.children[1];

            //Using scroller object to scroll out then scroll back in
            if (clickStatus == "false" && window.getComputedStyle(e.parentElement.parentElement).transform.includes("-") == false) {
                e.setAttribute("data-clicked", "true");
                e.parentElement.parentElement.scroller.scrollTo(e.parentElement.parentElement.clientWidth, 0, true, 1, null);
                optionIcon.classList.remove("optionIcon");
                optionIcon.classList.add("optionIconOff");
                optionLine.style.display = "none";
            } else {
                e.setAttribute("data-clicked", "false");
                e.parentElement.parentElement.scroller.scrollTo(0, 0, true, 1, null);
                optionIcon.classList.remove("optionIconOff");
                optionIcon.classList.add("optionIcon");
                optionLine.style.display = "block";
            }
        }

    },

    optionIndicatorSwipeOpen: function (e) {
        var optionIndicatorContainer = e._elem.querySelector(".optionIndicator");
        var optionLine = optionIndicatorContainer.children[0];
        var optionIcon = optionIndicatorContainer.children[1];

        optionLine.style.display = "none";
        optionIndicatorContainer.setAttribute("data-clicked", "true");
        optionIcon.classList.remove("optionIcon");
        optionIcon.classList.add("optionIconOff");
    },

    optionIndicatorSwipeClose: function (e) {
        var optionIndicatorContainer = e._elem.querySelector(".optionIndicator");
        var optionLine = optionIndicatorContainer.children[0];
        var optionIcon = optionIndicatorContainer.children[1];

        optionLine.style.display = "block";
        optionIndicatorContainer.setAttribute("data-clicked", "false");
        optionIcon.classList.remove("optionIconOff");
        optionIcon.classList.add("optionIcon");
    },

    /**Slider and Dual MM**/
    sliderLoad: function () {

        var dualSliders = document.getElementsByClassName("dualSlider");

        for (var dualSlider = 0; dualSlider < dualSliders.length; dualSlider++) {

            MM.sliderInputColour(dualSliders[dualSlider]);
        }

    },
    /**Adjust colour lower half on the slider track**/
    sliderInput: function (e) {

        var min = e.min,
            max = e.max,
            val = e.value;

        e.style.backgroundSize = (((val - min) / (max - min)) * 100) + '% 100%';

    },

    /**Adjust colour lower half on the slider track**/
    sliderInputColour: function (e) {

        var parent = e.parentElement;
        var sliders = parent.children;
        var lower = sliders[0];
        var upper = sliders[1];
        var min = e.min;
        var max = e.max;

        upper.style.backgroundSize = (((parseInt(upper.value) - parseInt(lower.value)) / (parseInt(max) - parseInt(min))) * 100) + '%';

        upper.style.backgroundPositionX = ((parseInt(lower.value) / ((parseInt(max) - (parseInt(upper.value) - parseInt(lower.value))))) * 100) + '%';

    },

    /**Control inputbox using slider**/
    updateInputMM: function (e) {

        var singleSliderInput = document.getElementById(e.getAttribute("data-singleSliderInput"));
        var hiddenSlider = document.getElementById(e.getAttribute("data-hiddenInput"));
        var sliderType = e.getAttribute("data-type");

        singleSliderInput.value = e.value;
        singleSliderInput.setAttribute("value", e.value);
        hiddenSlider.value = e.value;

        if (sliderType == "UPDATE") {
            MM.partialUpdate(hiddenSlider, false);
        }

    },

    /**Slider input value less than min**/
    sliderInputEmptyCheck: function (e) {

        if (e.value == "") {
            e.value = "0";
        }

        MM.updateSlider(e);
    },

    /**Control slider using inputbox**/
    updateSlider: function (e) {

        var singleSliderKey = e.getAttribute("data-singleSliderKey");
        var sliderInputId = e.getAttribute("data-singleSliderId");
        var singleSlider = document.getElementById(singleSliderKey);
        var sliderType = singleSlider.getAttribute("data-type");
        var hiddenSlider = document.getElementById(singleSlider.getAttribute("data-hiddenInput"));

        MM.applyRestrictionsNumeric(e);

        if ((e.value >= parseInt(e.getAttribute("data-minValue"))) && (e.value <= parseInt(e.getAttribute("data-maxValue")))) {
            var step = singleSlider.getAttribute("step");
            if (e.value % step == 0) {
                singleSlider.value = e.value;
                singleSlider.setAttribute("value", e.value);
                hiddenSlider.value = e.value;
                MM.sliderInput(singleSlider);
                sliderType = singleSlider.getAttribute("data-type");

                if (sliderType == "UPDATE") {
                    MM.partialUpdate(hiddenSlider, false);
                }
            } else {
                e.value = Math.round(e.value / step) * step;
                singleSlider.value = e.value;
                singleSlider.setAttribute("value", e.value);
                hiddenSlider.value = e.value;
                MM.sliderInput(singleSlider);
                sliderType = singleSlider.getAttribute("data-type");

                if (sliderType == "UPDATE") {
                    MM.partialUpdate(hiddenSlider, false);
                }
            }

        } else if (e.value < parseInt(e.getAttribute("data-minValue"))) {
            e.value = parseInt(e.getAttribute("data-minValue"));
            singleSlider.value = e.value;
            singleSlider.setAttribute("value", e.value);
            hiddenSlider.value = e.value;
            MM.sliderInput(singleSlider);

            if (sliderType == "UPDATE") {
                MM.partialUpdate(hiddenSlider, false);
            }
        } else {
            e.value = parseInt(e.getAttribute("data-maxValue"));
            singleSlider.value = e.value;
            singleSlider.setAttribute("value", e.value);
            hiddenSlider.value = e.value;
            MM.sliderInput(singleSlider);

            if (sliderType == "UPDATE") {
                MM.partialUpdate(hiddenSlider, false);
            }
        }

    },

    /**Slider Thumb updater**/
    dualSliderUpper: function (e) {

        var lowerSlider = document.getElementById(e.getAttribute("data-lowerSlider"));
        var upperSlider = document.getElementById(e.getAttribute("data-upperSlider"));
        var lowerVal = parseInt(lowerSlider.value);
        var upperVal = parseInt(upperSlider.value);

        if (upperVal <= lowerVal) {

            if (lowerVal == lowerSlider.min) {
                upperSlider.value = lowerVal + parseInt(e.getAttribute("data-distance"));
            } else {
                lowerSlider.value = upperVal - parseInt(e.getAttribute("data-distance"));
            }
        }
    },


    dualSliderLower: function (e) {

        var lowerSlider = document.getElementById(e.getAttribute("data-lowerSlider"));
        var upperSlider = document.getElementById(e.getAttribute("data-upperSlider"));
        var lowerVal = parseInt(lowerSlider.value);
        var upperVal = parseInt(upperSlider.value);

        if (lowerVal >= upperVal - parseInt(e.getAttribute("data-distance"))) {
            upperSlider.value = lowerVal + parseInt(e.getAttribute("data-distance"));

            if (upperVal == upperSlider.max) {
                lowerSlider.value = parseInt(upperSlider.max) - parseInt(e.getAttribute("data-distance"));
            }

        }
    },

    /**END: Slider Thumb updater**/

    dualSliderOnload: function (e) {

        var onLoadStatus = e.getAttribute("data-onLoadStatus");
        var min = e.getAttribute("data-minValue");
        var max = e.getAttribute("data-maxValue");
        var value = e.value;

        if (onLoadStatus == "true" && value == min) {
            e.value = "";
            e.setAttribute("value", "");
            e.setAttribute("data-onLoadStatus", "false");
        }
    },

    /**Update Inputbox values using Sliders**/

    updateInputMMDualSlider: function (e) {

        var dualSliderKey = e.getAttribute("data-dualSliderKey");
        var dualSlider = document.getElementById(dualSliderKey);
        var dualSliders = dualSlider.children;
        var hiddenInput = document.getElementById(e.getAttribute("data-hiddenInput"));
        var lowerValue, upperValue;
        var hiddenInput = hiddenInput;
        var sliderType = dualSliders[0].getAttribute("data-type");
        var upperInput = document.getElementById("upperInput_" + dualSliderKey);
        var lowerInput = document.getElementById("lowerInput_" + dualSliderKey);


        lowerInput.value = dualSliders[0].value;
        lowerInput.setAttribute("value", dualSliders[0].value);
        dualSliders[0].setAttribute("value", dualSliders[0].value);
        dualSliders[0].value = dualSliders[0].value;
        lowerValue = dualSliders[0].value;

        upperInput.value = dualSliders[1].value;
        upperInput.setAttribute("value", dualSliders[1].value);
        dualSliders[1].setAttribute("value", dualSliders[1].value);
        dualSliders[1].value = dualSliders[1].value;
        upperValue = dualSliders[1].value;

        hiddenInput.setAttribute("value", lowerValue + "," + upperValue);

        if (sliderType == "UPDATE") {
            MM.partialUpdate(hiddenInput, false);
        }

    },
    /**Check if dual slider input for empty value**/
    dualSliderInputEmptyCheck: function (e) {

        var adjacentInput = document.getElementById(e.getAttribute("data-adjacentSibling"));


        if (e.value != "" && adjacentInput.value != "") {

            MM.updateDualSliderInputMM(e);
        } else if (e.id.indexOf("lowerInput") > -1 && e.value == "") {
            var minValue = e.getAttribute("data-minValue");
            var lowerDualSlider = document.getElementById(e.getAttribute("data-dualSliderKey")).children;

            lowerDualSlider[0].value = parseInt(minValue);
            lowerDualSlider[0].setAttribute("value", minValue);
            MM.sliderInputColour(lowerDualSlider[0]);

        } else if (e.id.indexOf("upperInput") > -1 && e.value == "") {
            var maxValue = e.getAttribute("data-maxValue");
            var upperDualSlider = document.getElementById(e.getAttribute("data-dualSliderKey")).children;


            upperDualSlider[1].value = parseInt(maxValue);
            upperDualSlider[1].setAttribute("value", maxValue);
            MM.sliderInputColour(upperDualSlider[1]);

        } else {
            var dualSlider = document.getElementById(e.getAttribute("data-dualSliderKey")).children;
            var dualSliderIndex = parseInt(e.getAttribute("data-dualSliderIndex"));
            var min = parseInt(e.getAttribute("data-minValue"));
            var max = parseInt(e.getAttribute("data-maxValue"));

            if (e.value >= min && e.value <= max) {
                e.value = parseInt(e.value);
                e.setAttribute("value", e.value);
                dualSlider[dualSliderIndex].value = parseInt(e.value);
                dualSlider[dualSliderIndex].setAttribute("value", e.value);
                MM.sliderInputColour(dualSlider[dualSliderIndex]);
            } else if (e.id.indexOf("lowerInput") > -1) {
                e.value = min;
                e.setAttribute("value", e.value);
                dualSlider[dualSliderIndex].value = parseInt(e.value);
                dualSlider[dualSliderIndex].setAttribute("value", e.value);
                MM.sliderInputColour(dualSlider[dualSliderIndex]);
            } else {
                e.value = max;
                e.setAttribute("value", e.value);
                dualSlider[dualSliderIndex].value = parseInt(e.value);
                dualSlider[dualSliderIndex].setAttribute("value", e.value);
                MM.sliderInputColour(dualSlider[dualSliderIndex]);
            }
        }

    },
    /** Control slider using inputbox **/

    updateDualSliderInputMM: function (e) {

        var dualSliderKey = e.getAttribute("data-dualSliderKey");
        var dualSlider = document.getElementById(dualSliderKey);
        var dualSliders = dualSlider.children;
        var sliderType = dualSliders[0].getAttribute("data-type");
        var hiddenInput = document.getElementById(e.getAttribute("data-hiddenInput"));
        var lowerValue, upperValue;

        MM.applyRestrictionsNumeric(e);

        if (e.id.indexOf("lower") > -1) {

            var upperInput = document.getElementById(e.getAttribute("data-upperInput"));

            if (parseInt(e.value) < parseInt(e.getAttribute("data-minValue"))) {

                e.value = parseInt(e.getAttribute("data-minValue"));
                e.setAttribute("value", e.value);
            } else if (parseInt(e.value) > parseInt(e.getAttribute("data-maxValue"))) {

                e.value = parseInt(e.getAttribute("data-maxValue")) - parseInt(dualSliders[0].getAttribute("step"));
                e.setAttribute("value", e.value);
                dualSliders[1].value = e.getAttribute("data-maxValue");
                dualSliders[1].setAttribute("value", dualSliders[1].value);
            }

            if (parseInt(e.value) <= (parseInt(upperInput.value) - parseInt(dualSliders[0].getAttribute("step")))) {

                if (parseInt(e.value) == parseInt(upperInput.value)) {

                    upperInput.value = parseInt(e.value) + parseInt(dualSliders[0].getAttribute("step"));
                    upperInput.setAttribute("value", upperInput.value);
                }
                dualSliders[0].value = e.value;
                dualSliders[0].setAttribute("value", e.value);
                dualSliders[0].value = e.value;
                lowerValue = dualSliders[0].value;
                upperValue = upperInput.value;
                MM.sliderInputColour(dualSliders[0]);
            } else {

                var newValue = (parseInt(e.value) - parseInt(dualSliders[0].getAttribute("step"))).toString();
                dualSliders[0].value = newValue;
                dualSliders[0].setAttribute("value", newValue);
                e.value = newValue;
                e.setAttribute("value", newValue);
                lowerValue = dualSliders[0].value;
                upperValue = upperInput.value;
                MM.sliderInputColour(dualSliders[0]);
            }
        }

        if ((e.id.indexOf("upper") > -1)) {

            var lowerInput = document.getElementById(e.getAttribute("data-lowerInput"));

            if (parseInt(e.value) < parseInt(e.getAttribute("data-minValue"))) {

                e.value = parseInt(e.getAttribute("data-minValue")) + parseInt(dualSliders[0].getAttribute("step"));
                e.setAttribute("value", e.value);
                dualSliders[0].value = e.getAttribute("data-minValue");
                dualSliders[0].setAttribute("value", dualSliders[0].value);
            } else if (parseInt(e.value) > parseInt(e.getAttribute("data-maxValue"))) {

                e.value = parseInt(e.getAttribute("data-maxValue"));
                e.setAttribute("value", e.value);
            }

            if (parseInt(e.value) >= parseInt(lowerInput.value)) {

                if (parseInt(e.value) == parseInt(lowerInput.value)) {
                    e.value = parseInt(e.value) + parseInt(dualSliders[0].getAttribute("step"));
                }

                dualSliders[1].value = e.value;
                dualSliders[1].setAttribute("value", e.value);
                dualSliders[1].value = e.value;
                lowerValue = lowerInput.value;
                upperValue = dualSliders[1].value;
                MM.sliderInputColour(dualSliders[1]);
            } else {
                var newValue = (parseInt(dualSliders[0].value) + parseInt(dualSliders[0].getAttribute("step"))).toString();
                dualSliders[1].value = newValue;
                dualSliders[1].setAttribute("value", newValue);
                e.value = newValue;
                e.setAttribute("value", newValue);
                lowerValue = lowerInput.value;
                upperValue = dualSliders[1].value;
                MM.sliderInputColour(dualSliders[1]);
            }
        }

        hiddenInput.setAttribute("value", lowerValue + "," + upperValue);

        if (sliderType == "UPDATE") {
            MM.partialUpdate(hiddenInput, false);
        }

    },

    /**END: Slider and Dual MM**/

    /** Input Restrictions using Type **/

    applyRestrictionsNumeric: function (e) {
        //Elton: Splitting single line into two fixed issue where restriction does not work on certain tablets (IPad)
        var restrictionResult = e.value.replace(/[^0-9]/g, "");
        e.value = restrictionResult;
    },

    applyRestrictionsAmount: function (e) {
        e.value = e.value.replace(/[^0-9.]/g, "");
    },

    applyRestrictionsAlphaNumericSpecial: function (e) {
        e.value = e.value.replace(/[^A-Za-z0-9!@#$%^&*()_\+\=\-\{\[\}\]\\\|\;\:\'\"\,\<\.\>\/\? ]/g, "");
    },

    applyRestrictionsCard: function(e, hiddenId){
       var hiddenInput =document.getElementById(hiddenId);
        e.value = e.value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
        var matches = e.value.match(/\d{4,16}/g);
        var match = matches && matches[0] || '';
        var parts = [];
        var len = match.length;
        for (var i=0; i<len; i+=4) {
            parts.push(match.substring(i, i+4))
        }
        if (parts.length) {
            e.value = parts.join(' ')
        }
        hiddenInput.value = e.value.replace(/\s+/g, '');
        return e.value;
    },
    onpasteCard : function(e, hiddenId){
        setTimeout(function(){
            MM.applyRestrictionsCard(e, hiddenId);
        }, 4); //or 4
    },
    /** End of: Input Restrictions using Type **/

    /** Reset Error Text**/

    resetErrorText: function (e) {

        e.setAttribute("data-error", "false");
        var errorTextAreaLabel = e.parentElement.parentElement.querySelector('.errorTextleft');
        var leftLabel = e.parentElement.querySelector('.inputlabelLeft');
        if (leftLabel != null) {
            if (leftLabel != null && leftLabel != "") {
                leftLabel.innerText = "";
            }
        }
        if (errorTextAreaLabel != null) {
            if (errorTextAreaLabel != null && errorTextAreaLabel != "") {
                errorTextAreaLabel.innerText = "";
            }
        }

        //change colour of label back to labelColour once errorText is cleared
        var inputLabel = e.parentElement.children[2];
        if (inputLabel != null) {
            inputLabel.setAttribute("data-error", "false");
        }

    },
    dateTimeResetErrorText: function (e) {

        e.setAttribute("data-error", "false");
        var dateTimePickerLeft = e.parentElement.querySelector('.dateTimePickerLeft');
        if (dateTimePickerLeft != null && dateTimePickerLeft != "") {
            dateTimePickerLeft.innerText = "";
        }

    },

    /** End of: Reset Error Text**/

    /** Reset numericSelection Error text **/


    resetNumericError: function (e) {

        //e.parentElement.parentElement.querySelector
        var errorTextLabel = e.parentElement.parentElement.querySelector('.numericSelectionErrorText');
        var hintTextLabel = e.parentElement.parentElement.querySelector('.numericSelectionHintText');
        var LableBottomLine = e.parentElement.parentElement.querySelector('.numericSelectionBottomLine');

        if (errorTextLabel != null) {
            errorTextLabel.innerText = "";
            // LableBottomLine.style.borderBottomColor="#fff";
        }
        if (hintTextLabel != null) {
            hintTextLabel.innerText = "";
        }

    },
    /** End of numericErrorSelection Error Text **/



    /**This function changes the icon when the Checkable Readout is clicked**/

    checkableReadoutImage: function (e) {

        var textDiv = e.querySelector('.richTextCheckableIconText');
        var icon = e.querySelector('.readoutCheckableIcon');
        var check = document.getElementById(e.getAttribute("data-checkableHidden"));

        if (check.getAttribute("value") == "N") {

            if (textDiv.getAttribute("data-selectedText") != "" && textDiv.getAttribute("data-selectedText") != "-") {
                textDiv.innerText = textDiv.getAttribute("data-selectedText");
            } else {
                textDiv.innerText = "";
            }
            textDiv.style.backgroundColor = "transparent";
            icon.style.backgroundImage = "url(" + icon.getAttribute("data-selectedIcon") + ")";
            check.value = "Y";

        } else {

            textDiv.innerText = textDiv.getAttribute("data-text");
            textDiv.style.backgroundColor = textDiv.getAttribute("data-bgColour");
            icon.style.backgroundImage = "url(" + icon.getAttribute("data-icon") + ")";
            check.value = "N";

        }

    },

    /**End of checkableReadoutImage**/


    /**Set Card Container height using Fill attribute**/

    cardFill: function () {

        var cards = document.querySelectorAll(".cardContainer");

        if (cards != null && cards.length > 0) {
            for (var card = 0; card < cards.length; card++) {

                var parentHeight = cards[card].parentElement.clientHeight;
                var pagerDotHeight = 2;

                if (cards[card].getAttribute("data-height") == "FILL") {
                    cards[card].style.height = "calc(" + ((parentHeight / Root.unit()) - pagerDotHeight) + " * var(--unit))";
                }
            }
        }

    },

    /**End of CardFill**/

    /**Hide Header and Footer when popup is displayed**/
    popupHeaderFooterHide: function () {

        //Cater for multiple kinds of pop ups and UFF screen sizes
        var popUpContainers = document.querySelectorAll(".popUpContainer");
        popUpContainers = popUpContainers == null || popUpContainers.length < 1 ? document.querySelectorAll(".popUpSectionContainer_messaging") : popUpContainers;

        var popUpBackdrops = document.querySelectorAll(".popUpBackdrop");
        popUpBackdrops = popUpBackdrops == null || popUpBackdrops.length < 1 ? document.querySelectorAll(".popUpBackdrop_messaging") : popUpBackdrops;

        for (i = 0; i < popUpContainers.length; i++) {
            var popUpContainer = popUpContainers[i];
            var popUpBackdrop = popUpBackdrops[i];

            var popUp = popUpContainer.querySelector(".popUpSectionContainer");
            popUp = popUp == null || popUp.length < 1 ? popUpContainer.querySelector(".popUpSectionContainer_messaging") : popUp;

            var baseWidth = window.getComputedStyle(document.getElementById("base-content")).width;

            if (popUp != null && popUpBackdrop != null && popUpContainer != null) {
                popUp.style.width = baseWidth;
                popUpBackdrop.style.width = baseWidth;
                popUpContainer.style.width = baseWidth;
            }

            //move popups to form for 3 panel view
            var baseBodyPanelContainer = document.getElementById("baseBodyPanelContainer");
            if (baseBodyPanelContainer != null) {
                var popupSymbol = popUpContainer.parentElement;
                var formContents = document.getElementById("formContents");
                if (formContents != null) {
                    formContents.insertBefore(popupSymbol, baseBodyPanelContainer);
                }
            }
        }

        var timerId = setInterval(function () {
            Timers.clearOne(timerId);

            //Elton: This is to ignore the forced removal of the on screen keyboard for partial updates
            //This is done by adding the class name "ignoreKeyboardRemoval" to your element
            //This is done in two functions (_partialUpdateFrontEnd, partialUpdateResponseHandler)
            //and once in the popupHeaderFooterHide function to avoid incorrect spacing on the composebar after partial update
            if (document.querySelector(".ignoreKeyboardRemoval") != null) {
                return;
            }

            var popupHeader = document.querySelector(".header");
            var popupFooter = document.querySelector(".footer");
            var popUp = document.querySelector(".popUpSectionContainer");
            var header = document.getElementById(".headerFixed");
            var footer = document.getElementById(".footer");

            if (popUp !== null) {
                (popupHeader != null && header != null) ? header.classList.add("hideHeader") : null;
                (popupFooter != null && footer != null) ? footer.classList.add("hideFooter") : null;
            } else {
                (popupHeader != null && header != null) ? header.classList.remove("hideHeader") : null;
                (popupHeader != null && header != null) ? header.classList.add("showHeader") : null;
                (popupFooter != null && footer != null) ? footer.classList.remove("hideFooter") : null;
            }
        }, 601);
        Timers.register(timerId);
    },

    /** Probably correct: Used to calculate inflates to push content from underneath header and footer in structured container. **/

    structuredContainerHeaderFooterCalc: function () {

        var structContainers = document.querySelectorAll(".StructuredContainer");

        for (var i = 0; i < structContainers.length; i++) {

            var structContainer = structContainers[i];
            var header = structContainer.querySelector(".StructuredContainerHeader");
            var footer = structContainer.querySelector(".StructuredContainerFooter");
            var headerInflate = structContainer.querySelector(".StructuredContainerHeaderInflate");
            var footerInflate = structContainer.querySelector(".StructuredContainerFooterInflate");
            if (header != null && headerInflate != null) {

                headerInflate.style.height = "calc(" + (header.clientHeight / Root.unit()) + " * var(--unit))";

                //set width dynamically because header is fixed
                header.style.width = header.parentElement.offsetWidth + "px";
            }

            if (footer != null && footerInflate != null) {

                var parentContainer = structContainer.parentElement;
                var newFooterHeight = footer.clientHeight;

                if (parentContainer.classList.contains("popUpSectionContent")) {
                    /**Extra inflate for close button on popup**/
                    if (parentContainer.getAttribute("data-popCornerIcon") == "true") {
                        newFooterHeight += 20;
                    }
                }

                footerInflate.style.height = "calc(" + (newFooterHeight / Root.unit()) + " * var(--unit))";
            }

            //When switching between dark/light mode the time taken to load resources can cause issues with the calculation. Leaving it unset works for this particular instance
            if (structContainer.parentNode.innerText == "Dark Mode") {
                structContainer.style.height = "unset";
            } else {

                var base = document.getElementById("base-content");

                var totalHeightNotBase = Root.getTotalHeightAboveEl(base);
                var lastElement = document.getElementById("lastElement");
                totalHeightNotBase += lastElement != null ? lastElement.offsetHeight : 0;

                var windowInnerHeight = window.innerHeight + "px";

                structContainer.style.height = "unset";
                var bodyContents = document.getElementById("formContents");
                if (lastElement == null || (bodyContents.offsetHeight + totalHeightNotBase) < window.innerHeight) {
                    totalHeightNotBase += "px";
                    structContainer.style.height = "calc(" + windowInnerHeight + " - " + totalHeightNotBase + ")";
                }
            }
        }

        //webview is cut off if height is not set to 100%
        var structuredContainerBody = document.querySelector(".StructuredContainerBody");
        if(structuredContainerBody != null && structuredContainerBody.querySelector(".mm_webview") != null) {
            structuredContainerBody.style.height = "100%";
        }

    },

    /**End of structuredContainerHeaderFooterCalc**/

    /*
     *This function is used to calc total width off 2de level children
     */
    setDivWidth: function () {
        var contentWidth = 0;
        var setWidthArray = document.querySelectorAll("[data-scrollable-set-width='true']");
        for (var arrayCount = 0; arrayCount < setWidthArray.length; arrayCount++) {
            for (var index = 0; index < setWidthArray[arrayCount].children.length; index++) {
                contentWidth += setWidthArray[arrayCount].children[index].firstElementChild.offsetWidth;
            }
            setWidthArray[arrayCount].style.width = "calc(" + Math.round(contentWidth / Root.unit()) + " * var(--unit))";
            contentWidth = 0;
        }
    },

    /**This function sets the width of Pager if the parent of the pager is not
     * Full screen
     * i.e. Pager may need to wrap width according to the width of a Card
     * **/
    wrapPagerInParent: function () {

        var pagerContents = document.querySelectorAll(".pagerContent");

        for (var pagerContent = 0; pagerContent < pagerContents.length; pagerContent++) {

            var cards = pagerContents[pagerContent].getAttribute("data-cards");
            // var pagerParentWidth = pagerContents[pagerContent].parentElement.parentElement.parentElement.clientWidth / Root.unit();
            var dataPagerWidth = pagerContents[pagerContent].getAttribute("data-pagerWidth");
            var pagerParentWidth = dataPagerWidth != "" && dataPagerWidth != "75" ? dataPagerWidth : document.getElementById("base-content").clientWidth / Root.unit();
            var pager = pagerContents[pagerContent].parentElement;

            pager.style.width = "calc(" + pagerParentWidth + " * var(--unit))";

            if (cards != null) {
                pagerContents[pagerContent].style.width = "calc(" + cards + " * " + pagerParentWidth + " * var(--unit))";
            }

        }

    },

    /**End of wrapPagerInParent**/


    /**Applying Center Crop property on Image**/

    imageLoad: function (e) {


        if (e.parentElement.getAttribute("data-scaleType") == "CENTER_CROP") {

            var parentWidth = e.parentElement.clientWidth;
            var img_full = e.parentElement.parentElement;
            var dataHeight = e.parentElement.getAttribute("data-height");
            var style = document.getElementById("imageUFFStyling");
            var uffMaxHeightIncrease = 77;

            if (dataHeight !== "" && dataHeight !== null) {

                if (dataHeight == "FILL") {
                    e.style.height = "100%";
                    e.style.width = "100%";
                } else {
                    e.style.height = "calc(" + dataHeight + " * var(--unit))";
                    Root.applyMaxHeightForUFF(e, 500, (dataHeight + uffMaxHeightIncrease));
                    e.style.maxWidth = "100%";

                    //fix to stretch image symbols to 100% of width for uff
                    var addToScreen = false;
                    if (style == null) {
                        style = document.createElement('style');
                        style.type = 'text/css';
                        style.id = "imageUFFStyling";
                        addToScreen = true;
                    }

                    var elementHeight = e.parentElement.getAttribute("data-height");
                    if(elementHeight == "FILL" || elementHeight == "" ){
                        style.innerHTML += '@media (min-width: 600px) { .image_img {width:100%; }}';
                    }

                    if (addToScreen)
                        e.parentElement.appendChild(style);
                }

            } else if (e.clientWidth < parentWidth && e.className != "image_full_img" && e.className === "image_img") {
                e.style.width = "calc(" + parentWidth / Root.unit() + " * var(--unit))";

            } else {
                MM.getPager(img_full);
            }

            //check to see if e(image) has a layeredContainer as its parent
            //if this is true then remove layerContainers height of 100%
            //made it auto so it takes the height of its children
            if (e.className != "image_full_img" && dataHeight !== "FILL" && e.className === "image_img") {
                var layerContainer = document.querySelector(".layeredContainer");
                if (layerContainer != null) {
                    var imageInLayeredContainer = layerContainer.querySelector(".image_img");
                    if (imageInLayeredContainer == e) {
                        layerContainer.style.height = 'auto';
                    }
                }
            }

            var parentHeight = e.parentElement.clientHeight;
            var parent = e.parentElement;
            var imageHeight = e.clientHeight;

            if (e.clientHeight < parentHeight && e.className != "image_full_img" && dataHeight !== "FILL" && e.className === "image_img") {

                e.style.height = "calc(" + parentHeight / Root.unit() + " * var(--unit))";
                Root.applyMaxHeightForUFF(e, 500, (parentHeight + uffMaxHeightIncrease) / Root.unit());

                parent.style.height = "calc(" + imageHeight / Root.unit() + " * var(--unit))";
                Root.applyMaxHeightForUFF(parent, 500, (imageHeight + uffMaxHeightIncrease) / Root.unit());

            } else if (e.className == "image_full_img") {

                /**
                 *Set Image_Full to the size of Layered Container or
                 * the size of (parent - children: excluded current Image_Full) if the
                 *Image_Full does not live in a Layered Container
                 *i.e. if the Image lives in Stacked Container, its true height should be
                 * the height of the container minus the Image's siblings
                 * **/

                var containerType = e.parentElement.parentElement.parentElement;
                var containerHeight = containerType.clientHeight;


                if (containerType.classList.contains("layeredContainer")) {

                    e.style.height = "calc(" + containerHeight / Root.unit() + " * var(--unit))";
                    Root.applyMaxHeightForUFF(e, 500, containerHeight / Root.unit());

                    parent.style.height = "calc(" + containerHeight / Root.unit() + " * var(--unit))";
                    Root.applyMaxHeightForUFF(parent, 500, containerHeight / Root.unit());

                } else if (containerType.classList.contains("pagerContent")) {

                    containerHeight = containerType.parentElement.clientHeight;
                    parent.style.height = "calc(" + containerHeight / Root.unit() + " * var(--unit))";
                    Root.applyMaxHeightForUFF(parent, 500, containerHeight / Root.unit());

                } else {

                    var children = containerType.children;
                    var imgId = e.parentElement.parentElement.id;
                    var siblingsHeight = 0;

                    for (var child = 0; child < children.length; child++) {

                        if (children[child].id != imgId) {

                            siblingsHeight += children[child].clientHeight;
                        }

                    }

                    parent.style.height = "calc(" + (containerHeight - siblingsHeight) / Root.unit() + " * var(--unit))";
                }
            }
            e.style.visibility = "visible";
            MM.structuredContainerHeaderFooterCalc();

        } else if (e.parentElement.getAttribute("data-scaleType") == "CENTER_FIT" || e.parentElement.getAttribute("data-height") == "FILL") {
            e.style.height = "100%";
            e.style.visibility = "visible";
            MM.structuredContainerHeaderFooterCalc();
        }
        MM.setCollapsableContainer();

    },

    /**End of imageLoad **/

    getPager: function (img_full) {


        var pagers = document.querySelectorAll(".pagerContainer");

        for (var pager = 0; pager < pagers.length; pager++) {

            var pagerContent = pagers[pager].querySelector(".pagerContent");
            var pagerContentChildren = pagerContent.children;

            for (var pagerContentChild = 0; pagerContentChild < pagerContentChildren.length; pagerContentChild++) {

                if (pagerContentChildren[pagerContentChild].id == img_full.id) {

                    img_full.style.width = "calc(" + pagers[pager].clientWidth / Root.unit() + " * var(--unit))";
                }

            }

        }

    },

    setPagerHeightUFF: function () {
        if (window.matchMedia("(min-width: 500px)").matches) {
            var pagers = document.querySelectorAll(".pagerContainer");

            if (pagers != null && pagers.length != 0) {
                for (var pager = 0; pager < pagers.length; pager++) {

                    //Take height of pager radio and the have the pager content fill the parent 100% minus that height so that both elements fit in parent as expected
                    var pagerRadioContent = pagers[pager].parentElement.querySelector(".pagerRadioContent");
                    var pagerRadioContentHeight = pagerRadioContent != null ? pagerRadioContent.clientHeight : 0;
                    pagers[pager].style.height = "calc(100% - " + pagerRadioContentHeight + "px)";

                }
            }
        }
    },

    headerNoShadow: function () {

        var headers = document.getElementsByClassName("header");

        for (var header = 0; header < headers.length; header++) {

            var headerClasses = headers[header].className.split(" ");
            var headerUp = "";

            for (var headerClass = 0; headerClass < headerClasses.length; headerClass++) {

                if (headerClasses[headerClass] == "headerContainer") {
                    headerUp += " headerContainerNoBottomLine";
                } else {
                    headerUp += " " + headerClasses[headerClass];
                }
            }
            headers[header].className = headerUp;
        }
    },

    headerOverlay: function () {


    },

    /** BEGIN: Message long press **/

    controlMessageOptions: function (e, addRemove, headerToolbar, counter) {
        var options = e.querySelector(".messaging").getAttribute("data-messageOptions");

        //Reset
        MM.resetMessagingHeaders();

        //For every element with an option we add/remove to the relevant counter when the user selects/un-selects it
        //When the messaging option type counter is equal to the standard counter (Number of selected messages) that message option is valid for all selected messages
        if (addRemove == "ADD") {

            if (options.includes("COPY") == true) {
                headerToolbar.copyCounter++;
            }

            if (options.includes("FORWARD") == true) {
                headerToolbar.forwardCounter++;
            }

            if (options.includes("REPLY") == true) {
                headerToolbar.replyCounter++;
            }

            if (options.includes("DELETE") == true) {
                headerToolbar.deleteCounter++;
            }

            if (options.includes("DELETE_FOR_EVERYONE") == true) {
                headerToolbar.deleteForEveryone++;
            }

            //Store texts for copy
            MM.storeMessageTexts(e, headerToolbar.keyTextPair, options, addRemove, headerToolbar);

            //store from label
            MM.storeFromLabelsAndIds(e, options, addRemove, headerToolbar);

        } else if (addRemove == "REMOVE") {

            if (options.includes("COPY") == true) {
                headerToolbar.copyCounter--;
            }

            if (options.includes("FORWARD") == true) {
                headerToolbar.forwardCounter--;
            }

            if (options.includes("REPLY") == true) {
                headerToolbar.replyCounter--;
            }

            if (options.includes("DELETE") == true) {
                headerToolbar.deleteCounter--;
            }

            if (options.includes("DELETE_FOR_EVERYONE") == true) {
                headerToolbar.deleteForEveryone--;
            }

            //Remove texts for copy
            MM.storeMessageTexts(e, headerToolbar.keyTextPair, options, addRemove, headerToolbar);

            //store from label
            MM.storeFromLabelsAndIds(e, options, addRemove, headerToolbar);
        }

        //Display
        if (headerToolbar.copyCounter == counter) {
            document.querySelector(".messagingHeaderCopy").style.display = "";
            document.querySelector(".messagingHeaderCopy").style.pointerEvents = "auto";
        }

        if (headerToolbar.forwardCounter == counter) {
            document.querySelector(".messagingHeaderForward").style.display = "";
            document.querySelector(".messagingHeaderForward").style.pointerEvents = "auto";
        }

        if (headerToolbar.replyCounter == counter && counter <= 1) {
            document.querySelector(".messagingHeaderReply").style.display = "";
            document.querySelector(".messagingHeaderReply").style.pointerEvents = "auto";
        }

        if (headerToolbar.deleteCounter == counter) {
            document.querySelector(".messagingHeaderDelete").style.display = "";
            document.querySelector(".messagingHeaderDelete").style.pointerEvents = "auto";
        }

    },

    swipeToReply: function (e) {
        if (e != null && e._elem != null) {
            MM._partialUpdateFrontEnd(e._elem.parentElement, null, null);
        }
    },

    storeFromLabelsAndIds: function (e, options, addRemove, headerToolbar) {

        var fromLabelAndMessageIdPair = headerToolbar.fromLabelAndMessageIdPair;

        if (fromLabelAndMessageIdPair != null) {

            if (addRemove == "ADD") {
                if (options.includes("DELETE") == true || options.includes("DELETE_FOR_EVERYONE")) {
                    if (e.querySelector(".messaging").getAttribute("data-messageFromLabel") != null && e.querySelector(".messaging").getAttribute("data-messageFromLabel") != "") {
                        fromLabelAndMessageIdPair.fromLabels.push(e.querySelector(".messaging").getAttribute("data-messageFromLabel"));
                        fromLabelAndMessageIdPair.ids.push(e.querySelector(".messaging").getAttribute("data-messageId"));
                        headerToolbar.fromLabelAndMessageIdPair = fromLabelAndMessageIdPair;
                    }
                }

            } else if (addRemove == "REMOVE") {
                //Remove specific un-selected fromLabel arrays
                var index = 0;

                fromLabelAndMessageIdPair.ids.every(function removeLabel(id) {

                    if (e.querySelector(".messaging").getAttribute("data-messageId") == id) {
                        fromLabelAndMessageIdPair.ids.splice(index, 1);
                        fromLabelAndMessageIdPair.fromLabels.splice(index, 1);
                        return false;
                    }
                    index++;
                    return true;
                });
            }

            headerToolbar.fromLabelAndMessageIdPair = fromLabelAndMessageIdPair;
        }
    },

    storeMessageTexts: function (target, keyTextPair, options, addRemove, headerToolbar) {

        if (keyTextPair != null) {

            if (addRemove == "ADD") {
                //Store multiple text values for multiple copies
                if (options.includes("COPY") == true) {
                    var messageBubble = null;
                    if (target.querySelector(".messageBubbleText") != null) {
                        messageBubble = target.querySelector(".messageBubbleText");
                    } else if (target.querySelector(".messageBubbleMapMapText") != null) {
                        messageBubble = target.querySelector(".messageBubbleMapMapText");
                    } else if (target.querySelector(".messageBubbleParentText") != null) {
                        messageBubble = target.querySelector(".messageBubbleParentText");
                    }

                    if (messageBubble != null) {
                        var plainText = messageBubble.getAttribute("data-plainTextWithoutFormatting") != null ? messageBubble.getAttribute("data-plainTextWithoutFormatting") : messageBubble.innerText;
                        plainText = MM.removeHtmlTags(plainText);
                        plainText = plainText.trimStart();
                        keyTextPair.texts.push(plainText);
                        keyTextPair.ids.push(target.id);
                    }
                }

            } else if (addRemove == "REMOVE") {
                //Remove specific un-selected text from copy arrays
                var index = 0;

                keyTextPair.texts.forEach(function removeText(element) {

                    if (target.querySelector(".messageBubbleText") != null) {
                        if (element == target.querySelector(".messageBubbleText").innerText) {
                            keyTextPair.texts.splice(index, 1);
                            keyTextPair.ids.splice(index, 1);
                        }
                    } else if (target.querySelector(".messageBubbleMapMapText") != null) {
                        if (element == target.querySelector(".messageBubbleMapMapText").innerText) {
                            keyTextPair.texts.splice(index, 1);
                            keyTextPair.ids.splice(index, 1);
                        }
                    } else if (target.querySelector(".messageBubbleParentText") != null) {
                        if (element == target.querySelector(".messageBubbleParentText").innerText) {
                            keyTextPair.texts.splice(index, 1);
                            keyTextPair.ids.splice(index, 1);
                        }
                    }

                    index++;
                });

            }

            headerToolbar.keyTextPair = keyTextPair;

        }

    },

    copyMessagingToClipboard: function () {
        var headerToolbar = document.querySelector(".messagingHeaderOptions");
        var textarea = document.createElement("textarea");
        var texts = headerToolbar.keyTextPair.texts;

        texts.forEach(function getText(element) {
            //Don't add line break to last text
            if (texts[texts.length - 1] == element) {
                textarea.innerHTML += element;
            } else {
                textarea.innerHTML += element + "\n";
            }
        });

        document.body.appendChild(textarea);

        textarea.focus();
        textarea.select();
        document.execCommand('copy');
        textarea.parentNode.removeChild(textarea);

        MM.removeMessagingHeader();
    },

    messageLongPressAction: function (action) {

        var headerToolbar = document.querySelector(".messagingHeaderOptions");

        if (action == "replyMessage") {
            MM._partialUpdateFrontEnd(headerToolbar, headerToolbar.getAttribute("data-reply"), null);
            MM.removeMessagingHeader();
        } else if (action == "deleteMessage") {
            MM._partialUpdateFrontEnd(headerToolbar, headerToolbar.getAttribute("data-delete"), null);
            MM.removeMessagingHeader();
        } else if (action == "deleteMessageOptions") {

            var counter = document.querySelector(".messagingHeaderCounter");
            var selectedMessageCounter = counter.innerText != '' ? parseInt(counter.innerText) : 0;

            var deleteMessageOptionsContainer = document.getElementById("deleteMessageOptionsContainer");

            var deleteMessageOptionsHeader = deleteMessageOptionsContainer.querySelector(".deleteMessageOptionsHeader");

            var popupText = null;
            var fromLabelAndMessageIdPair = headerToolbar.fromLabelAndMessageIdPair;

            if (selectedMessageCounter == 1)
                popupText = fromLabelAndMessageIdPair.fromLabels[0] != null && fromLabelAndMessageIdPair.fromLabels[0] != "" ? "Delete message from " + fromLabelAndMessageIdPair.fromLabels[0] + "?" : null;

            popupText = popupText != null ? popupText : selectedMessageCounter > 1 ? "Delete " + selectedMessageCounter + " messages?" : "Delete message?";
            deleteMessageOptionsHeader.innerHTML = popupText;

            var deleteMessageOptions = deleteMessageOptionsContainer.querySelector(".deleteMessageOptions");
            var deleteForEveryone = deleteMessageOptions.querySelector(".deleteForEveryone");
            var deleteForMe = deleteMessageOptions.querySelector(".deleteForMe");
            var cancel = deleteMessageOptions.querySelector(".cancel");

            //check if delete for everyone option should be displayed
            var deleteForEveryoneFlag = false;
            if (headerToolbar.deleteForEveryone == selectedMessageCounter)
                deleteForEveryoneFlag = true;

            if (deleteForEveryoneFlag) {
                deleteForEveryone.style.display = "";

                //clear different styling for displaying only 2 options
                deleteMessageOptions.style.gridTemplateColumns = "";
                deleteMessageOptions.style.justifySelf = "";
                deleteForMe.style.gridColumn = "";
                deleteForMe.style.gridRow = "";
                cancel.style.gridColumn = "";
                cancel.style.gridRow = "";
            } else {
                deleteForEveryone.style.display = "none";

                //different styling for displaying only 2 options
                deleteMessageOptions.style.gridTemplateColumns = "max-content max-content";
                deleteMessageOptions.style.justifySelf = "right";
                deleteForMe.style.gridColumn = 2;
                deleteForMe.style.gridRow = 1;
                cancel.style.gridColumn = 1;
                cancel.style.gridRow = 1;
            }

            deleteMessageOptionsContainer.style.display = "grid";

        } else if (action == "cancelSelectedMessages") {
            var imageViewerWrapper = document.querySelector(".imageViewerWrapper");
            if (imageViewerWrapper != null) {
                imageViewerWrapper.style.display = "none";
            }

            MM._partialUpdateFrontEnd(headerToolbar, headerToolbar.getAttribute("data-cancelSelectedMessages"), null);
            MM.removeMessagingHeader();
        }

    },

    deleteMessageOptionsAction: function (action) {
        var headerToolbar = document.querySelector(".messagingHeaderOptions");

        if (action == "delete_for_me") {
            MM._partialUpdateFrontEnd(headerToolbar, headerToolbar.getAttribute("data-delete"), null);
            MM.removeMessagingHeader();
        } else if (action == "delete_for_everyone") {
            MM._partialUpdateFrontEnd(headerToolbar, headerToolbar.getAttribute("data-deleteForEveryone"), null);
            MM.removeMessagingHeader();
        }

        var deleteMessageOptionsContainer = document.getElementById("deleteMessageOptionsContainer");
        deleteMessageOptionsContainer.style.display = "none";
    },

    removeMessagingHeader: function () {
        var headerToolbar = document.querySelector(".messagingHeaderOptions");
        var counter = document.querySelector(".messagingHeaderCounter");
        var tempParent;

        //Header animation
        headerToolbar.style.animation = "phaseOut 0.5s forwards";
        setTimeout(function () {
            headerToolbar.style.display = "none";
        }, 500);

        counter.innerText = "0";

        headerToolbar.setAttribute("data-longPressed", "false");
        headerToolbar.setAttribute("data-beginQuickSelects", "false");

        //Clean up (Unselect elements and remove events and messaging header)
        document.querySelectorAll(".messaging").forEach(function setEvents(element) {
            //Enable touch events for message bubbles
            element.style.pointerEvents = "auto";

            tempParent = element.parentElement;

            while (tempParent.className.includes(" container") != true  && tempParent.className.includes(" symbol") != true){
                tempParent = tempParent.parentElement;
            }

            tempParent.removeEventListener('pointerup', MM.messagingHeaderQuickSelect);

            if(window.getComputedStyle(tempParent).backgroundColor != "" && window.getComputedStyle(tempParent).backgroundColor != "rgba(0, 0, 0, 0)"){
                tempParent.style.backgroundColor = "";
            }
        });

    },

    messagingHeaderQuickSelect: function (e) {
        var headerToolbar = document.querySelector(".messagingHeaderOptions");
        var counter = document.querySelector(".messagingHeaderCounter");
        var target = e.currentTarget;
        var subElementKey = target.querySelector(".messaging").getAttribute("data-selectDataKey");
        var tempParent;
        var options = target.querySelector(".messaging").getAttribute("data-messageOptions");

        //The first pointer up is fired once the user releases long press so we only need to act the second time one is fired
        if(headerToolbar.getAttribute("data-beginQuickSelects") == "false"){
            headerToolbar.setAttribute("data-beginQuickSelects", "true");
            return;
        }

        //Make non selectable if the message has no options
        if(options == null || options == ""){
            return;
        }

        //Highlight selected message bubble
        if (window.getComputedStyle(target).backgroundColor == "" || window.getComputedStyle(target).backgroundColor == "rgba(0, 0, 0, 0)") {

            target.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--PRIMARY_LIGHT");
            MM._partialUpdateFrontEnd(target, subElementKey, null);

            counter.innerText = parseInt(counter.innerText) + 1;

            //Determine options
            MM.controlMessageOptions(target, "ADD", headerToolbar, parseInt(counter.innerText));

        } else {//Unselect message bubble

            target.style.backgroundColor = "";
            MM._partialUpdateFrontEnd(target, subElementKey, null);

            counter.innerText = parseInt(counter.innerText) - 1;

            //Remove touch events from message bubbles if there are no selected message bubbles on screen
            if (counter.innerText == "0") {
                headerToolbar.setAttribute("data-beginQuickSelects", "false");

                //Header animation
                headerToolbar.style.animation = "phaseOut 0.5s forwards";
                setTimeout(function () {
                    headerToolbar.style.display = "none";
                }, 500);

                document.querySelectorAll(".messaging").forEach(function setEvents(element) {
                    //Enable touch events for message bubbles
                    element.style.pointerEvents = "auto";

                    tempParent = element.parentElement;

                    while (tempParent.className.includes(" container") != true  && tempParent.className.includes(" symbol") != true){
                        tempParent = tempParent.parentElement;
                    }

                    tempParent.removeEventListener('pointerup', MM.messagingHeaderQuickSelect);
                });

                //Reset text storing object
                headerToolbar.keyTextPair = null;
                headerToolbar.setAttribute("data-longPressed", "false");
            }

            //Determine options
            MM.controlMessageOptions(target, "REMOVE", headerToolbar, parseInt(counter.innerText));

        }

    },

    messageReplayLongPress: function () {

        var messageOptions = document.querySelectorAll("[data-longPressListener='false']");

        for (var option = 0; option < messageOptions.length; option++) {

            var parentElement = messageOptions[option].parentElement;

            while (parentElement.className.includes(" container") != true && parentElement.className.includes(" symbol") != true){
                parentElement = parentElement.parentElement;
            }

            parentElement.addEventListener('long-press', function (e) {

                // stop the event from bubbling up
                e.preventDefault();

                //Display longpress option
                if (e.currentTarget !== null && (e.currentTarget.className.indexOf("animation") !== -1) || e.currentTarget.classList.contains("messageBubbleContainer")) {

                    MM.longPressCancelListenerReg();

                    var headerToolbar = document.querySelector(".messagingHeaderOptions");
                    headerToolbar.messageOptions = [];

                    //Don't allow user to long press again once a long press flow has been initiated
                    if(headerToolbar.getAttribute("data-longPressed") == "false"){

                        headerToolbar.setAttribute("data-longPressed", "true");

                        var counter = document.querySelector(".messagingHeaderCounter");
                        var target = e.currentTarget;
                        var subElementKey = target.querySelector(".messaging").getAttribute("data-selectDataKey");
                        var tempParent;

                        //Highlight selected message bubble
                        if(window.getComputedStyle(target).backgroundColor == "" || window.getComputedStyle(target).backgroundColor == "rgba(0, 0, 0, 0)"){

                            target.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--PRIMARY_LIGHT");
                            MM._partialUpdateFrontEnd(target, subElementKey, null);

                            //Add touch events to message bubbles for further selection
                            if(counter.innerText == "0"){
                                counter.innerText = parseInt(counter.innerText) + 1;

                                document.querySelectorAll(".messaging").forEach(function setEvents(element) {
                                    //Disable touch events for message bubbles so that only select touch event fires off
                                    element.style.pointerEvents = "none";

                                    tempParent = element.parentElement;

                                    while (tempParent.className.includes(" container") != true && tempParent.className.includes(" symbol") != true){
                                        tempParent = tempParent.parentElement;
                                    }

                                    tempParent.addEventListener('pointerup', MM.messagingHeaderQuickSelect);
                                });

                                //Header animation
                                headerToolbar.style.display = "grid";
                                headerToolbar.style.animation = "phaseIn 0.5s forwards";

                                //Create object to store message texts and id's for copy
                                var keyTextPair = new Object();
                                keyTextPair.texts = [];
                                keyTextPair.ids = [];
                                headerToolbar.keyTextPair = keyTextPair;

                                //Create object to store messages from label and id's
                                var fromLabelAndMessageIdPair = new Object();
                                fromLabelAndMessageIdPair.fromLabels = [];
                                fromLabelAndMessageIdPair.ids = [];
                                headerToolbar.fromLabelAndMessageIdPair = fromLabelAndMessageIdPair;

                                //Determine options
                                headerToolbar.forwardCounter = 0;
                                headerToolbar.copyCounter = 0;
                                headerToolbar.deleteCounter = 0;
                                headerToolbar.replyCounter = 0;
                                headerToolbar.deleteForEveryone = 0;
                                MM.controlMessageOptions(target, "ADD", headerToolbar, parseInt(counter.innerText));

                            } else {
                                counter.innerText = parseInt(counter.innerText) + 1;
                            }

                        } else {//Unselect message bubble

                            target.style.backgroundColor = "";
                            MM._partialUpdateFrontEnd(target, subElementKey, null);

                            counter.innerText = parseInt(counter.innerText) - 1;

                            //Remove touch events from message bubbles if there are no selected message bubbles on screen
                            if(counter.innerText == "0"){
                                headerToolbar.setAttribute("data-beginQuickSelects", "false");

                                //Header animation
                                headerToolbar.style.animation = "phaseOut 0.5s forwards";
                                setTimeout(function () {
                                    headerToolbar.style.display = "none";
                                }, 500);

                                document.querySelectorAll(".messaging").forEach(function setEvents(element) {
                                    //Enable touch events for message bubbles
                                    element.style.pointerEvents = "auto";

                                    tempParent = element.parentElement;

                                    while (tempParent.className.includes(" container") != true && tempParent.className.includes(" symbol") != true){
                                        tempParent = tempParent.parentElement;
                                    }

                                    tempParent.removeEventListener('pointerup', MM.messagingHeaderQuickSelect);
                                });

                                //Reset text storing object
                                headerToolbar.keyTextPair = null;

                                //Determine options
                                MM.controlMessageOptions(target, "REMOVE", headerToolbar, parseInt(counter.innerText));
                            }

                        }
                    }

                } else {

                    var paths = e.path;

                    for (var path = 0; path < paths.length; path++) {

                        if (paths[path].className === "longPressOptionsContainer") {
                            paths[path].previousElementSibling.style.display = "";
                            break;
                        }
                    }
                }
                return false;
            });

            messageOptions[option].setAttribute("data-longPressListener","true");
        }
    },

    longPressCancelListener: function (e) {

        //Manually call href for long press anchors as the pointer event on parent stops them from being called
        if (e.target.href != null && e.target.href != "") {
            window.location = e.target.href;
        }

        var baseElementCancel = document.getElementById("base-content");
        baseElementCancel.removeEventListener('pointerdown', MM.longPressCancelListener);
        baseElementCancel.removeEventListener('scroll', MM.longPressCancelListener);

        var longPressOptions = document.getElementsByClassName("longPressOptionsContainer");

        for (var longPressOption = 0; longPressOption < longPressOptions.length; longPressOption++) {

            longPressOptions[longPressOption].style.display = "none";
        }
        return false;
    },

    longPressCancelListenerReg: function () {
        var baseElement = document.getElementById("base-content");
        baseElement.addEventListener('pointerdown', MM.longPressCancelListener);
        baseElement.addEventListener('scroll', MM.longPressCancelListener);
    },

    /** END: Message long press **/

    /** BEGIN: Messaging headers **/

    showForwardSearchHeader: function () {
        var header = document.querySelector(".messagingHeaderForwardSearch");

        header.style.display = "grid";
        header.style.animation = "phaseInForwardSearch 0.5s forwards";
    },

    hideForwardSearchHeader: function (e) {
        var header = document.querySelector(".messagingHeaderForwardSearch");

        header.style.animation = "phaseOutForwardSearch 0.5s forwards";
        setTimeout(function () {
            header.style.display = "none";
            MM._partialUpdateFrontEnd(e, e.getAttribute("data-messagingHeaderBackKey"), true);
        }, 500);
    },

    showHideForwardSearchClearIcon: function () {
        var input = document.querySelector(".messagingHeaderForwardSearchInput");
        var clearIcon = document.querySelector(".messagingHeaderForwardClearIcon");

        if (input.value != null && input.value != "") {
            clearIcon.style.display = "block";
        } else {
            clearIcon.style.display = "none";
        }
    },

    clearForwardSearch: function () {
        var input = document.querySelector(".messagingHeaderForwardSearchInput");
        var clearIcon = document.querySelector(".messagingHeaderForwardClearIcon");

        input.value = "";
        clearIcon.style.display = "none";
    },

    updateMessagingHeaderHiddenInput: function () {
        //Update cloned input with user input
        var messagingHeaderForwardSearchInput = document.querySelector(".messagingHeaderForwardSearchInput");
        messagingHeaderForwardSearchInput.hiddenInput.value = messagingHeaderForwardSearchInput.value;
    },

    addHiddenMessagingHeaderInput: function () {
        var messagingHeaderForwardSearchInput = document.querySelector(".messagingHeaderForwardSearchInput");

        //Add a cloned input to base-content for form submission purposes
        if (messagingHeaderForwardSearchInput != null) {
            if (messagingHeaderForwardSearchInput.name != null && messagingHeaderForwardSearchInput.name != "") {
                var hiddenInput = messagingHeaderForwardSearchInput.cloneNode(true);
                var baseContent = document.getElementById("base-content");
                var check = document.getElementById("hiddenMessagingHeaderForwardSearchInput");

                hiddenInput.id = "hiddenMessagingHeaderForwardSearchInput";

                //Make sure we only add the input to the screen once
                if (baseContent != null && (check == null || check == "")) {
                    hiddenInput.style.display = "none";
                    baseContent.firstElementChild.appendChild(hiddenInput);
                    messagingHeaderForwardSearchInput.hiddenInput = hiddenInput;
                }
            }
        }
    },

    setHeaderToolbarForImageViewerCarousel: function (addRemove, el) {
        var forward = document.querySelector(".messagingHeaderImageViwerCarouselForward");
        var download = document.querySelector(".messagingHeaderDownload");
        var options = el.getAttribute("data-messageOptions");
        var headerCounter = document.querySelector(".messagingHeaderCounter");

        MM.resetMessagingHeaders();

        headerCounter.style.display = "none";

        download.style.display = "";
        download.style.pointerEvents = "auto";
        download.setAttribute("data-downloadLink", el.getAttribute("data-downloadLink"));

        //Set navigate link for forward
        forward.href = el.getAttribute("data-forwardLink");

        if (addRemove == "ADD") {

            if (options.includes("FORWARD") == true) {
                forward.style.display = "";
                forward.style.pointerEvents = "auto";
            }

        } else if (addRemove == "REMOVE") {

            if (options.includes("FORWARD") == true) {
                forward.style.display = "none";
                forward.style.pointerEvents = "none";
            }

        }

    },

    resetMessagingHeaders: function () {
        var copy = document.querySelector(".messagingHeaderCopy");
        var forward = document.querySelector(".messagingHeaderForward");
        var reply = document.querySelector(".messagingHeaderReply");
        var deleteButton = document.querySelector(".messagingHeaderDelete");
        var download = document.querySelector(".messagingHeaderDownload");
        var forwardImageViewer = document.querySelector(".messagingHeaderImageViwerCarouselForward");

        if(copy != null){
            copy.style.display = "none";
            copy.style.pointerEvents = "none";
        }

        if(forward != null){
            forward.style.display = "none";
            forward.style.pointerEvents = "none";
        }

        if(reply != null){
            reply.style.display = "none";
            reply.style.pointerEvents = "none";
        }

        if(deleteButton != null){
            deleteButton.style.display = "none";
            deleteButton.style.pointerEvents = "none";
        }

        if(download != null){
            download.style.display = "none";
            download.style.pointerEvents = "none";
        }

        if(forwardImageViewer != null){
            forwardImageViewer.style.display = "none";
            forwardImageViewer.style.pointerEvents = "none";
        }
    },

    /** END: Messaging headers **/

    /** BEGIN: composedMessage **/
    //** This is correct, complexity created because of growing div element **/
    /** BEGIN: composedMessage **/
    //** This is correct, complexity created because of growing div element **/
    composedMessageConstraintsAndResize: function (e) {
        var key;

        //removes any characters more than max length if max length is set
        var maxlength = e != null ? e.getAttribute("maxlength") : null;
        maxlength = maxlength != null && maxlength.length > 0 ? parseInt(maxlength) : null;

        if (maxlength != null) {
            if ((e.innerHTML != null && e.innerHTML.length > maxlength) || (e.value != null && e.value.length > maxlength)) {
                e.innerHTML = e.innerHTML != null ? e.innerHTML.substring(0, maxlength) : "";
                e.value = e.value != null ? e.value.substring(0, maxlength) : null;
            }
        }

        if (e != null && (e.classList == null || !e.classList.contains("composedMessageTextBox"))) {
            if (window.event) {
                key = window.event.keyCode;
            } else {
                key = e.which;
            }
            if (key == 13) {
                e.innerHTML += String.fromCharCode(10);
            }
        }

        e.style.height = 'auto';
        e.style.padding = '0';
        if (e.scrollHeight <= 36 * Root.unit()) {
            e.style.height = e.scrollHeight + 'px';
        } else {
            e.style.height = 36 * Root.unit() + 'px';
            e.style.overflow = 'scroll';
        }
        e.scrollTop = e.scrollHeight;

        MM.checkDisplayOfScrollToBottomBtn();

        //copy value from compose to hindden input for submitting
        MM.copyToHiddenInput(e.getAttribute("data-hiddenInputName"), MM.markDownToPlainText(e.innerHTML));

        return true;
    },


    composedMessageApplyRestrictionsAlphaNumericSpecial: function (e) {
        //e.value= e.value.replace(/[^A-Za-z0-9!@#$%^&*()_\+\=\-\{\[\}\]\\\|\;\:\'\"\,\<\.\>\/\? ]/g, "");
    },

    clearComposedMessage: function () {
        var textBox = document.querySelector('.composedMessageTextBox');
        textBox.innerHTML = "";
        textBox.style.cssText = 'height:auto;';

        var hiddenInputName = textBox.getAttribute("data-hiddenInputName");
        var composedMessageHiddenInput = document.getElementsByName(hiddenInputName)[0];
        composedMessageHiddenInput.value = "";

    },

    switchButtons: function (textarea) {
        var buttonGroup = textarea.parentNode.querySelector('.composedMessageButtonGroupRight');

        if (textarea.innerHTML === "") {
            if (buttonGroup != null) {
                buttonGroup.setAttribute("style", "");
            }
        } else {
            if (buttonGroup != null) {
                buttonGroup.setAttribute("style", "display : none;");
            }
        }
    },

    ComposeMessagePresenceHandler: {

        _ComposeMessageList: [],

        addComposeMessage: function (id) {

            for (composeMessageCount = 0; composeMessageCount < MM.ComposeMessagePresenceHandler._ComposeMessageList.length; ++composeMessageCount) {
                var composeMessage = MM.ComposeMessagePresenceHandler._ComposeMessageList[composeMessageCount];
                if (composeMessage.id === id) {
                    Timers.clearOne(MM.ComposeMessagePresenceHandler._ComposeMessageList[composeMessageCount].timerId);
                    MM.ComposeMessagePresenceHandler._ComposeMessageList.splice(composeMessageCount, 1);
                }
            }

            var timerId = setInterval(function () {
                var xhr = new XMLHttpRequest();

                var element = document.getElementsByClassName("composedMessageTextBox")[0];
                if (element != null) {
                    if (element.innerHTML != "" && element.tempData != element.innerHTML) {
                        element.tempData = element.innerHTML;
                        var conversationId = element.getAttribute("data-conversationId");
                        var userId = element.getAttribute("data-userId");
                        xhr.open("GET", "/banking/typing?conversationId=" + conversationId + "&userId=" + userId);
                        xhr.send();
                    }
                } else {
                    xhr.open("GET", "/banking/typing");
                    xhr.send();
                }
            }, 3000);
            Timers.register(timerId);

            var singleObj = {}
            singleObj['id'] = id;
            singleObj['timerId'] = timerId;
            MM.ComposeMessagePresenceHandler._ComposeMessageList.push(singleObj);
        },

        deleteComposeMessage: function (id) {
            for (composeMessageCount = 0; composeMessageCount < MM.ComposeMessagePresenceHandler._ComposeMessageList.length; ++composeMessageCount) {
                var composeMessage = MM.ComposeMessagePresenceHandler._ComposeMessageList[composeMessageCount];
                if (composeMessage.id === id) {
                    Timers.clearOne(MM.ComposeMessagePresenceHandler._ComposeMessageList[composeMessageCount].timerId);
                    MM.ComposeMessagePresenceHandler._ComposeMessageList.splice(composeMessageCount, 1);
                }
            }
        }
    },

    composeMessageRemoveIcons: function() {
        var camera = document.querySelector('.composebarCamera');
        var textBox = document.querySelector('.composedMessageTextBox');

        //Move camera and paperclip icons accordingly
        if (textBox.innerHTML == "") {
            camera.style.display = "block";
        } else {
            camera.style.display = "none";
        }
    },

    composeMessageOptionsRemove: function() {
        MM.openComposeMessageOptions();
    },

    openComposeMessageOptions: function () {
        var composeMessageOptionIconButtonsContainer = document.querySelector(".composeMessageOptionIconButtonsContainer");
        var paperclip = document.querySelector(".composebarPaperClip");

        if(composeMessageOptionIconButtonsContainer == null || composeMessageOptionIconButtonsContainer == "" || paperclip == null || paperclip == ""){
            return;
        }

        var icons = composeMessageOptionIconButtonsContainer.querySelectorAll(".composeMessageOptionIconButton");
        var iconWidth = 17;
        var visible = composeMessageOptionIconButtonsContainer.getAttribute("data-visible");

        var composeMessageStyle = document.querySelector(".composeMessageStyle");
        composeMessageStyle.innerHTML = "";

        var height = 90;//Each row is 30 units, max 3 rows then scroll
        var rowHeight = 90/3;

        //UFF
        var unit = Root.determineUnitNeeded();

        //Set max on container. IOS renders incorrectly otherwise
        if(composeMessageOptionIconButtonsContainer.gridSet != true){
            var numRows = parseInt(icons.length/3);
            var remainder = icons.length % 3;
            if(remainder != 0){
                numRows++;
            }
            composeMessageOptionIconButtonsContainer.style.gridTemplateRows = "repeat(" + numRows + ", calc(" + rowHeight + " * var(" + unit + ")))";
            composeMessageOptionIconButtonsContainer.gridSet = true;
        }

        if(visible == "false"){//show
            composeMessageOptionIconButtonsContainer.setAttribute("data-visible", "true");
            paperclip.style.pointerEvents = "none";

            composeMessageOptionIconButtonsContainer.style.display = "grid";

            //Container coming up animation
            composeMessageStyle.innerHTML = "@keyframes showOptions\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    border-radius: 50%;\n" +
                "    max-height: calc(0 * var(" + unit + "));\n" +
                "    width: 30%;\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    border-radius: 0%;\n" +
                "    max-height: calc(" + height + " * var(" + unit + "));\n" +
                "    width: 100%;\n" +
                "  }\n" +
                "\n" +
                "}";

            //Slight bubble animation on icons
            composeMessageStyle.innerHTML += "@keyframes iconBubbleAnimation\n" +
                "{\n" +
                "\n" +
                "  0\n" +
                "  {\n" +
                "    width: calc(" + (iconWidth - 2) + " * var(" + unit + "));\n" +
                "  }\n" +
                "  40%\n" +
                "  {\n" +
                "    width: calc(" + (iconWidth + 2) + " * var(" + unit + "));\n" +
                "  }\n" +
                "  100%\n" +
                "  {\n" +
                "    width: calc(" + (iconWidth) + " * var(" + unit + "));\n" +
                "  }\n" +
                "\n" +
                "}";

            composeMessageOptionIconButtonsContainer.style.animationDuration = "0.3s";
            composeMessageOptionIconButtonsContainer.style.animationFillMode = "forwards";
            composeMessageOptionIconButtonsContainer.style.animationName = "showOptions";

            setTimeout(function () {
                icons.forEach(function (value) {
                    value.style.animationDuration = "0.3s";
                    value.style.animationFillMode = "forwards";
                    value.style.animationName = "iconBubbleAnimation";
                });
            }, 250);

            //Remove if user clicks anywhere else on the screen
            document.getElementById("base-content").addEventListener("pointerup", MM.composeMessageOptionsRemove);
        }else{//hide
            composeMessageOptionIconButtonsContainer.setAttribute("data-visible", "false");


            setTimeout(function () {
                composeMessageOptionIconButtonsContainer.style.display = "none";
                paperclip.style.pointerEvents = "auto";
            }, 250);

            composeMessageStyle.innerHTML = "@keyframes hideOptions\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    border-radius: 0%;\n" +
                "    max-height: calc(" + height + " * var(" + unit + "));\n" +
                "    width: 100%;\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    border-radius: 50%;\n" +
                "    max-height: calc(0 * var(" + unit + "));\n" +
                "    width: 30%;\n" +
                "  }\n" +
                "\n" +
                "}";

            composeMessageOptionIconButtonsContainer.style.animationName = "hideOptions";
            composeMessageOptionIconButtonsContainer.style.animationDuration = "0.3s";
            composeMessageOptionIconButtonsContainer.style.animationFillMode = "forwards";

            icons.forEach(function (value) {
                value.style.animationName = "";
            });

            //Remove if user clicks anywhere else on the screen
            document.getElementById("base-content").removeEventListener("pointerup", MM.composeMessageOptionsRemove);
        }

    },

    /** END: composedMessage **/

    /**Message Bubbles**/
    calcSwipeDeleteSize: function () {
        var elements = document.querySelectorAll("[data-swipe-delete]");

        for (allElementCount = 0; allElementCount < elements.length; ++allElementCount) {
            var element = elements[allElementCount];

            var unitHeight = element.parentNode.offsetHeight / Root.unit();
            element.style.height = "calc(" + unitHeight + " * var(--unit))";
        }
    },
    /**Message Bubbles**/

    /** filePicker **/

    _filePickerSyncHandler: {

        _filePickerList: [],

        addFilePicker: function (id, size) {

            for (filePickerCount = 0; filePickerCount < MM._filePickerSyncHandler._filePickerList.length; ++filePickerCount) {
                var filePicker = MM._filePickerSyncHandler._filePickerList[filePickerCount];
                if (filePicker.id === id) {
                    MM._filePickerSyncHandler._filePickerList.splice(filePickerCount, 1);
                }
            }

            var singleObj = {}
            singleObj['id'] = id;
            singleObj['size'] = size;
            MM._filePickerSyncHandler._filePickerList.push(singleObj);
        },

        filePickerSize: function (id) {
            for (filePickerCount = 0; filePickerCount < MM._filePickerSyncHandler._filePickerList.length; ++filePickerCount) {
                var filePicker = MM._filePickerSyncHandler._filePickerList[filePickerCount];
                if (filePicker.id === id) {
                    return filePicker.size;
                }
            }
        },

        decrementFilePickerSize: function (id) {
            for (filePickerCount = 0; filePickerCount < MM._filePickerSyncHandler._filePickerList.length; ++filePickerCount) {
                var filePicker = MM._filePickerSyncHandler._filePickerList[filePickerCount];
                if (filePicker.id === id) {
                    filePicker.size--;
                }
            }
        },

        deleteFilePicker: function (id) {
            for (filePickerCount = 0; filePickerCount < MM._filePickerSyncHandler._filePickerList.length; ++filePickerCount) {
                var filePicker = MM._filePickerSyncHandler._filePickerList[filePickerCount];
                if (filePicker.id === id) {
                    MM._filePickerSyncHandler._filePickerList.splice(filePickerCount, 1);
                }
            }
        }
    },

    updateLabel: function (input) {

        var changeColor = false;

        input.setAttribute("data-file-selected", "true");

        var maxSize = input.getAttribute("data-maxSize");
        var maxSizeMessage = input.getAttribute("data-maxSizeMessage");
        var invalidMimeTypeMessage = input.getAttribute("data-invalidMimeTypeMessage");

        var mimeTypes = input.getAttribute("accept").split(",");
        var mimeValid = false;

        for (mimeCount = 0; mimeCount < mimeTypes.length; ++mimeCount) {
            var mimeType = mimeTypes[mimeCount];

            if (mimeType === input.files[0].type) {
                mimeValid = true;
            }
        }

        if (!mimeValid) {
            //File not correct type

            var messageBackdrop = (input.parentNode.parentNode.parentNode.querySelectorAll('.filePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.filePickerMessage'))[0];

            message.innerText = invalidMimeTypeMessage;
            messageBackdrop.className = "filePickerMessageBackdrop filePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "filePickerMessageBackdrop";
                message.innerText = "";

            }, 3000);
            Timers.register(timerId);
            return;
        }


        if (input.files[0].size > maxSize) {
            //File to big

            var messageBackdrop = (input.parentNode.parentNode.parentNode.querySelectorAll('.filePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.filePickerMessage'))[0];

            message.innerText = maxSizeMessage;
            messageBackdrop.className = "filePickerMessageBackdrop filePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "filePickerMessageBackdrop";
                message.innerText = "";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        if (input.files[0].type === "image/jpeg" || input.files[0].type === "image/png" || input.files[0].type === "image/bmp" || input.files[0].type === "image/gif") {

            var preview = input.parentNode;
            var file = input.files[0];
            var reader = new FileReader();

            reader.addEventListener("load", function (oFREvent) {
                var eve = oFREvent;
                preview.setAttribute("style", "background: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url(" + oFREvent.target.result + "); background-position: center;");
            }, false);

            if (file) {
                reader.readAsDataURL(file);
            }

            changeColor = true;
        }

        var names = input.parentNode.getElementsByClassName("fileName");
        var name = names[0];
        name.innerHTML = input.files[0].name;

        var sizes = input.parentNode.getElementsByClassName("fileSize");
        var size = sizes[0];
        size.innerHTML = (input.files[0].size / 1024).toFixed(2) + " KB";

        if (changeColor) {
            name.setAttribute("style", "color : white;");
            size.setAttribute("style", "color : white;");
        }

        var dropFile = (input.parentNode.querySelectorAll('.fileDrop'))[0];
        dropFile.setAttribute("style", "");
        var inputRemove = (input.parentNode.querySelectorAll('.inputRemove'))[0];
        inputRemove.setAttribute("style", "");
        inputRemove.onclick = function () {
            input.value = "";
            input.parentNode.setAttribute("style", "");
            dropFile.setAttribute("style", "display:none;");
            inputRemove.setAttribute("style", "display:none;");
            name.innerHTML = "Click to Select";
            name.setAttribute("style", "color : black;");
            size.innerHTML = "";
            size.setAttribute("style", "color : black;");
        };

    },

    uploadFiles: function (element, subElementKey) {
        var fileInputs = document.querySelectorAll('[data-file-selected="true"]');

        var loaderBackdrop = (fileInputs[0].parentNode.parentNode.parentNode.querySelectorAll('.filePickerLoaderBackdrop'))[0];
        loaderBackdrop.setAttribute("style", "");
        var loader = (loaderBackdrop.querySelectorAll('.filePickerLoader'))[0];
        var removeloader = true;

        //Sort out sync issue with FileReader
        MM._filePickerSyncHandler.addFilePicker(element.id, fileInputs.length);

        for (fileCount = 0; fileCount < fileInputs.length; ++fileCount) {
            var fileInput = fileInputs[fileCount];
            if (fileInput.files.length > 0) {

                removeloader = false;

                var inputHidden = (fileInput.parentNode.querySelectorAll('input[type="hidden"]'))[0];
                inputHidden.value = ":" + fileInput.files[0].name;

                var reader = new FileReader();
                reader.readAsDataURL(fileInput.files[0]);
                reader.onload = (function (fileInput, inputHidden) {
                    return function (e) {
                        var data = e.target.result;
                        var payload = data.split(',')[1];

                        var xhr = new XMLHttpRequest();

                        loader.onclick = (function (xhr) {
                            return function () {
                                xhr.abort();
                                loader.parentNode.setAttribute("style", "display:none;");
                            }
                        })(xhr);

                        xhr.addEventListener("load", function (evt) {
                            MM.uploadFile(evt, loader, inputHidden, fileInput, element, subElementKey);
                        }, true);

                        xhr.open("POST", "/banking/thingUpload?host=" + fileInput.getAttribute('data-host') + "&port=" + fileInput.getAttribute('data-port') +
                            "&userName=" + fileInput.getAttribute('data-userName') + "&password=" + fileInput.getAttribute('data-password') +
                            "&fileName=" + fileInput.files[0].name + "&filePrefix=" + fileInput.getAttribute('data-fileNamePrefix') +
                            "&maxSize=" + fileInput.getAttribute('data-maxSize') + "&fileNumber=" + fileCount);
                        xhr.send(payload);
                    };
                })(fileInput, inputHidden);

            }
        }

        //No file to upload
        if (removeloader) {
            loader.parentNode.setAttribute("style", "display:none;");
        }

    },

    uploadAndSendGif: function (el, submitEl) {

        var input = document.getElementById("gifData");
        var maxSize = input.getAttribute("data-maxSize");
        var noFiles = input.getAttribute("data-noFilesFoundMessage");
        var maxSizeMessage = input.getAttribute("data-maxSizeMessage");
        var invalidMimeTypeMessage = input.getAttribute("data-invalidMimeTypeMessage");
        var selectionLimit = input.getAttribute("data-selectionLimit");
        var selectionLimitMessage = input.getAttribute("data-selectionLimitMesssage");
        var nativeFilePicker = document.getElementById("nativeOverlay");

        input.blur();
        nativeFilePicker.style.display = "";

        //using an attribute from thing settings to see if it was received if not then display error message
        if (input.getAttribute("data-fileNamePrefix") == "" || input.getAttribute("data-fileNamePrefix") == null) {

            var messageBackdrop = (document.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = "Your request cannot be processed, please try again later.";
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        var url = el.getAttribute("data-gif-url");
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url);
        xhr.responseType = "blob";
        xhr.addEventListener("load", function (evt) {

            var payload = evt.currentTarget.response;

            var mimeTypes = input.getAttribute("accept");
            if (mimeTypes !== null) {
                mimeTypes = mimeTypes.split(",");
            }

            var mimeValid = false;
            var currentMimeType = evt.currentTarget.response.type;

            for (mimeCount = 0; mimeCount < mimeTypes.length; ++mimeCount) {
                var mimeType = mimeTypes[mimeCount];
                if (mimeType === currentMimeType) {
                    mimeValid = true;
                }
            }

            //hardcorded to true temporarily until BE adds gif in thingsettings
            mimeValid = true;

            if (!mimeValid) {
                //File not correct type

                var messageBackdrop = (nativeFilePicker.querySelector('.nativeFilePickerMessageBackdrop'));
                var message = messageBackdrop.querySelector('.nativeFilePickerMessage');

                message.innerText = invalidMimeTypeMessage;
                messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
                input.value = "";

                var timerId = setInterval(function () {
                    Timers.clearOne(timerId);

                    messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                    message.innerText = "";
                    nativeFilePicker.style.display = "none";

                }, 3000);
                Timers.register(timerId);
                return;
            }

            var currentFileSize = evt.currentTarget.response.size;
            if (currentFileSize > maxSize) {
                //File to big

                var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
                var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

                message.innerText = maxSizeMessage;
                messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
                input.value = "";

                var timerId = setInterval(function () {
                    Timers.clearOne(timerId);

                    messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                    message.innerText = "";
                    nativeFilePicker.style.display = "none";

                }, 3000);
                Timers.register(timerId);
                return;
            }

            var reader = new FileReader();
            reader.readAsDataURL(payload);
            reader.onload = (function (e) {
                var fileInput = document.getElementById("gifData");
                var data = e.target.result;
                var payload = data.split(',')[1];
                var xhr = new XMLHttpRequest();

                xhr.addEventListener("load", function (evt) {
                    var response = JSON.parse(evt.currentTarget.responseText);
                    MM.gifUploadResponseHandler(response, submitEl);


                }, true);

                var fileName = url.substring(url.lastIndexOf("/") + 1);
                xhr.open("POST", "/banking/thingUpload?host=" + fileInput.getAttribute('data-host') + "&port=" + fileInput.getAttribute('data-port') +
                    "&userName=" + fileInput.getAttribute('data-userName') + "&password=" + fileInput.getAttribute('data-password') +
                    "&fileName=" + fileName + "&filePrefix=" + fileInput.getAttribute('data-fileNamePrefix') +
                    "&maxSize=" + fileInput.getAttribute('data-maxSize') + "&fileNumber=" + 1);
                xhr.send(payload);
            });
        }, true);

        xhr.addEventListener("error", function (evt) {
            //display error if upload fails
            var messageBackdrop = (document.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = "Your request cannot be processed, please try again later.";
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }, true);

        xhr.send();

    },

    gifUploadResponseHandler: function (response, submitEl) {

        if (response.returnInfo === "failed") {
            var messageBackdrop = (document.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = "Error uploading file";
            messageBackdrop.className = "filePickerMessageBackdrop filePickerMessageBackdropFlash";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "filePickerMessageBackdrop";
                message.innerText = "";

            }, 3000);
            Timers.register(timerId);
        }

        if (response.returnInfo === "success") {
            var fileInput = document.getElementById("gifData");
            fileInput.name = response.fileName + ":filename_1:upload";
            fileInput.value = response.returnHash + ":" + response.fileName;

            var messagingText = document.getElementById("messagingText");
            var hiddenInputName = messagingText.getAttribute("data-hiddenInputName");
            var hiddenInput = document.getElementsByName(hiddenInputName)[0];
            hiddenInput.setAttribute("name",hiddenInputName+":composeData");

            var sendGifUiid = submitEl.querySelector(".composedMessageTextBox").getAttribute("data-sendGifUiid");
            Form.submit(sendGifUiid);
        }
    },

    uploadFile: function (evt, loader, inputHidden, fileInput, element, subElementKey) {

        MM._filePickerSyncHandler.decrementFilePickerSize(element.id);

        var response = JSON.parse(evt.currentTarget.responseText);

        if (response.returnInfo === "failed") {

            var messageBackdrop = (fileInput.parentNode.parentNode.parentNode.querySelectorAll('.filePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.filePickerMessage'))[0];

            message.innerText = "Error uploading file";
            messageBackdrop.className = "filePickerMessageBackdrop filePickerMessageBackdropFlash";
            //fileInput.value = "";
            //fileInput.parentNode.setAttribute("style", "");

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "filePickerMessageBackdrop";
                message.innerText = "";

            }, 3000);
            Timers.register(timerId);
        }

        if (response.returnInfo === "success") {
            var valueHolder = inputHidden.value;
            inputHidden.value = response.returnHash + valueHolder;
        }

        if (MM._filePickerSyncHandler.filePickerSize(element.id) === 0) {
            MM._filePickerSyncHandler.deleteFilePicker(element.id);

            var dataType = fileInput.getAttribute("data-type");
            var url = fileInput.getAttribute("data-url");

            if (dataType == "NAVIGATE") {
                MM.partialUpdate(element, subElementKey);
            } else if (dataType == "SUBMIT") {
                var url = fileInput.getAttribute("data-url");
                Form.submit(url, true);
            }
            //All files uploaded
            loader.parentNode.setAttribute("style", "display:none;");
        }
    },

    /** END: filePicker **/

    /** filePicker cancel button **/

    filePickerCancel: function (element, subElementKey) {


        var fileInput = element.parentElement.querySelectorAll('input[type="file"]')[0];

        var dataType = fileInput.getAttribute("data-type");
        var url = fileInput.getAttribute("data-cancelUiid"); //|| fileInput.getAttribute("data-backUiid");

        if (dataType == "NAVIGATE") {
            Form.navigate(url, true);
        } else if (dataType == "UPDATE") {
            MM.partialUpdate(element, subElementKey);
        } else if (dataType == "SUBMIT") {
            Form.submit(url, true);
        }

    },

    /** END: filePicker cancel button **/

    /**Native filePicker**/

    updateLabelNative: function (input) {

        input.setAttribute("data-file-selected", "true");

        var maxSize = input.getAttribute("data-maxSize");
        var noFiles = input.getAttribute("data-noFilesFoundMessage");
        var maxSizeMessage = input.getAttribute("data-maxSizeMessage");
        var invalidMimeTypeMessage = input.getAttribute("data-invalidMimeTypeMessage");
        var selectionLimit = input.getAttribute("data-selectionLimit");
        var selectionLimitMessage = input.getAttribute("data-selectionLimitMesssage");
        var nativeFilePicker = document.getElementById("nativeOverlay");

        //Image cropper attributes
        var cropStyle = input.getAttribute("data-cropStyle");
        var cropSource = input.getAttribute("data-cropSource");
        var doneText = input.getAttribute("data-doneText");

        input.blur();
        nativeFilePicker.style.display = "";

        //using an attribute from thing settings to see if it was recieved if not then display error message
        if (input.getAttribute("data-fileNamePrefix") == "" || input.getAttribute("data-fileNamePrefix") == null) {

            var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = "Your request cannot be processed, please try again later.";
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        var mimeTypes = input.getAttribute("accept");

        if (mimeTypes !== null) {
            mimeTypes = mimeTypes.split(",");
        }
        var mimeValid = false;

        if (input.files.length === 0) {

            var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = noFiles;
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        if (input.files.length > selectionLimit) {

            var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

            message.innerText = selectionLimitMessage;
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        var mimeCheckSize = input.files.length;
        var mimeCheck = 0;

        for (var file = 0; file < input.files.length; file++) {

            var currentFile = input.files[file];

            for (mimeCount = 0; mimeCount < mimeTypes.length; ++mimeCount) {
                var mimeType = mimeTypes[mimeCount];

                if (mimeType === currentFile.type) {
                    mimeCheck++;
                }
            }
        }

        if (mimeCheckSize == mimeCheck) {
            mimeValid = true;
        } else {
            mimeValid = false;
        }

        if (!mimeValid) {
            //File not correct type

            var messageBackdrop = (nativeFilePicker.querySelector('.nativeFilePickerMessageBackdrop'));
            var message = messageBackdrop.querySelector('.nativeFilePickerMessage');

            message.innerText = invalidMimeTypeMessage;
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
            input.value = "";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
            return;
        }

        for (var file = 0; file < input.files.length; file++) {

            var currentFile = input.files[file];

            if (currentFile.size > maxSize) {
                //File to big

                var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
                var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];

                message.innerText = maxSizeMessage;
                messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";
                input.value = "";

                var timerId = setInterval(function () {
                    Timers.clearOne(timerId);

                    messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                    message.innerText = "";
                    nativeFilePicker.style.display = "none";

                }, 3000);
                Timers.register(timerId);
                return;
            }
        }


        var element = input.id;
        var subElementKey = "upload";

        if (cropStyle != null && cropStyle != "" && cropStyle != "null") {
            MM.setCropAttributes(input, element, subElementKey, cropStyle, cropSource, doneText);
        } else {
            MM.uploadFilesNative(element, subElementKey);
        }

    },

    uploadFilesNative: function (element, subElementKey, crop, newFiles) {
        var fileInputs = document.querySelectorAll('[data-file-selected="true"]');

        var nativeFilePicker = document.getElementById("nativeOverlay");
        var loaderBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerLoaderBackdrop'))[0];

        loaderBackdrop.setAttribute("style", "");
        var loader = (loaderBackdrop.querySelectorAll('.nativeFilePickerLoader'))[0];
        var removeloader = true;
        var uniqueNameList = [];

        if (crop == true) {

            //Convert array with file object to fileList with file object for FileReader

            var list = new DataTransfer();
            list.items.add(newFiles[0]);
            var files = list.files;

        } else {
            var files = fileInputs[0].files;
        }

        for (var fileIndex = 0; fileIndex < files.length; fileIndex++) {

            //Sort out sync issue with FileReader
            var uniqueName = "index:" + fileIndex + " " + files[fileIndex].name;
            uniqueNameList[fileIndex] = uniqueName;

            MM._filePickerSyncHandler.addFilePicker(uniqueName, files.length);
        }

        for (var file = 0; file < files.length; file++) {

            removeloader = false;

            var fileInput = fileInputs[0];

            if (crop == true) {

                //Convert array with file object to fileList with file object for FileReader

                var list = new DataTransfer();
                list.items.add(newFiles[0]);
                var filesUpload = list.files;

            } else {
                var filesUpload = fileInputs[0].files;
            }

            var reader = new FileReader(filesUpload);
            reader.readAsDataURL(files[file]);
            reader.onload = (function (fileInput, filesUpload, file) {
                return function (e) {
                    var data = e.target.result;
                    var payload = data.split(',')[1];

                    var xhr = new XMLHttpRequest();

                    loader.onclick = (function (xhr) {
                        return function () {
                            xhr.abort();
                            loader.parentNode.setAttribute("style", "display:none;");
                            nativeFilePicker.style.display = "none";
                        }
                    })(xhr);

                    xhr.addEventListener("load", function (evt) {
                        MM.uploadFileNative(evt, loader, fileInput, element, subElementKey, uniqueNameList[file], filesUpload[file].name, file);
                    }, true);

                    xhr.open("POST", "/banking/thingUpload?host=" + fileInput.getAttribute('data-host') + "&port=" + fileInput.getAttribute('data-port') +
                        "&userName=" + fileInput.getAttribute('data-userName') + "&password=" + fileInput.getAttribute('data-password') +
                        "&fileName=" + filesUpload[file].name + "&filePrefix=" + fileInput.getAttribute('data-fileNamePrefix') +
                        "&maxSize=" + fileInput.getAttribute('data-maxSize') + "&fileNumber=" + file);
                    xhr.send(payload);
                };
            })(fileInput, filesUpload, file);

            reader.onerror = (function () {
                return function (e) {

                    loader.parentNode.setAttribute("style", "display:none;");
                    var messageBackdrop = (nativeFilePicker.querySelector('.nativeFilePickerMessageBackdrop'));
                    var message = messageBackdrop.querySelector('.nativeFilePickerMessage');

                    message.innerText = "Your request cannot be processed, please try again later.";
                    messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";

                    var timerId = setInterval(function () {
                        Timers.clearOne(timerId);

                        messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                        message.innerText = "";
                        nativeFilePicker.style.display = "none";

                    }, 3000);
                    Timers.register(timerId);

                }
            })();
        }

        //No file to upload
        if (removeloader) {
            loader.parentNode.setAttribute("style", "display:none;");
        }

    },

    uploadFileNative: function (evt, loader, fileInput, element, subElementKey, uniqueName, fileName, index) {

        MM._filePickerSyncHandler.decrementFilePickerSize(uniqueName);

        var response = JSON.parse(evt.currentTarget.responseText);

        if (response.returnInfo === "failed") {
            loader.parentNode.setAttribute("style", "display:none;");

            var nativeFilePicker = document.getElementById("nativeOverlay");
            var messageBackdrop = (nativeFilePicker.querySelectorAll('.nativeFilePickerMessageBackdrop'))[0];
            var message = (messageBackdrop.querySelectorAll('.nativeFilePickerMessage'))[0];
            var uploadFailedMessage = fileInput.getAttribute("data-uploadFailureMessage");

            message.innerText = uploadFailedMessage;
            messageBackdrop.className = "nativeFilePickerMessageBackdrop nativeFilePickerMessageBackdropFlash";

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                messageBackdrop.className = "nativeFilePickerMessageBackdrop";
                message.innerText = "";
                nativeFilePicker.style.display = "none";

            }, 3000);
            Timers.register(timerId);
        }

        if (response.returnInfo === "success") {
            var hashedValue = response.returnHash;
            var input = document.createElement("input");

            input.type = "hidden";

            if (fileInput.getAttribute("data-currentSymbolID") === fileInput.getAttribute("data-rightButtonId")) {
                input.name = fileInput.getAttribute("data-currentSymbolID") + ":filename_" + (index + 1) + ":upload";
            } else {
                input.name = fileInput.getAttribute("data-currentSymbolID") + ":" + fileInput.getAttribute("data-rightButtonId") + ":filename_" + (index + 1) + ":upload";
            }
            input.value = hashedValue + ":" + fileName;
            input.setAttribute("data-ignoreEmpty", "true");

            fileInput.parentNode.appendChild(input);

            MM._filePickerSyncHandler.deleteFilePicker(uniqueName);
        }

        if (MM._filePickerSyncHandler._filePickerList.length === 0) {

            var currentSymbol = document.getElementById(fileInput.getAttribute("data-currentSymbolID"));
            var fileSymbolKey = fileInput.getAttribute("data-rightButtonId");
            var symbolType = fileInput.getAttribute("data-symbolType").trim();
            var subElementType = fileInput.getAttribute("data-subElementType").trim();
            var type = (subElementType == '') ? symbolType : subElementType;

            if (type === "NATIVE_FILE_PICKER_UPDATE") {

                if (fileInput.getAttribute("data-currentSymbolID") === fileInput.getAttribute("data-rightButtonId")) {
                    MM.partialUpdate(currentSymbol);
                } else {
                    MM.partialUpdateSubElementKey(currentSymbol, fileSymbolKey);
                }

            } else if (type === "NATIVE_FILE_PICKER_SUBMIT") {

                var url = fileInput.getAttribute("data-url");
                Form.submit(url, true);
            } else if (type === "NATIVE_FILE_PICKER_UPDATE_FE") {
                MM._partialUpdateFrontEnd(currentSymbol);
            }
            //All files uploaded
            var nativeFilePicker = document.getElementById("nativeOverlay");

            loader.parentNode.setAttribute("style", "display:none;");
            nativeFilePicker.style.display = "none";
        }
    },

    /**END: Native filePicker**/

    /** calenderMonth **/

    calenderMonthSetClicked: function (e, element) {
        var epoch = e.getAttribute("data-epoch");
        element.value = epoch;
    },

    /** END: calenderMonth **/

    /** multiMarkersMap **/

    multiMarkersMapInit: function () {
        var maps = document.querySelectorAll('[data-multiMap-symbol="true"]');

        if (maps.length > 0) {
            if (!(typeof google === 'object' && typeof google.maps === 'object')) {
                var script = document.createElement('script');
                script.type = "text/javascript";
                script.src = "https://maps.googleapis.com/maps/api/js?key=AIzaSyA3HZioTaxXDA4uyUqagd7B9gH9Rcc1ujs&libraries=places&callback=MM.multiMarkersMapStartup";
                document.body.appendChild(script);
            } else {
                MM.multiMarkersMapStartup();
            }
        }
    },

    multiMarkersMapStartup: function () {

        var maps = document.querySelectorAll('[data-multiMap-symbol="true"]');

        for (mapCount = 0; mapCount < maps.length; ++mapCount) {
            var mapElement = maps[mapCount];
            mapElement.setAttribute("data-multiMap-symbol", "false");

            MM.multiMarkerMapFill(mapElement);

            var map = new google.maps.Map(mapElement, {
                center: {
                    lat: parseFloat((mapElement.getAttribute("data-map-latitude") === '') ? '-25.7479' : mapElement.getAttribute("data-map-latitude")),
                    lng: parseFloat((mapElement.getAttribute("data-map-longitude") === '') ? '28.2293' : mapElement.getAttribute("data-map-longitude"))
                },
                zoom: parseFloat((mapElement.getAttribute("data-map-zoom") === '') ? '13' : mapElement.getAttribute("data-map-zoom")),
                scrollwheel: true,			//This option is used for disable zoom on mouse.
                scaleControl: true,		//This option is used for disable zoom by scale.
                draggable: true,			//This option is used for disabling drag.
                mapTypeControl: false,		//This option will hide map type.
                streetViewControl: false,	//This removes street view controls
                zoomControl: false,			//This removes zoom controls
                fullscreenControl: false,	//This remove full screen
                mapTypeId: 'roadmap'
            });

            //Manage markers via this list
            google.maps.Map.prototype.markers = [];

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function (position) {
                    //Initial position marker on client location
                    google.maps.Map.prototype.markers.push(new google.maps.Marker({
                        position: {lat: position.coords.latitude, lng: position.coords.longitude},
                        map: map,
                        icon: mapElement.getAttribute("data-map-pin")
                    }));
                });
            } else {
                //Initial position marker on backend lat lng
                google.maps.Map.prototype.markers.push(new google.maps.Marker({
                    position: {
                        lat: parseFloat((mapElement.getAttribute("data-map-latitude") === '') ? '-25.7479' : mapElement.getAttribute("data-map-latitude")),
                        lng: parseFloat((mapElement.getAttribute("data-map-longitude") === '') ? '28.2293' : mapElement.getAttribute("data-map-longitude"))
                    },
                    map: map,
                    icon: mapElement.getAttribute("data-map-pin")
                }));
            }

            //Add Additional Markers
            var markers = mapElement.getAttribute("data-map-markers");
            if (markers !== "") {
                markers = JSON.parse(markers);

                //Clean Markers out of the attribute
                mapElement.setAttribute("data-map-markers", "");

                if (markers !== null && markers.length > 0) {
                    for (var markerCount = 0; markerCount < markers.length; ++markerCount) {
                        var marker = markers[markerCount];

                        var googleMarker = new google.maps.Marker({
                            position: {lat: parseFloat(marker.latitude), lng: parseFloat(marker.longitude)},
                            map: map,
                            icon: marker.iconId
                        });

                        googleMarker.addListener('click', (function (marker, mapElement) {
                            return function () {
                                if (marker.actionType === "UPDATE") {
                                    MM.partialUpdateSubElementKey(mapElement, marker.key);
                                } else if (marker.actionType === "NETWORK_PROVIDER") {
                                    window.location = 'tel:' + marker.value;
                                } else if (marker.actionType === "SUBMIT") {
                                    Form.submit(marker.uiid);
                                } else if (marker.actionType === "NAVIGATE") {
                                    Form.navigate(marker.uiid);
                                }
                            }
                        })(marker, mapElement));

                        google.maps.Map.prototype.markers.push(googleMarker);
                    }
                }
            }

            // Create the search box and link it to the UI element.
            var input = (mapElement.parentNode.getElementsByClassName('mapInput'))[0];

            if (input != null) {
                var searchBox = new google.maps.places.SearchBox(input);

                //Stop enter press problems
                google.maps.event.addDomListener(input, 'keydown', function (event) {
                    if (event.keyCode === 13) {
                        event.preventDefault();
                    }
                });

                // Bias the SearchBox results towards current map's viewport and update the JSON Object
                map.addListener('bounds_changed', (function (input, searchBox, map) {
                    return function () {
                        searchBox.setBounds(map.getBounds());
                        MM.multiMarkersMapUpdateInfo(input, map);
                    }
                })(input, searchBox, map));

                map.addListener('idle', (function (input, searchBox, map) {
                    return function () {
                        MM.partialUpdate(input);
                    }
                })(input, searchBox, map));

                // Listen for the event fired when the user selects a prediction and retrieve
                // more details for that place.
                searchBox.addListener('places_changed', (function (searchBox, map) {
                    return function () {
                        var places = searchBox.getPlaces();

                        if (places.length === 0) {
                            return;
                        }

                        // For each place, get the icon, name and location.
                        var bounds = new google.maps.LatLngBounds();

                        places.forEach(function (place) {
                            if (!place.geometry) {
                                console.log("Returned place contains no geometry");
                                return;
                            }
                            if (place.geometry.viewport) {
                                // Only geocodes have viewport.
                                bounds.union(place.geometry.viewport);
                            } else {
                                bounds.extend(place.geometry.location);
                            }
                        });

                        map.fitBounds(bounds)
                    }
                })(searchBox, map));
            }
        }
    },

    multiMarkersMapUpdateInfo: function (input, map) {

        var inputInfo = (input.parentNode.querySelectorAll('input[type="hidden"]'))[0];

        var JSONObject = {
            zoomLevel: map.getZoom(),
            latitude: map.getCenter().lat(),
            longitude: map.getCenter().lng(),
            topLeft: {
                latitude: map.getBounds().getNorthEast().lat(),
                longitude: map.getBounds().getSouthWest().lng()
            },
            topRight: {
                latitude: map.getBounds().getNorthEast().lat(),
                longitude: map.getBounds().getNorthEast().lng()
            },
            bottomLeft: {
                latitude: map.getBounds().getSouthWest().lat(),
                longitude: map.getBounds().getSouthWest().lng()
            },
            bottomRight: {
                latitude: map.getBounds().getSouthWest().lat(),
                longitude: map.getBounds().getNorthEast().lng()
            },
        };

        inputInfo.value = JSON.stringify(JSONObject);

    },

    multiMarkerMapFill: function (e) {
        if (e.parentNode.parentNode.parentNode.classList.contains("StructuredContainerBody") && e.parentNode.parentNode.style.height === "100%") {
            e.parentNode.parentNode.parentNode.style.height = "100%";
        }
    },

    /** END: multiMarkersMap **/

    /** map **/

    mapSetHeight: function () {
        var mapContainer = document.querySelectorAll('.mapGrid');
        var footer = document.getElementById("footer");
        var header = document.getElementById("headerFixed");
        var baseBody = document.querySelector(".baseBody");

        if (mapContainer != null && mapContainer.length > 0 && baseBody != null && footer != null && header != null) {
            for (mapCount = 0; mapCount < mapContainer.length; ++mapCount) {
                var map = mapContainer[mapCount];

                if (map.getAttribute("data-setHeight") == "true") {
                    if (window.matchMedia("(min-width: 500px) and (max-width: 799px)").matches) {
                        //In between 500px - 799px screens padding of base is not restricted so we use the height of footer and header and add styling to map to ignore parent padding
                        //Map height is the full screen height - footer height - header height
                        map.style.height = "calc((100vh - " + window.getComputedStyle(footer).height + ") - " + window.getComputedStyle(header).height + ")";
                        map.style.position = "fixed";
                    } else {
                        //Outside of the 500px - 799px case this sets height correctly
                        //Map height is the full screen height - base paddingtop - base paddingbottom
                        map.style.height = "calc((100vh - " + window.getComputedStyle(baseBody).paddingTop + ") - " + window.getComputedStyle(baseBody).paddingBottom + ")";
                        map.style.position = "unset";
                    }
                }

            }
        }
    },

    mapInit: function () {

        var maps = document.querySelectorAll('[data-map-symbol="true"]');

        if (maps.length > 0) {
            if (!(typeof google === 'object' && typeof google.maps === 'object')) {
                var script = document.createElement('script');
                script.type = "text/javascript";
                script.src = "https://maps.googleapis.com/maps/api/js?key=AIzaSyA3HZioTaxXDA4uyUqagd7B9gH9Rcc1ujs&libraries=places&callback=MM.mapStartup";
                document.body.appendChild(script);
            } else {
                MM.mapStartup();
            }
        }
    },

    mapStartup: function () {

        var maps = document.querySelectorAll('[data-map-symbol="true"]');

        for (mapCount = 0; mapCount < maps.length; ++mapCount) {
            var mapElement = maps[mapCount];

            var map = new google.maps.Map(mapElement, {
                center: {

                    lat: parseFloat((mapElement.getAttribute("data-map-latitude") === '') ? '-25.7479' : mapElement.getAttribute("data-map-latitude")),
                    lng: parseFloat((mapElement.getAttribute("data-map-longitude") === '') ? '28.2293' : mapElement.getAttribute("data-map-longitude"))
                },
                zoom: 13,
                scrollwheel: true,			//This option is used for disable zoom on mouse.
                scaleControl: true,			//This option is used for disable zoom by scale.
                draggable: true,			//This option is used for disabling drag.
                mapTypeControl: false,		//This option will hide map type.
                streetViewControl: false,	//This removes street view controls
                zoomControl: false,			//This removes zoom controls
                fullscreenControl: false,	//This remove full screen
                mapTypeId: 'roadmap'
            });

            //Manage markers via this list
            google.maps.Map.prototype.markers = [];

            //Initial position marker
            var mapMarker = new google.maps.Marker({
                position: {
                    lat: parseFloat((mapElement.getAttribute("data-map-latitude") === '') ? '-25.7479' : mapElement.getAttribute("data-map-latitude")),
                    lng: parseFloat((mapElement.getAttribute("data-map-longitude") === '') ? '28.2293' : mapElement.getAttribute("data-map-longitude"))
                },
                map: map,
                icon: mapElement.getAttribute("data-map-pin")
            });

            google.maps.Map.prototype.markers.push(mapMarker);

            // Create the search box and link it to the UI element.
            var input = (mapElement.parentNode.getElementsByClassName('mapInput'))[0];
            if (input != null) {
                //map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

                //Stop enter press problems
                var searchBox = new google.maps.places.SearchBox(input);
                google.maps.event.addDomListener(input, 'keydown', function (event) {
                    if (event.keyCode === 13) {
                        event.preventDefault();
                    }
                });

                google.maps.event.addListener(map, 'click', (function (map, input) {
                    return function (event) {

                        // Clear out the old markers.
                        google.maps.Map.prototype.markers.forEach(function (marker) {
                            marker.setMap(null);
                        });
                        google.maps.Map.prototype.markers = [];

                        var geocoder = new google.maps.Geocoder;
                        //var infowindow = new google.maps.InfoWindow;

                        geocoder.geocode({'location': event.latLng}, function (results, status) {
                            if (status === 'OK') {
                                if (results[0]) {
                                    map.setZoom(13);
                                    google.maps.Map.prototype.markers.push(new google.maps.Marker({
                                        position: event.latLng,
                                        map: map,
                                        icon: mapElement.getAttribute("data-map-pin")
                                    }));

                                    //Update data
                                    MM.mapUpdateInfo(input, results[0]);

                                    input.value = results[0].formatted_address;

                                    //infowindow.setContent(results[0].formatted_address);
                                    //infowindow.open(map, marker);
                                } else {
                                    window.alert('No results found');
                                }
                            } else {
                                window.alert('Geocoder failed due to: ' + status);
                            }
                        });
                    }
                })(map, input));


                // Bias the SearchBox results towards current map's viewport.
                map.addListener('bounds_changed', (function (searchBox, map) {
                    return function () {
                        searchBox.setBounds(map.getBounds());
                    }
                })(searchBox, map));

                // Listen for the event fired when the user selects a prediction and retrieve
                // more details for that place.
                searchBox.addListener('places_changed', (function (input, searchBox, map) {
                    return function () {
                        var places = searchBox.getPlaces();

                        if (places.length === 0) {
                            return;
                        }

                        // Clear out the old markers.
                        google.maps.Map.prototype.markers.forEach(function (marker) {
                            marker.setMap(null);
                        });
                        google.maps.Map.prototype.markers = [];

                        // For each place, get the icon, name and location.
                        var bounds = new google.maps.LatLngBounds();
                        places.forEach(function (place) {
                            if (!place.geometry) {
                                console.log("Returned place contains no geometry");
                                return;
                            }

                            //Check if only 1 place and set data
                            if (places.length === 1) {
                                MM.mapUpdateInfo(input, place);
                            }

                            // var icon = {
                            //     url: place.icon,
                            //     size: new google.maps.Size(71, 71),
                            //     origin: new google.maps.Point(0, 0),
                            //     anchor: new google.maps.Point(17, 34),
                            //     scaledSize: new google.maps.Size(25, 25)
                            // };

                            // Create a marker for each place.
                            google.maps.Map.prototype.markers.push(new google.maps.Marker({
                                map: map,
                                icon: mapElement.getAttribute("data-map-pin"),
                                title: place.name,
                                position: place.geometry.location
                            }));

                            if (place.geometry.viewport) {
                                // Only geocodes have viewport.
                                bounds.union(place.geometry.viewport);
                            } else {
                                bounds.extend(place.geometry.location);
                            }
                        });
                        map.fitBounds(bounds);
                    }
                })(input, searchBox, map));
            }

            if (mapElement.getAttribute("data-map-startAtCurrentLocation") == "Y") {
                MM.mapGoToCurrentLocation(map, mapMarker, false);
            }

            MM.setMyLocationButton(map, mapMarker);
        }
    },

    mapUpdateInfo: function (input, data) {

        var inputInfo = (input.parentNode.querySelectorAll('input[type="hidden"]'))[0];

        //data.address_components[]

        var JSONObject = {
            addressLines: data.formatted_address,
            subThoroughfare: "",
            thoroughFare: "",
            subLocality: "",
            locality: "",
            subAdminArea: "",
            adminArea: "",
            countryCode: "",
            countryName: "",
            postalCode: "",
            latitude: data.geometry.location.lat(),
            longitude: data.geometry.location.lng()
        };

        for (var addressCount = 0; addressCount < data.address_components.length; addressCount++) {
            var addressComponent = data.address_components[addressCount];

            for (var typeCount = 0; typeCount < addressComponent.types.length; typeCount++) {
                var type = addressComponent.types[typeCount];

                switch (type) {
                    case "street_number":
                        JSONObject.subThoroughfare = addressComponent.long_name;
                        break;
                    case "route":
                        JSONObject.thoroughFare = addressComponent.long_name;
                        break;
                    case "sublocality":
                        JSONObject.subLocality = addressComponent.long_name;
                        break;
                    case "locality":
                        JSONObject.locality = addressComponent.long_name;
                        break;
                    case "administrative_area_level_2":
                        JSONObject.subAdminArea = addressComponent.long_name;
                        break;
                    case "administrative_area_level_1":
                        JSONObject.adminArea = addressComponent.long_name;
                        break;
                    case "country":
                        JSONObject.countryCode = addressComponent.short_name;
                        JSONObject.countryName = addressComponent.long_name;
                        break;
                    case "postal_code":
                        JSONObject.postalCode = addressComponent.long_name;
                        break;
                }
            }

        }

        inputInfo.value = JSON.stringify(JSONObject);

    },
    /*setting go to my current location button on the map */
    setMyLocationButton: function (map, marker) {
        var myLocationButton = document.getElementsByClassName("myLocationButton")[0];
        if (myLocationButton != null) {
            myLocationButton.addEventListener('click', function () {
                if (navigator.geolocation) {
                    MM.mapGoToCurrentLocation(map, marker, true);
                }
            });
        }
    },

    mapGoToCurrentLocation: function (map, marker, updateMapInfo) {
        var startPos;
        var geoOptions = {
            //accept cached position no older than 30 minute
            maximumAge: 300000,
        };

        var geoSuccess = function (position) {
            startPos = position;
            var latlng = new google.maps.LatLng(startPos.coords.latitude, startPos.coords.longitude);
            marker.setPosition(latlng);
            map.setCenter(latlng);
            map.setZoom(15);

            if (updateMapInfo) {
                var geocoder = new google.maps.Geocoder;

                geocoder.geocode({'location': latlng}, function (results, status) {
                    if (status === 'OK') {
                        if (results[0]) {
                            var mapElement = document.querySelectorAll('[data-map-symbol="true"]')[0];
                            var input = (mapElement.parentNode.getElementsByClassName('mapInput'))[0];

                            // Clear out the old markers.
                            google.maps.Map.prototype.markers.forEach(function (marker) {
                                marker.setMap(null);
                            });
                            google.maps.Map.prototype.markers = [];

                            google.maps.Map.prototype.markers.push(new google.maps.Marker({
                                position: latlng,
                                map: map,
                                icon: mapElement.getAttribute("data-map-pin")
                            }));

                            //Update map data to send
                            MM.mapUpdateInfo(input, results[0]);
                            input.value = results[0].formatted_address;

                        } else {
                            window.alert('No results found');
                        }
                    } else {
                        window.alert('Geocoder failed due to: ' + status);
                    }
                });
            }
        };

        var geoError = function (error) {
            var userDeniedGeolocationDiv = document.getElementById("userDeniedGeolocation");
            Form.navigate(userDeniedGeolocationDiv.getAttribute("data-url"));
        };

        navigator.geolocation.getCurrentPosition(geoSuccess, geoError, geoOptions);
    },

    /** END: map **/

    /** parallaxContainer **/

    scrollParallaxContainer: function () {
        var parallaxContainers = document.querySelectorAll(".parallaxContainer");
        var speed = 0.5;

        for (var paraCount = 0; paraCount < parallaxContainers.length; paraCount++) {
            var parallaxContainer = parallaxContainers[paraCount];
            var parallaxContainerParent = parallaxContainer.parentNode;

            for (var paraTranslateSetupCount = 0; paraTranslateSetupCount < parallaxContainer.children.length; paraTranslateSetupCount++) {
                var parallaxContainerChild = parallaxContainer.children[paraTranslateSetupCount];
                MM.setupTransformParallaxContainerChildren(parallaxContainerChild, MM.parallaxContainerChildCheckVisible(parallaxContainerChild));
            }

            parallaxContainerParent.onscroll = (function (parallaxContainer, parallaxContainerParent) {
                return function () {
                    var parentYOffset = parallaxContainerParent.scrollTop;
                    var childYCenter = parallaxContainer.scrollHeight;
                    parallaxContainer.style.backgroundPosition = "center " + ((-(childYCenter / 2)) + (parentYOffset * speed)) + "px";

                    //Check and do any translates
                    for (var paraTranslateCount = 0; paraTranslateCount < parallaxContainer.children.length; paraTranslateCount++) {
                        var parallaxContainerChild = parallaxContainer.children[paraTranslateCount];
                        //Transform
                        MM.transformParallaxContainerChildren(parallaxContainerChild, MM.parallaxContainerChildCheckVisible(parallaxContainerChild, 150));
                    }
                };
            })(parallaxContainer, parallaxContainerParent);
        }
    },

    parallaxContainerChildCheckVisible: function (elm, threshold, mode) {
        threshold = threshold || 0;
        mode = mode || 'visible';

        var rect = elm.getBoundingClientRect();
        var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
        var above = rect.bottom - threshold < 0;
        var below = rect.top - viewHeight + threshold >= 0;

        return mode === 'above' ? above : (mode === 'below' ? below : !above && !below);
    },

    setupTransformParallaxContainerChildren: function (symbol, state) {
        if (state) {
            symbol.classList.add(symbol.getAttribute("data-transform-in"));
        } else {
            symbol.classList.add(symbol.getAttribute("data-transform-out"));
        }
    },

    transformParallaxContainerChildren: function (symbol, state) {
        if (state) {
            if (!symbol.classList.contains(symbol.getAttribute("data-transform-in"))) {
                symbol.classList.remove(symbol.getAttribute("data-transform-out"));
                symbol.classList.add(symbol.getAttribute("data-transform-in"));
            }
        } else {
            if (!symbol.classList.contains(symbol.getAttribute("data-transform-out"))) {
                symbol.classList.remove(symbol.getAttribute("data-transform-in"));
                symbol.classList.add(symbol.getAttribute("data-transform-out"));
            }
        }
    },

    transformParallaxChildLeft: function (symbol) {

    },

    /** END: parallaxContainer **/

    /** Correct: Custom function to ellipse overflow text (hack) **/
    ellipsisText: function () {
        var counter;
        var lineHeight;
        var amountOfLines;
        var text;
        var el = document.querySelectorAll("[ellipsis-me]");

        for (var elCounter = 0; elCounter < el.length; elCounter++) {
            lineHeight = parseInt(window.getComputedStyle(el[elCounter], null).getPropertyValue('line-height'));
            amountOfLines = parseInt(el[elCounter].getAttribute("ellipsis-me"));
            text = el[elCounter].innerHTML;
            el[elCounter].innerHTML = "";
            for (counter = 1; parseInt(window.getComputedStyle(el[elCounter], null).getPropertyValue('height')) <= lineHeight * amountOfLines && text.length >= counter; counter++) {
                el[elCounter].innerHTML += text.slice(counter - 1, counter);
            }
            if (parseInt(window.getComputedStyle(el[elCounter], null).getPropertyValue('height')) > lineHeight * amountOfLines) {
                el[elCounter].innerHTML = el[elCounter].innerHTML.slice(0, counter - 5);
                el[elCounter].innerHTML += "...";
            } else {
                el[elCounter].style.height = "calc(" + amountOfLines * (lineHeight / Root.unit()) + " * var(--unit))";
            }
        }
    },

    partialUpdateSubElementKeyFrontEnd: function (e, subElementKey, blockerEnabled) {
        MM._partialUpdateFrontEnd(e, subElementKey, blockerEnabled);
    },

    _partialUpdateFrontEnd: function (e, subElementKey, blockerEnabled) {

        //Elton: This is to ignore the forced removal of the on screen keyboard for partial updates
        //This is done by adding the class name "ignoreKeyboardRemoval" to your element
        //This is done in two functions (_partialUpdateFrontEnd, partialUpdateResponseHandler)
        //and once in the popupHeaderFooterHide function to avoid incorrect spacing when adding to composebar
        if (document.querySelector(".ignoreKeyboardRemoval") == null) {
            //Elton: This is to fix screen calculation problem when keyboard is not removed from screen
            document.activeElement.blur();
        }

        if (blockerEnabled || blockerEnabled == undefined || blockerEnabled == null) {
            Loader.showPartialUpdate(true);
        }
        var requestType = null, swipeDelete = false, initiatedSymbolKey = null;
        var whileElement = e;

        if (whileElement.children[0] != null) {
            if (whileElement.children[0].className === "swipeDeleteContent") {
                swipeDelete = true;
            }
        }


        if (whileElement != null) {
            initiatedSymbolKey = whileElement.name == null || whileElement.name === "" ? whileElement.id : whileElement.name;

            if (subElementKey != null) {
                initiatedSymbolKey += ":" + subElementKey;
            }

            whileElement = whileElement.parentNode;
            if (whileElement.getAttribute("data-source") != null || whileElement.getAttribute("data-source") != "") {
                requestType = whileElement.getAttribute("data-source");
            }
        }

        var xhr = new XMLHttpRequest();

        document.getElementsByTagName("form")[0].setAttribute("swipeDelete", swipeDelete);
        var form = document.getElementsByTagName("form");

        var elements = form[0].elements;
        var params = "";
        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
        for (var i = 0, e; e = elements[i]; i++) {
            if (e.name && !e.disabled) {

                if (params.length > 0) {
                    params += "&";
                }
                if (e.getAttribute("data-URLEncodedPassThrough") === 'true') {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value)).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value));
                    }
                } else {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value);
                    }
                }
            }
        }

        xhr.open("POST", "/banking/partialFrontEndUpdate?requestType=" + requestType + "&swipeDelete=" + swipeDelete + "&initiatedSymbolKey=" + encodeURIComponent(initiatedSymbolKey));
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhr.onload = MM.partialUpdateResponseHandler.bind(xhr);
        xhr.send(params);
    },

    partialUpdateSubElementKey: function (e, subElementKey, blockerEnabled) {
        MM._partialUpdate(e, subElementKey, blockerEnabled);
    },

    partialUpdate: function (e, blockerEnabled) {
        MM._partialUpdate(e, null, blockerEnabled);
    },

    _partialUpdate: function (e, subElementKey, blockerEnabled) {
        //Elton: This is to fix screen calculation problem when keyboard is not removed from screen
        document.activeElement.blur();

        if (blockerEnabled || blockerEnabled == undefined || blockerEnabled == null) {
            Loader.showPartialUpdate(true);
        }
        var requestType = null, parent = null, initiatedSymbolKey = null, found = false;
        var whileElement = e;
        while (found == false) {
            if (whileElement != null) { //Vincent - Fixes issues with screen rotate on scrollers
                //Checks for child id
                if (initiatedSymbolKey == null && whileElement.id != "") {
                    if (whileElement.getAttribute("data-SkipId") !== "true") {
                        initiatedSymbolKey = whileElement.name == null ? whileElement.id : whileElement.name;
                        if (subElementKey != null) {
                            initiatedSymbolKey += ":" + subElementKey;
                        }
                    }
                }
                //Checks for parent data source
                var check = whileElement.getAttribute("data-source");
                if (check != null && check !== "") {
                    requestType = whileElement.getAttribute("data-source");
                    parent = whileElement.getAttribute("data-parent");
                    found = true;
                } else {
                    whileElement = whileElement.parentNode;
                }
            }
        }

        if (!requestType) {
            return;
        }
        var xhr = new XMLHttpRequest();

        var form = document.getElementsByTagName("form");

        var elements = form[0].elements;
        var params = "";
        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
        for (var i = 0, e; e = elements[i]; i++) {
            if (e.name && !e.disabled) {
                /**Allow unchecked checkbox to be submitted**/
                //if (e.type == "checkbox" && !e.checked) {
                //	continue;
                //}
                if (params.length > 0) {
                    params += "&";
                }
                if (e.getAttribute("data-URLEncodedPassThrough") === 'true') {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value)).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value));
                    }
                } else {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value);
                    }
                }
            }
        }

        xhr.open("POST", "/banking/partialMM?requestType=" + requestType + "&parent=" + parent + "&initiatedSymbolKey=" + encodeURIComponent(initiatedSymbolKey));
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhr.onload = MM.partialUpdateResponseHandler.bind(xhr);
        xhr.send(params);
    },

    _partialUpdateSessionReplay: function (e, subElementKey, blockerEnabled) {

        //Elton: This is to ignore the forced removal of the on screen keyboard for partial updates
        //This is done by adding the class name "ignoreKeyboardRemoval" to your element
        //This is done in two functions (_partialUpdateFrontEnd, partialUpdateResponseHandler)
        //and once in the popupHeaderFooterHide function to avoid incorrect spacing when adding to composebar
        if (document.querySelector(".ignoreKeyboardRemoval") == null) {
            //Elton: This is to fix screen calculation problem when keyboard is not removed from screen
            document.activeElement.blur();
        }

        if (blockerEnabled || blockerEnabled == undefined || blockerEnabled == null) {
            Loader.showPartialUpdate(true);
        }
        var requestType = null, parent = null, initiatedSymbolKey = null;
        var whileElement = e;
        var SRData = document.getElementById("MMSessionReplayUpdate");

        var SRParent = SRData.getAttribute("data-parent");
        var SRSource = SRData.getAttribute("data-source");

        requestType = "fester.ui.get";
        parent = SRParent;

        var xhr = new XMLHttpRequest();

        var form = document.getElementsByTagName("form");

        var elements = form[0].elements;
        var params = "";
        var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
        for (var i = 0, e; e = elements[i]; i++) {
            if (e.name && !e.disabled) {

                if (params.length > 0) {
                    params += "&";
                }
                if (e.getAttribute("data-URLEncodedPassThrough") === 'true') {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value)).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(encodeURIComponent(e.value));
                    }
                } else {
                    if (iOS) {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value).replace(/%E2%80%99/g, '%27');
                    } else {
                        params += encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value);
                    }
                }
            }
        }

        xhr.open("POST", "/banking/partialMMWithKey?requestType=" + requestType + "&initiatedSymbolKey=" + encodeURIComponent(initiatedSymbolKey));
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhr.onload = MM.partialUpdateResponseHandler.bind(xhr);
        xhr.send(params);
    },

    partialUpdateResponseHandler: function (blockerEnabled) {
        if (!MM._isUpdating) {
            try {
                var response = JSON.parse(this.responseText);

                //Check if the update was intended for this screen
                var panel = null;
                if(response.partialHelper.panelId !== null){
                    var panels = document.querySelectorAll("[data-panel='panelId']");
                    panels.forEach(function (panelItem) {
                        if(panelItem.value == response.partialHelper.panelId){
                            panel = panelItem;
                        }
                    })
                }

                var dataParents = document.querySelectorAll("[data-parent='" + response.partialHelper.dataParent + "']");
                if (dataParents.length > 0) {
                    //Do Clear
                    MM.partialUpdate_ClearHandler(panel, response.partialHelper.clears);
                    //Do Delete
                    MM.partialUpdate_DeleteHandler(panel, response.partialHelper.deletes);
                    //Do Add
                    MM.partialUpdate_AddHandler(panel, response.partialHelper.adds);
                    //Do Update
                    MM.partialUpdate_UpdateHandler(panel, response.partialHelper.updates);

                    //partial update for the title text
                    if (response.partialHelper.titleTextUpdate != null) {
                        var titleElement = document.querySelector(".headerTitle");
                        if (titleElement != null) {
                            titleElement.innerHTML = response.partialHelper.titleTextUpdate;
                        }
                    }

                    //Do Easy Scroller
                    AttachEasyScroller(1000);
                    //Do Anchor Bind
                    Form._bindAnchorsForAjax();

                    //Do Keyboard Quirks

                    //Elton: This is to ignore the forced removal of the on screen keyboard for partial updates
                    //This is done by adding the class name "ignoreKeyboardRemoval" to your element
                    //This is done in two functions (_partialUpdateFrontEnd, partialUpdateResponseHandler)
                    //and once in the popupHeaderFooterHide function to avoid incorrect spacing when adding to composebar
                    if (document.querySelector(".ignoreKeyboardRemoval") == null) {
                        Quirks._setAbsolute(false);
                    }
                    Quirks._applyInputFieldFix();

                    MM.init();

                } else {
                    console.log("Could not update...Data parent not found");
                }
            } catch (Exception) {
                console.log("Could not update...");
            }

            Loader.showPartialUpdate(false);
        }
    },

    partialUpdate_ClearHandler: function (panel, collection) {
        if (collection != null && collection.length > 0) {
            //Clear All Symbols inside Symbol
            for (clearCount = 0; clearCount < collection.length; clearCount++) {
                var symbol = collection[clearCount];
                var symbolDOM = null;
                if(panel !== null){
                    document.querySelectorAll("[data-panel='panelId']");
                    symbolDOM = panel.parentElement.querySelector("[id='"+ symbol.key +"']");
                }else{
                    symbolDOM = document.getElementById(symbol.key);
                }


                if (symbolDOM != null) {
                    while (symbolDOM.hasChildNodes()) {
                        symbolDOM.removeChild(symbolDOM.lastChild);
                    }
                } else {
                    console.log("Could not update...Clear Handler...Could not find symbol");
                }

            }
        }
    },

    partialUpdate_DeleteHandler: function (panel, collection) {
        if (collection != null && collection.length > 0) {
            //Delete All Symbols

            var domSymbols = [];

            for (deleteCount = 0; deleteCount < collection.length; deleteCount++) {
                var symbol = collection[deleteCount];

                var symbolDOM = null;
                if(panel !== null){
                    symbolDOM = panel.parentElement.querySelector("[id='"+ symbol.key +"']");
                }else{
                    symbolDOM = document.getElementById(symbol.key);
                }

                if (symbolDOM != null) {
                    domSymbols.push(symbolDOM);
                } else {
                    console.log("Could not update...Delete Handler...Could not find symbol");
                }

            }

            var symbolsWithAnimation = [];
            var symbolsWithoutAnimation = [];
            var symbolsWithAnimationCount = 0;
            var symbolsWithoutAnimationCount = 0;

            for (animateOutCount = 0; animateOutCount < domSymbols.length; animateOutCount++) {
                var symbolDom = domSymbols[animateOutCount];
                MM.animateExitElement(symbolDom);

                if (domSymbols[animateOutCount].dataset.animationExit === "NONE") {
                    symbolsWithoutAnimation[symbolsWithoutAnimationCount] = domSymbols[animateOutCount];
                    symbolsWithoutAnimationCount++;
                } else {
                    symbolsWithAnimation[symbolsWithAnimationCount] = domSymbols[animateOutCount];
                    symbolsWithAnimationCount++;
                }
            }

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);
                for (animateOutCount = 0; animateOutCount < symbolsWithAnimation.length; animateOutCount++) {
                    var symbolDom = symbolsWithAnimation[animateOutCount];
                    if (symbolDom.parentNode !== null) {
                        symbolDom.parentNode.removeChild(symbolDom);
                    }
                }
            }, 600);
            Timers.register(timerId);

            for (animateOutCount = 0; animateOutCount < symbolsWithoutAnimation.length; animateOutCount++) {
                var symbolDom = symbolsWithoutAnimation[animateOutCount];
                symbolDom.parentNode.removeChild(symbolDom);
            }
        }
    },

    partialUpdate_AddHandler: function (panel, collection) {
        if (collection != null && collection.length > 0) {
            //Insert New Symbols
            for (addCount = 0; addCount < collection.length; addCount++) {
                var symbol = collection[addCount];

                var container = null;
                if(panel !== null){
                    container = panel.parentElement.querySelector("[id='"+ symbol.parent +"']");
                }else{
                    container = document.getElementById(symbol.parent);
                }

                if (container.getAttribute("data-hasNested") != null) {

                    container = container.firstElementChild;

                }

                if (container != null) {

                    var ordering = container.getAttribute("data-ordering");

                    var isAdded = false;
                    for (childCount = 0; childCount < container.children.length; childCount++) {
                        var element = container.children[childCount];
                        var elementOrder = element.getAttribute("data-order");

                        if (ordering == "ASC") {
                            if (parseInt(symbol.order) <= parseInt(elementOrder)) {
                                element.insertAdjacentHTML('beforebegin', symbol.html);
                                isAdded = true;

                                childCount = container.children.length;
                                break;
                            }
                        } else {
                            if (parseInt(symbol.order) >= parseInt(elementOrder)) {
                                element.insertAdjacentHTML('beforebegin', symbol.html);
                                isAdded = true;

                                childCount = container.children.length;
                                break;
                            }
                        }
                    }
                    if (!isAdded) {
                        var element = container.children[container.children.length - 1];
                        if (element != null) {
                            element.insertAdjacentHTML('afterend', symbol.html);
                        } else {
                            container.innerHTML = symbol.html;
                        }

                    }

                } else {
                    console.log("Could not update...Add Handler...Could not find container");
                }
            }
        }
    },

    partialUpdate_UpdateHandler: function (panel, collection) {
        if (collection != null && collection.length > 0) {
            //Update All Symbols
            for (updateCount = 0; updateCount < collection.length; updateCount++) {
                var symbol = collection[updateCount];
                var symbolDOM = null;

                if(panel !== null){
                    symbolDOM = panel.parentElement.querySelector("[id='"+ symbol.key +"']");
                }else{
                    symbolDOM = document.getElementById(symbol.key);
                }

                if (symbolDOM != null) {
                    var tempDiv = document.createElement('div');
                    tempDiv.innerHTML = symbol.html;
                    var Node = tempDiv.children[0];
                    symbolDOM.parentNode.replaceChild(Node, symbolDOM);
                } else {
                    console.log("Could not update...Update Handler...Could not find symbol");
                }
            }
        }
    },

    powerCardPinResponseHandler: function () {
        /*used to receive data from BE and pass to js*/
        try {
            var response = JSON.parse(this.responseText);

            if (response.key != null) {
                if (response.key == "pinBlockData") {
                    MM.powerCardDecryptPin(response.data);
                }
            }
        } catch (Exception) {
            console.log("Could not load pin data...");
        }
        Loader.showPartialUpdate(false);
    },


    /** Numeric selection button updateValue**/

    incrementValue: function (div) {
        var selectionSymbol = div.parentElement.parentElement;
        var hiddenInput = document.getElementById(div.getAttribute("data-hiddenInput"));

        if (selectionSymbol != null) {
            for (var count = 0; count < selectionSymbol.children.length; count++) {
                if (selectionSymbol.children[count].className == 'numericSelectionIconNumber') {
                    var innerTextValue = parseFloat(selectionSymbol.children[count].innerHTML);
                    if (innerTextValue >= 0) {
                        innerTextValue += 1;
                        if (innerTextValue <= div.getAttribute("data-maxValue")) {
                            selectionSymbol.children[count].innerHTML = innerTextValue;
                            hiddenInput.setAttribute("value", innerTextValue);
                        }
                    }
                }
            }


        }


    },

    decrementValue: function (div) {
        var selectionSymbol = div.parentElement.parentElement;
        var hiddenInput = document.getElementById(div.getAttribute("data-hiddenInput"));

        if (selectionSymbol != null) {
            for (var count = 0; count < selectionSymbol.children.length; count++) {
                if (selectionSymbol.children[count].className == 'numericSelectionIconNumber') {
                    var innerTextValue = parseFloat(selectionSymbol.children[count].innerHTML);
                    if (innerTextValue != 0 && innerTextValue) {
                        innerTextValue -= 1;
                        if (innerTextValue >= div.getAttribute("data-minValue")) {
                            selectionSymbol.children[count].innerHTML = innerTextValue;
                            hiddenInput.setAttribute("value", innerTextValue);
                        }
                    }
                }
            }

        }
    },
    /** End of: Numeric selection button updateValue**/

    /** Rating selection updateValue**/

    ratingSelection: function (e) {

        var value = e.getAttribute("data-count");
        var selectedIconBackground = "url(" + e.getAttribute("data-selectedIcon") + ")" + " center center no-repeat";
        var unSelectedIconBackground = "url(" + e.getAttribute("data-unSelectedIcon") + ")" + " center center no-repeat";
        var ratingMode = e.getAttribute("data-ratingMode");
        var ratingText = e.getAttribute("data-ratingText");
        var ratingTextColor = e.getAttribute("data-ratingTextColor");
        var datakey = e.getAttribute("data-key");
        e.parentElement.firstElementChild.value = datakey;

        if (ratingMode == 'LEFT_TO_RIGHT') {
            var x = value;
            e.parentElement.children[x].parentElement.parentElement.children[1].textContent = ratingText;
            e.parentElement.children[x].parentElement.parentElement.children[1].style.color = ratingTextColor;
            while (x != 0) {
                e.parentElement.children[x].style.background = selectedIconBackground;
                x--;
            }

            var y = value;
            while (y < e.parentElement.children.length) {
                y++;
                if (y < e.parentElement.children.length) {
                    e.parentElement.children[y].style.background = unSelectedIconBackground;
                }
            }
        } else if (ratingMode == 'NONE') {
            var x = value;
            e.parentElement.children[x].parentElement.parentElement.children[1].textContent = ratingText;
            e.parentElement.children[x].parentElement.parentElement.children[1].style.color = ratingTextColor;
            e.parentElement.children[x].style.background = selectedIconBackground;
            while (x != 0) {
                x--;
                e.parentElement.children[x].style.background = unSelectedIconBackground;
            }

            var y = value;
            while (y < e.parentElement.children.length) {
                y++;
                if (y < e.parentElement.children.length) {
                    e.parentElement.children[y].style.background = unSelectedIconBackground;
                }
            }
        }

    },

    /** End of: Rating selection updateValue***/


    /** Characters remaining updateValue**/


    charCounter: function (e) {
        var value = e.value != null ? e.value : e.innerHTML;
        var maxLength = e.maxLength != null ? e.maxLength : e.getAttribute("maxLength") != '' ? parseInt(e.getAttribute("maxLength")) : 0;

        if (maxLength > 0) {

            var remaining = maxLength - value.length;

            if (e.classList.contains("composedMessageTextBoxFull")) {
                var inputlabelRight = e.parentNode.parentElement.querySelector(".inputlabelRight");
                if (inputlabelRight != null)
                    inputlabelRight.innerHTML = remaining;
            }


            if (e.classList.contains("input")) {

                var hintLabel = e.parentElement.querySelector(".inputlabelRight");

                if (hintLabel.innerText != "") {
                    var hint = e.getAttribute("data-hint").split(" ");
                    var hText = "";
                    for (var text = 0; text < hint.length; text++) {

                        if (isNaN(hint[text])) {
                            hText += hint[text] + " ";
                        } else {
                            hText += remaining + " ";
                        }
                    }

                    hText.trim();

                    hintLabel.innerText = hText;
                    e.setAttribute("data-hint", hintLabel.innerText);
                }
            }
        }

    },
    /** End of: Characters remaining updateValue**/


    /** spinnerContainer **/

    SpinnerBodyDisplayDelay: function (body) {

        var timerCheck = body.getAttribute("data-timerValue");

        if (timerCheck == null || timerCheck == "") {

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                body.style.display = "";
                body.setAttribute("data-displayDelay", "false");

            }, 600);
            Timers.register(timerId);

            body.setAttribute("data-timerValue", timerId);
        } else {

            var timerId = setInterval(function () {
                Timers.clearOne(timerId);

                body.style.display = "";
                body.setAttribute("data-displayDelay", "false");

            }, 600);
            Timers.register(timerId);

            Timers.clearOne(timerCheck);
            body.setAttribute("data-timerValue", timerId);
        }
    },

    SpinnerUpdateInputValue: function (vertical, horizontal, element, noCallBack) {

        //Added so that the filter functionality is run for symbol updates as well
        var spinnerContainer = document.querySelector(".spinnerContainer");

        if (spinnerContainer == null || (vertical == null && spinnerContainer.vertical == null)) {
            return
        }

        if (vertical == null && spinnerContainer.vertical != null) {
            vertical = spinnerContainer.vertical;
            horizontal = spinnerContainer.horizontal;
            element = spinnerContainer.element;
            noCallBack = spinnerContainer.noCallBack;
        }
        //

        spinnerContainer = element.parentElement.parentElement;
        var displayQuery = ' .spinnerCard:not([style*="display:none"]):not([style*="display: none"])';
        var elements = element.querySelectorAll(displayQuery);

        var selectedSpinnerCard = elements[Math.round(vertical)];
        var hiddenInput = document.getElementById(element.getAttribute("data-hiddenInput"));
        hiddenInput.value = selectedSpinnerCard.parentElement.getAttribute("data-load") === "false" ? selectedSpinnerCard.parentElement.getAttribute("data-defaultValue") : selectedSpinnerCard.id;

        if (hiddenInput.value == '') {
            hiddenInput.value = elements[0].parentElement.children[0].id;
        }

        if (element.getAttribute("data-defaultValue") == '') {
            element.setAttribute("data-defaultValue", elements[0].parentElement.children[0].id);
        }

        selectedSpinnerCard.parentElement.setAttribute("data-value", hiddenInput.value);

        var leftSpinnerInstance, rightSpinnerInstance, currentSpinnerInstance;

        if (!noCallBack) {
            var leftSpinner = spinnerContainer.getElementsByClassName("leftSpinner")[0];
            var rightSpinner = spinnerContainer.getElementsByClassName("rightSpinner")[0];
            var spinnerBody = spinnerContainer.getElementsByClassName("spinnerBody")[0];

            spinnerContainer.vertical = vertical;
            spinnerContainer.horizontal = horizontal;
            spinnerContainer.element = element;
            spinnerContainer.noCallBack = noCallBack;

            leftSpinnerInstance = leftSpinner;
            rightSpinnerInstance = rightSpinner;

            if (leftSpinner != null && rightSpinner != null) {
                if (spinnerContainer.getAttribute("data-filterType") === "JOIN_KEY") {
                    var currentSpinner = element.parentElement;
                    currentSpinnerInstance = currentSpinner;
                    //Vincent - Join Key init fix
                    var joinKey = selectedSpinnerCard.getAttribute("data-joinKey");
                    if (selectedSpinnerCard.parentElement.getAttribute("data-load") === "false") {
                        var initCard = document.getElementById(hiddenInput.value);
                        if (initCard != null) {
                            joinKey = initCard.getAttribute("data-joinKey");
                        }
                        selectedSpinnerCard.parentElement.setAttribute("data-load", "true");
                    }
                    //----------------------------
                    if (currentSpinner.id === leftSpinner.id) {
                        MM.SpinnerJoinKeyFilter(joinKey, rightSpinner);
                    } else if (currentSpinner.id === rightSpinner.id) {
                        MM.SpinnerJoinKeyFilter(joinKey, leftSpinner);
                    }
                } else if (spinnerContainer.getAttribute("data-filterType") === "FILTER_OUT") {
                    var currentSpinner = element.parentElement;
                    currentSpinnerInstance = currentSpinner;
                    var filterOut = selectedSpinnerCard.getAttribute("data-filterOut");
                    filterOut = filterOut.split(',');
                    if (currentSpinner.id === leftSpinner.id) {
                        MM.SpinnerFilterOutFilter(filterOut, rightSpinner);
                    } else if (currentSpinner.id === rightSpinner.id) {
                        MM.SpinnerFilterOutFilter(filterOut, leftSpinner);
                    }
                }
            }

            var adjacentSpinnerFilter;

            if (currentSpinnerInstance !== undefined && leftSpinnerInstance !== undefined && rightSpinnerInstance !== undefined && (spinnerContainer.getAttribute("data-filterType") === "FILTER_OUT")) {

                if (currentSpinnerInstance.id === leftSpinnerInstance.id && rightSpinnerInstance.children[1].scroller !== undefined) {

                    var rightCardIndex = rightSpinnerInstance.children[1].scroller.getHoriVertical().vert;
                    var filteredSpinnerRight = rightSpinnerInstance.children[1].querySelectorAll(displayQuery)[Math.round(rightCardIndex)];
                    var hiddenRight = rightSpinnerInstance.children[0];
                    hiddenRight.value = filteredSpinnerRight.id;

                    var adjacentCard = rightSpinnerInstance.children[0].value;
                    var spinnerFilters = document.getElementById(adjacentCard).getAttribute("data-filterOut");
                    adjacentSpinnerFilter = spinnerFilters.split(',');
                } else if (currentSpinnerInstance.id === rightSpinnerInstance.id && leftSpinnerInstance.children[1].scroller !== undefined) {

                    var leftCardIndex = leftSpinnerInstance.children[1].scroller.getHoriVertical().vert;
                    var filteredSpinnerLeft = leftSpinnerInstance.children[1].querySelectorAll(displayQuery)[Math.round(leftCardIndex)];
                    var hiddenLeft = leftSpinnerInstance.children[0];
                    hiddenLeft.value = filteredSpinnerLeft.id;

                    var adjacentCard = leftSpinnerInstance.children[0].value;
                    var spinnerFilters = document.getElementById(adjacentCard).getAttribute("data-filterOut");
                    adjacentSpinnerFilter = spinnerFilters.split(',');
                }
            }

            var filterOutBody = selectedSpinnerCard.getAttribute("data-filterOut");
            filterOutBody = filterOutBody.split(',');

            if (adjacentSpinnerFilter != undefined) {
                filterOutBody = filterOutBody.concat(adjacentSpinnerFilter);
            }
            MM.SpinnerFilterOutBody(filterOutBody, spinnerBody);

            var spinnerCheck = selectedSpinnerCard.parentElement.parentElement;
            var spinnerCardCheck = selectedSpinnerCard.parentElement;

            if (spinnerCheck !== null && spinnerCheck.className === "rightSpinner" && spinnerCardCheck.getAttribute("data-load") === "false") {

                var leftSpinnerCheck = document.querySelector(".leftSpinner");
                var cardIndex = 0;


                if (leftSpinnerCheck !== null && spinnerCardCheck !== null && leftSpinnerCheck.children[0].getAttribute("value") === leftSpinnerCheck.children[1].getAttribute("data-defaultValue")) {

                    for (var rightSpinnerIndex = 0; rightSpinnerIndex < elements.length; rightSpinnerIndex++) {

                        if (spinnerCardCheck.getAttribute("data-defaultValue") === elements[rightSpinnerIndex].id) {
                            cardIndex = rightSpinnerIndex;
                            break;
                        }
                    }

                    spinnerCardCheck.setAttribute("data-indexing", "true");
                    spinnerCardCheck.setAttribute("data-index-y", "(" + cardIndex + " * (36 * Root.unit()))");
                    spinnerCardCheck.setAttribute("data-load", "true");
                }
            }
        }
    },

    SpinnerJoinKeyFilter: function (joinKey, filterSpinner) {
        var filterSpinnerCurrentCardId = (filterSpinner.querySelector('input')).value;
        if (filterSpinnerCurrentCardId !== "") {
            var filterSpinnerContent = filterSpinner.getElementsByClassName("spinnerContent")[0];
            var filterSpinnerCurrentCard = filterSpinnerContent.querySelector("[id='" + filterSpinnerCurrentCardId + "']");
            if (filterSpinnerCurrentCard.getAttribute("data-joinKey") === joinKey) {

                var cardLocation = null;

                for (spinnerCardCount = 0; spinnerCardCount < filterSpinnerContent.children.length; spinnerCardCount++) {
                    var spinnerCard = filterSpinnerContent.children[spinnerCardCount];
                    if (spinnerCard.id === filterSpinnerCurrentCardId) {
                        cardLocation = spinnerCardCount;
                        break;
                    }
                }

                if (filterSpinnerContent.scroller !== undefined) {
                    if (cardLocation === filterSpinnerContent.children.length || cardLocation > 0) {
                        var newPostion = (cardLocation - 1) * filterSpinner.clientHeight;
                        filterSpinnerContent.scroller.scrollTo(null, newPostion, false, null, true);
                    } else {
                        var newPostion = (cardLocation + 1) * filterSpinner.clientHeight;
                        filterSpinnerContent.scroller.scrollTo(null, newPostion, false, null, true);
                    }
                }

            }
        }
    },

    SpinnerFilterOutFilter: function (filterOut, filterSpinner) {
        var filterSpinnerContent = filterSpinner.getElementsByClassName("spinnerContent")[0];

        for (spinnerCardCount = 0; spinnerCardCount < filterSpinnerContent.children.length; spinnerCardCount++) {
            var spinnerCard = filterSpinnerContent.children[spinnerCardCount];
            spinnerCard.style.display = "";
        }

        for (spinnerCardCount = 0; spinnerCardCount < filterSpinnerContent.children.length; spinnerCardCount++) {
            var spinnerCard = filterSpinnerContent.children[spinnerCardCount];
            for (filterCount = 0; filterCount < filterOut.length; filterCount++) {
                var filter = filterOut[filterCount];
                if (spinnerCard.id === filter) {
                    spinnerCard.style.display = "none";
                }
            }
        }
    },

    SpinnerFilterOutBody: function (filterOut, Body) {
        for (elementCount = 0; elementCount < Body.children.length; elementCount++) {
            var element = Body.children[elementCount];
            element.style.display = "";
        }

        for (elementCount = 0; elementCount < Body.children.length; elementCount++) {
            var element = Body.children[elementCount];
            for (filterCount = 0; filterCount < filterOut.length; filterCount++) {
                var filter = filterOut[filterCount];
                if (element.id === filter) {
                    element.style.display = "none";
                }
            }
        }

        Root.setBodyContentsHeight();
    },

    /** END: spinnerContainer **/

    /** SortableGridContainer **/

    sortableGridContainerInit: function () {

        var sortableGridContainers = document.querySelectorAll('[data-dragableContainer="true"]');

        for (var sortContainerCount = 0; sortContainerCount < sortableGridContainers.length; sortContainerCount++) {
            var sortableGridContainer = sortableGridContainers[sortContainerCount];
            var bodyIconsContainer = sortableGridContainer.querySelector(".sortableContainerBodyIcons");
            var trayIconsContainer = sortableGridContainer.querySelector(".sortableContainerTrayBody");
            var baseBody = document.querySelector(".baseBody");
            var addIcon = bodyIconsContainer.lastElementChild;

            Sortable.create(bodyIconsContainer, {
                handle: '.sortableIconButtonContent',
                group: {
                    name: 'body',
                    put: ['tray']
                },
                ghostUseOpacity: true,
                animation: 130,
                delay: 300,
                filter: ".sortableContainerAddIcon",
                preventOnFilter: false,
                verticalScrollOffsetElement: baseBody,

                onChoose: function (/**Event*/evt) {
                    var sortableGridContainer = evt.target.parentElement.parentElement;
                    evt.item.children[0].children[1].children[0].classList.add("sortableIconButtonImgTraySelect");
                    evt.item.children[1].classList.add("sortableIconButtonTextTraySelect");
                    MM.sortableGridContainerToggleDragSortState(sortableGridContainer, true);
                    //  sortableGridContainer.querySelector('.sortableContainerAddIcon').setAttribute('style', 'display : none;');
                },
                onStart: function (evt) {
                    var iconsParent = evt.from;
                    for (var iconCount = 0; iconCount < iconsParent.children.length; iconCount++) {
                        var icon = iconsParent.children[iconCount];
                        Util.removeClass(icon, "shake");

                    }
                },
                onAdd: function (evt) {
                    evt.item.setAttribute("data-onclickLocation", "tray");
                    var sortableGridContainer = evt.target.parentElement.parentElement;
                    MM.sortableGridContainerToggleDragSortState(sortableGridContainer, true);

                },
                onEnd: function (evt) {
                    var iconsParent = evt.from;
                    for (var iconCount = 0; iconCount < iconsParent.children.length; iconCount++) {
                        var icon = iconsParent.children[iconCount];
                        Util.addClass(icon, "shake");
                    }
                },
                onChooseEnd: function (evt) {
                    evt.item.children[0].children[1].children[0].classList.remove("sortableIconButtonImgTraySelect");
                    evt.item.children[1].classList.remove("sortableIconButtonTextTraySelect");
                    sortableGridContainer.querySelector('.sortableContainerAddIcon').setAttribute('style', 'display : ;');


                    for (var childCount = 0; childCount < bodyIconsContainer.children.length; childCount++)
                        if (bodyIconsContainer.children[childCount].classList.contains('sortableContainerAddIcon')) {
                            bodyIconsContainer.removeChild(bodyIconsContainer.querySelector('.sortableContainerAddIcon'));
                            bodyIconsContainer.appendChild(addIcon);

                        }

                }
            });
            Sortable.create(trayIconsContainer, {
                handle: '.sortableIconButtonContent',
                group: 'tray',
                sort: false,
                ghostUseOpacity: false,
                animation: 130,
                delay: 250,

                onChoose: function (/**Event*/evt) {
                    evt.item.children[0].children[1].children[0].classList.add("sortableIconButtonImgTraySelect");
                    evt.item.children[1].classList.add("sortableIconButtonTextTraySelect");
                    bodyIconsContainer.lastElementChild.remove();
                },
                onStart: function (/**Event*/evt) {
                    var sortableGridContainer = evt.target.parentElement.parentElement;
                    MM.sortableGridContainerToggleTray(sortableGridContainer);
                },
                onChooseEnd: function (evt) {
                    evt.item.children[0].children[1].children[0].classList.remove("sortableIconButtonImgTraySelect");
                    evt.item.children[1].classList.remove("sortableIconButtonTextTraySelect");
                    bodyIconsContainer.appendChild(addIcon);
                }
            });
        }
    },

    sortableGridContainerToggleTray: function (sortableGridContainer) {
        var tray = sortableGridContainer.querySelector(".sortableContainerTray");
        Util.toggleClass(tray, "visible");

        var sortableContainerTrayCancel = document.querySelector(".sortableContainerTrayCancel");

        //add cancel arrow to header if its not already added
        var header = document.getElementById("headerFixed");
        if (header != null && header.querySelector(".sortableContainerTrayCancel") == null) {
            header.prepend(sortableContainerTrayCancel);
        }

        if (header != null)
            Util.toggleClass(sortableContainerTrayCancel, "visible");

    },

    sortableGridContainerToggleDragSortState: function (sortableGridContainer, state) {
        if (state) {
            var bodyIconsContainer = sortableGridContainer.querySelector(".sortableContainerBodyIcons");
            var icons = bodyIconsContainer.querySelectorAll('.sortableIconButtonContent');
            var editButtons = sortableGridContainer.querySelector('.sortableContainerBodyEdit');

            bodyIconsContainer.setAttribute('data-state', 'EDITING');
            for (var iconCount = 0; iconCount < icons.length; iconCount++) {
                var icon = icons[iconCount];
                var iconRemovable = icon.getAttribute("data-removable");
                var deleteBadge = icon.querySelector('.sortableIconButtonDeleteBadge');

                Util.addClass(icon, "shake");

                if (iconRemovable === 'Y')
                    Util.removeClass(deleteBadge, "visible");
            }
            Util.removeClass(editButtons, "visible");

        } else {
            var bodyIconsContainer = sortableGridContainer.querySelector(".sortableContainerBodyIcons");
            var icons = bodyIconsContainer.querySelectorAll('.sortableIconButtonContent');
            var editButtons = sortableGridContainer.querySelector('.sortableContainerBodyEdit');

            bodyIconsContainer.setAttribute('data-state', 'NONE');
            for (var iconCount = 0; iconCount < icons.length; iconCount++) {
                var icon = icons[iconCount];
                var deleteBadge = icon.querySelector('.sortableIconButtonDeleteBadge');
                Util.removeClass(icon, "shake");
                Util.addClass(deleteBadge, "visible");
                icon.setAttribute('data-state', 'NONE');
            }
            Util.addClass(editButtons, "visible");
            //Show Plus Badge?
        }
    },

    sortableGridContainerDone: function (sortableGridContainer) {

        MM.sortableGridContainerToggleDragSortState(sortableGridContainer, false);
        sortableGridContainer.querySelector('.sortableContainerAddIcon').setAttribute('style', '');

        var actionType = sortableGridContainer.getAttribute("data-type");

        var sortableGridContainerBody = document.querySelector('.sortableContainerBodyIcons');

        var inputInfo = (sortableGridContainerBody.parentElement.parentElement.querySelectorAll('input[type="hidden"]'))[0];

        var JSONObject = [];

        for (var childCount = 0; childCount < sortableGridContainerBody.children.length; childCount++) {
            var sortableGridContainerBodyChild = sortableGridContainerBody.children[childCount];
            sortableGridContainerBodyChild.setAttribute("order", childCount);
        }


        for (var childElement = 0; childElement < sortableGridContainerBody.children.length; childElement++) {

            var obj = {
                'key': sortableGridContainerBody.children[childElement].getAttribute("data-id"),
                'order': sortableGridContainerBody.children[childElement].getAttribute("order")

            }
            if (!(sortableGridContainerBody.children[childElement].classList.contains('sortableContainerAddIcon')))
                JSONObject.push(obj);
        }

        inputInfo.value = JSON.stringify(JSONObject);

        if (actionType === 'UPDATE') {
            var el = document.getElementById(sortableGridContainer.getAttribute('id'));
            MM.partialUpdate(el);
        } else if (actionType === 'SUBMIT') {
            Form.submit(sortableGridContainer.getAttribute('data-url'));
        } else if (actionType === 'NAVIGATE') {
            Form.navigate(sortableGridContainer.getAttribute('data-url'));
        }

    },

    sortableGridContainerMoveTo: function (sortableGridContainer, element) {
        var bodyIconsContainer = sortableGridContainer.querySelector(".sortableContainerBodyIcons");
        var trayIconsContainer = sortableGridContainer.querySelector(".sortableContainerTrayBody");
        var location = element.getAttribute("data-onclickLocation");
        var iconRemovable = element.getAttribute("data-removable");

        if (location === 'tray') {
            if (iconRemovable === 'Y') {
                element.setAttribute("data-onclickLocation", "body");
                Util.removeClass(element, "shake");
                bodyIconsContainer.removeChild(element);

                var tempTrayIconsContainer = trayIconsContainer;
                var selectedElementOrder = element.getAttribute("data-trayOrder");

                for (i = 0; i < trayIconsContainer.children.length; i++) {
                    var trayOrder = trayIconsContainer.children[i].getAttribute("data-trayOrder");
                    if (parseInt(selectedElementOrder) <= parseInt(trayOrder)) {
                        tempTrayIconsContainer.insertBefore(element, tempTrayIconsContainer.children[i]);
                        break;
                    } else if (parseInt(selectedElementOrder) >= parseInt(trayIconsContainer.children[trayIconsContainer.children.length - 1].getAttribute("data-trayOrder"))) {
                        tempTrayIconsContainer.children[trayIconsContainer.children.length - 1].insertAdjacentElement('afterEnd', element);
                        break;
                    } else if (selectedElementOrder === "" || selectedElementOrder === null) {
                        tempTrayIconsContainer.children[trayIconsContainer.children.length - 1].insertAdjacentElement('afterEnd', element);
                        break;
                    }
                }

                trayIconsContainer = tempTrayIconsContainer;
            }

        } else if (location === 'body') {
            element.setAttribute("data-onclickLocation", "tray");
            if (bodyIconsContainer.getAttribute('data-state') === 'EDITING') {
                //sortableGridContainer.querySelector('.sortableContainerAddIcon').setAttribute('style', 'display : none;');
                var deleteBadge = element.querySelector('.sortableIconButtonDeleteBadge');
                Util.removeClass(deleteBadge, "visible");
                Util.addClass(element, "shake");
            } else {
                var deleteBadge = element.querySelector('.sortableIconButtonDeleteBadge');
                Util.addClass(deleteBadge, "visible");
                Util.removeClass(element, "shake");
            }

            trayIconsContainer.removeChild(element);
            var addIcon = bodyIconsContainer.lastElementChild;
            bodyIconsContainer.lastElementChild.remove();

            bodyIconsContainer.appendChild(element);
            bodyIconsContainer.appendChild(addIcon);


            MM.sortableGridContainerToggleTray(sortableGridContainer);
            MM.sortableGridContainerToggleDragSortState(sortableGridContainer, true);
        }
    },

    sortableGridContainerButtonActionIosFix: function (event, button, actionType) {

        //Check if user scrolled or clicked

        var moved = false;
        var initialEvent = event;

        var pointerUp = function () {
            if (moved == false) {
                MM.sortableGridContainerButtonAction(button, actionType);
            }

            //remove listeners
            button.removeEventListener("pointerup", pointerUp);
            button.removeEventListener("pointermove", pointerMove);
        };

        //Even without position change pointerMove is still called. So check X Y of touches to make sure
        var pointerMove = function (e) {
            if (initialEvent.clientX != e.clientX && initialEvent.clientY != e.clientY) {
                moved = true;
            }
        };

        button.addEventListener("pointerup", pointerUp);
        button.addEventListener("pointermove", pointerMove);

        return false;
    },

    sortableGridContainerButtonAction: function (button, actionType) {

        if (button.parentElement.getAttribute('data-state') === 'TRAY') {
            MM.sortableGridContainerMoveTo(button.parentElement.parentElement.parentElement, button);
        } else if (button.parentElement.getAttribute('data-state') === 'EDITING') {
            MM.sortableGridContainerMoveTo(button.parentElement.parentElement.parentElement.parentElement, button);
        } else {
            if (actionType === 'UPDATE') {
                var el = document.getElementById(button.getAttribute('data-updateKey'));
                MM.partialUpdate(el);
            } else if (actionType === 'SUBMIT') {
                Form.submit(button.getAttribute('data-url'));
            } else if (actionType === 'NAVIGATE') {
                Form.navigate(button.getAttribute('data-url'));
            }
        }
    },

    /** END: SortableGridContainer**/



    /** initialize lineGraph **/
    initMMLineGraph: function () {

        var lineGraph = document.querySelectorAll('[data-linegraph-container="true"]');

        if (lineGraph.length > 0) {

            lineGraph.forEach(function selectStartTab(element) {
                var subElements = element;
                subElements.setAttribute("data-linegraph-container", "false");

                var chartblock = element.querySelector(".LINE_GRAPH");
                var style = getComputedStyle(chartblock);
                var w = document.getElementById("base-content").clientWidth;
                var h = style.getPropertyValue('height').match(/\d+/)[0];

                var margin = {top: 50, right: 0, bottom: 40, left: 50, canvasLeft: 10, canvasRight: 10, bottomAxis: 20},
                    canvasHeight = h,
                    width = w - (margin.left / 2),
                    height = h - margin.top - margin.bottom;

                //Save svg element height for redraw
                chartblock.parentElement.loadedHeight = canvasHeight;

                MM._createMMLineGraph(canvasHeight, width, margin, chartblock);
            });

        }
    },

    /** End of: initialize lineGraph**/

    /** MM GraphLine **/

    reDrawMMLineGraph: function () {

        var lineGraph = document.querySelectorAll(".lineGraph");

        if (lineGraph.length > 0) {

            lineGraph.forEach(function selectStartTab(element) {

                var subElements = element;
                subElements.setAttribute("data-linegraph-container", "false");

                var chartblock = element.querySelector(".LINE_GRAPH");

                if (chartblock.parentElement != null) {

                    var h = chartblock.parentElement.loadedHeight;
                    var w = document.getElementById("base-content").clientWidth;
                    var margin = {
                            top: 50,
                            right: 0,
                            bottom: 40,
                            left: 50,
                            canvasLeft: 10,
                            canvasRight: 10,
                            bottomAxis: 20
                        },
                        canvasHeight = h,
                        width = w - (margin.left / 2);

                    //Remove current svg then add svg at beginning state and redraw
                    chartblock.innerHTML = "";

                    MM._createMMLineGraph(canvasHeight, width, margin, chartblock);

                }

            });

        }

    },

    _createMMLineGraph: function (canvasHeight, width, margin, chartblock) {

        var chartData = JSON.parse(chartblock.getAttribute("data-object"));
        var AxisWidth = width - (margin.left / 2);
        var graphHeight = parseFloat(parseFloat(canvasHeight) + parseFloat(margin.top + margin.bottom));

        var setItem = "true";

        var x = d3.scale.linear()
            .range([0, AxisWidth]);

        var y = d3.scale.linear()
            .range([canvasHeight, 0]);

        var color = d3.scale.category10();

        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

        var line = d3.svg.line()
            .x(function (d) {
                return xRange(parseFloat(d.x));
            })
            .y(function (d) {
                return yRange(parseFloat(d.y));
            });

        var svg = d3.select(chartblock)
            .attr("height", parseFloat(graphHeight - margin.bottom))
            .attr("width", parseFloat(width + (margin.left / 2)))
            .append("g")
            .attr("transform", "translate(" + (margin.left / 2.2) + "," + margin.top + ")");

        var charts = chartData.charts;

        /* Set data for X Axis */
        var wml = parseFloat(AxisWidth - (margin.left / 4));
        var x = d3.scale.ordinal().rangeRoundBands([0, (wml)], 0),
            xRange = d3.scale.linear().range([0, wml]).domain([d3.min(chartData.Labels.xLabels.data, function (d) {
                return 0;
            }),
                d3.max(chartData.Labels.xLabels.data, function (d) {
                    return parseFloat(wml);
                })
            ]),

            xAxis = d3.svg.axis().scale(x).orient("bottom");
        x.domain(chartData.Labels.xLabels.label);
        svg.append("g")
            .attr("class", "xAxis")
            .attr("transform", "translate(" + margin.canvasRight + "," + canvasHeight + ")")
            .call(xAxis)
            .select("path")
            .style("display", "none");

        //custom x-Axis label positioning
        for (var v = 0; v < chartData.Labels.xLabels.data.length; v++) {

            var xVal = parseFloat(parseFloat(parseFloat(chartData.Labels.xLabels.data[v].x / 100) * (AxisWidth - margin.left)));

            if (xVal + 55 >= document.getElementById("LINE_GRAPH").width.baseVal.value) {
                xVal = document.getElementById("LINE_GRAPH").width.baseVal.value;
            }

            svg.append("text")
                .attr("class", "customAxis")
                .attr("x", xVal)
                .attr("y", parseFloat(parseFloat(canvasHeight) + parseFloat(margin.bottomAxis)))
                .text(chartData.Labels.xLabels.data[v].text)
                .style({"fill": "#9B9B9B", "cursor": "normal"})
                .attr({"font-weight": "bold"})
                .attr({"font-size": "13px"});
        }

        svg.select(".xAxis")
            .selectAll(".tick")
            .style("fill", "#9B9B9B");

        svg.select(".xAxis")
            .selectAll(".tick text")
            .call(Overview.d3TextWrap, x.rangeBand());

        /*Set data for Y Axis */
        y = d3.scale.ordinal().rangeRoundBands([canvasHeight, 0], 0),
            yRange = d3.scale.linear().range([canvasHeight, 0]).domain([d3.min(chartData.Labels.yLabels.data, function (d) {
                return 0;
            }),
                d3.max(chartData.Labels.yLabels.data, function (d) {
                    return 100;
                })
            ]),

            yAxis = d3.svg.axis().scale(y).orient("left");
        y.domain(chartData.Labels.yLabels.label);
        svg.append("g")
            .attr("class", "yAxis")
            .call(yAxis)
            .select("path")
            .style("display", "none");

        svg.select(".yAxis")
            .selectAll(".tick")
            .style("fill", "#9B9B9B")
            .attr("display", "none");

        //custom Y-Axis label positioning
        for (var v = 0; v < chartData.Labels.yLabels.data.length; v++) {

            //var yVal =  parseFloat(parseFloat(parseFloat(chartData.Labels.yLabels.data[v].y / 100) * (canvasHeight)));
            var yVal = parseFloat(canvasHeight * parseFloat((parseFloat(100 - chartData.Labels.yLabels.data[v].y) / 100)) - 2);

            svg.append("text")
                .attr("class", "customY-Axis")
                .attr("y", parseFloat(yVal))
                .attr("x", 0)
                .text(chartData.Labels.yLabels.data[v].text)
                .style({"fill": "#9B9B9B", "cursor": "normal"})
                .attr({"font-weight": "bold"})
                .attr({"font-size": "13px"});
        }

        /**Horizontal axis**/
        svg.append("svg:line")
            .attr("class", "horizontal-grid-lines")
            .attr("x1", 0)
            .attr("y1", (canvasHeight))
            .attr("x2", xRange(AxisWidth))
            .attr("y2", (canvasHeight))
            .style("stroke", chartData.DottedLine.color)
            .style("stroke-width", 1);

        /*Appending xGridLines*/
        for (var i = 0; i < chartData.xGridLines.Data.length; i++) {

            var yVal = parseFloat(canvasHeight * parseFloat((parseFloat(100 - chartData.xGridLines.Data[i].position) / 100)));
            svg.append("svg:line")
                .attr("class", "horizontal-grid-lines")
                .attr("x1", 0)
                .attr("y1", yVal)
                .attr("x2", AxisWidth)
                .attr("y2", yVal)
                .style("stroke", chartData.xGridLines.Data[i].colour)
                .style("stroke-width", 1)
        }

        /**vertical axis **/
        svg.append("svg:line")
            .attr("class", "vertical-grid-lines")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", canvasHeight)
            .style("stroke", chartData.DottedLine.color)
            .style("stroke-width", 1);

        /*Appending yGridLines */
        for (i = 0; i < chartData.yGridLines.Data.length; i++) {

            svg.append("svg:line")
                .attr("class", "vertical-grid-lines")
                .attr("x1", parseFloat(parseFloat(chartData.yGridLines.Data[i].position) / 100) * width)
                .attr("y1", 0)
                .attr("x2", parseFloat(parseFloat(chartData.yGridLines.Data[i].position) / 100) * width)
                .attr("y2", canvasHeight)
                .style("stroke", chartData.yGridLines.Data[i].colour)
                .style("stroke-width", 1)
        }

        /**Filling graph area and Drawing line.**/
        var dataSet = [];

        var xDomain, yAxisRange, rangeValue;

        for (var n = 0; n < chartData.Charts.length; n++) {

            //filling LineGraph

            if (setItem == "true") {


                for (var j = 0; j <= 10; j++) {
                    dataSet.push({
                        x: j * 10,
                        y: j * 10
                    });

                }

                var xVals = dataSet.map(function (obj) {
                    return obj.x;
                });

                var yVals = dataSet.map(function (obj) {
                    return obj.y;
                });

                xDomain = Math.max.apply(null, xVals);

                yAxisRange = Math.max.apply(null, yVals);

                xDomain = parseFloat(parseFloat(AxisWidth) * parseFloat(xDomain / 100));

                rangeValue = parseFloat(parseFloat(canvasHeight) * parseFloat(yAxisRange / 100));

                var x = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.x;
                    })])
                    .range([0, xDomain]);

                var y = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.y;
                    })])
                    .range([rangeValue, 0]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left");

                var valueline = d3.svg.line()
                    .x(function (d) {
                        return x(d.x);
                    })
                    .y(function (d) {
                        return y(d.y);
                    });

                var area = d3.svg.area()
                    .x(function (d) {
                        return x(parseFloat(d.x));
                    })
                    .y0(rangeValue)
                    .y1(function (d) {
                        return y(parseFloat(d.y));
                    });

                var svg = d3.select(chartblock)
                    .attr("AxisWidth", AxisWidth)
                    .attr("height", parseFloat(graphHeight))
                    .append("g")
                    .attr("transform", "translate(" + (margin.left / 2.2) + "," + parseFloat(parseFloat(graphHeight - margin.bottom) - parseFloat(rangeValue)) + ")");

                //Draw graphfill line here!

                svg.append("path")
                    .attr("class", "baseLine")
                    .attr("d", valueline(dataSet))
                    .attr("stroke", chartData.Charts[n].color)
                    .attr("stroke-AxisWidth", 2)
                    .attr("fill", "none")
                    .attr("display", "none");


                svg.append("path")
                    .datum(dataSet)
                    .attr("class", "BaseArea")
                    .attr("d", area)
                    .attr("fill", "#FFFFFF")
                    .attr("stroke-AxisWidth", 0)
                    .attr("opacity", 0.0);

                dataSet = [];

                setItem = false;
            }


            if (chartData.Charts[n].fillgraph == "Y") {
                for (var j = 0; j < (chartData.Charts[n].Data.length); j++) {
                    dataSet.push({
                        x: parseFloat(chartData.Charts[n].Data[j].x),
                        y: parseFloat(chartData.Charts[n].Data[j].y)
                    });

                }

                var xVals = dataSet.map(function (obj) {
                    return obj.x;
                });

                var yVals = dataSet.map(function (obj) {
                    return obj.y;
                });

                xDomain = Math.max.apply(null, xVals);

                yAxisRange = Math.max.apply(null, yVals);


                xDomain = parseFloat(parseFloat(AxisWidth) * parseFloat(xDomain / 100));

                rangeValue = parseFloat(parseFloat(canvasHeight) * parseFloat(yAxisRange / 100));

                var x = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.x;
                    })])
                    .range([0, xDomain]);

                var y = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.y;
                    })])
                    .range([rangeValue, 0]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left");


                var valueline = d3.svg.line()
                    .x(function (d) {
                        return x(d.x);
                    })
                    .y(function (d) {
                        return y(d.y);
                    });

                var area = d3.svg.area()
                    .x(function (d) {
                        return x(parseFloat(d.x));
                    })
                    .y0(rangeValue)
                    .y1(function (d) {
                        return y(parseFloat(d.y));
                    });

                var svg = d3.select(chartblock)
                    .attr("AxisWidth", AxisWidth)
                    .attr("height", parseFloat(graphHeight))
                    .append("g")
                    .attr("transform", "translate(" + (margin.left / 2.2) + "," + parseFloat(parseFloat(graphHeight - margin.bottom) - parseFloat(rangeValue)) + ")");

                svg.append("path")
                    .datum(dataSet)
                    .attr("class", "area")
                    .attr("d", area)
                    .attr("fill", chartData.Charts[n].color)
                    .attr("stroke-AxisWidth", 0)
                    .attr("opacity", 0.35);

                //Draw graphfill line here!

                if (chartData.Charts[n].style == "SOLID" && chartData.Charts[n].fillgraph == "Y") {
                    svg.append("path")
                        .attr("class", "solidLine")
                        .attr("d", valueline(dataSet))
                        .attr("stroke", chartData.Charts[n].color)
                        .attr("stroke-AxisWidth", 2)
                        .attr("fill", "none");

                }
                if (chartData.Charts[n].style == "DOTTED" && chartData.Charts[n].fillgraph == "Y") {
                    svg.append("path")
                        .attr("class", "dottedLine")
                        .attr("d", valueline(dataSet))
                        .attr("stroke", chartData.Charts[n].color)
                        .style("stroke-dasharray", ("3, 3"))
                        .attr("fill", "none")
                        .attr("stroke-AxisWidth", 2);
                }

                //adding dots on line
                if (chartData.Charts[n].boldPoints == "Y") {

                    for (var s = 0; s < dataSet.length; s++) {
                        svg.selectAll("dot")
                            .data(dataSet)
                            .enter().append("circle")
                            .attr("r", 1.0)
                            .attr("cx", function (d) {
                                return x(parseFloat(dataSet[s].x));
                            })
                            .attr("cy", function (d) {
                                return y(parseFloat(dataSet[s].y));
                            });
                    }
                }

                dataSet = [];

            }

            if (chartData.Charts[n].fillgraph == "N") {
                for (var j = 0; j < chartData.Charts[n].Data.length; j++) {
                    dataSet.push({
                        x: parseFloat(chartData.Charts[n].Data[j].x),
                        y: parseFloat(chartData.Charts[n].Data[j].y)
                    });

                }

                var xVals = dataSet.map(function (obj) {
                    return obj.x;
                });

                var yVals = dataSet.map(function (obj) {
                    return obj.y;
                });

                xDomain = Math.max.apply(null, xVals);

                yAxisRange = Math.max.apply(null, yVals);


                xDomain = parseFloat(parseFloat(AxisWidth) * parseFloat(xDomain / 100));

                rangeValue = parseFloat(parseFloat(canvasHeight) * parseFloat(yAxisRange / 100));

                var x = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.x;
                    })])
                    .range([0, xDomain]);

                var y = d3.scale.linear()
                    .domain([0, d3.max(dataSet, function (d) {
                        return d.y;
                    })])
                    .range([rangeValue, 0]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left");


                var valueline = d3.svg.line()
                    .x(function (d) {
                        return x(d.x);
                    })
                    .y(function (d) {
                        return y(d.y);
                    });

                var svg = d3.select(chartblock)
                    .attr("AxisWidth", AxisWidth)
                    .attr("height", parseFloat(graphHeight))
                    .append("g")
                    .attr("transform", "translate(" + (margin.left / 2.2) + "," + parseFloat(parseFloat(graphHeight - margin.bottom) - parseFloat(rangeValue)) + ")");

                //Draw graphfill line here!

                if (chartData.Charts[n].style == "SOLID" && chartData.Charts[n].fillgraph == "N") {
                    svg.append("path")
                        .attr("class", "solidLine")
                        .attr("d", valueline(dataSet))
                        .attr("stroke", chartData.Charts[n].color)
                        .attr("stroke-AxisWidth", 2)
                        .attr("fill", "none");

                }
                if (chartData.Charts[n].style == "DOTTED" && chartData.Charts[n].fillgraph == "N") {
                    svg.append("path")
                        .attr("class", "dottedLine")
                        .attr("d", valueline(dataSet))
                        .attr("stroke", chartData.Charts[n].color)
                        .style("stroke-dasharray", ("3, 3"))
                        .attr("stroke-AxisWidth", 2)
                        .attr("fill", "none");
                }


                //adding dots on line
                if (chartData.Charts[n].boldPoints == "Y") {

                    for (var s = 0; s < dataSet.length; s++) {
                        svg.selectAll("dot")
                            .data(dataSet)
                            .enter().append("circle")
                            .attr("r", 3.0)
                            .attr("cx", function (d) {
                                return x(parseFloat(dataSet[s].x));
                            })
                            .attr("cy", function (d) {
                                return y(parseFloat(dataSet[s].y));
                            });
                    }
                }


                dataSet = [];

            }

        }

        /* Appending graphBubble */
        var textWidth;
        var bubbleTriangleXCord;
        var bubbleTextXCord;
        var canvasYHeight = graphHeight - margin.top - margin.bottom - margin.bottomAxis;


        for (var n = 0; n < chartData.graphBubbles.Data.length; n++) {

            textWidth = ((chartData.graphBubbles.Data[n].text.length + 2) * 7);

            bubbleTriangleXCord = ((chartData.graphBubbles.Data[n].text.length + 2) * 8) / 2;

            svg.append("svg:rect")
                .attr("class", "graphBubble")
                .attr("id", "graphBubbleSpace." + n)
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("fill", chartData.graphBubbles.Data[n].backgroundColor)
                .attr('transform', 'translate(' + (parseFloat(parseFloat(parseFloat(chartData.graphBubbles.Data[n].x) / 100) * (width)) - (textWidth / 2)) + ',' + parseFloat(canvasYHeight * parseFloat((parseFloat(100 - chartData.graphBubbles.Data[n].y) / 100))) + ')');
            bubbleTextXCord = (parseFloat(parseFloat(parseFloat(chartData.graphBubbles.Data[n].x) / 100) * (AxisWidth)) - (textWidth / 3.2));
            var rectblock = document.getElementById('graphBubbleSpace.' + n);
            var style = getComputedStyle(rectblock);
            var bubbleHeight = style.getPropertyValue('height').match(/\d+/)[0];

            rectblock.setAttribute('transform', 'translate(' + (parseFloat(parseFloat(parseFloat(chartData.graphBubbles.Data[n].x) / 100) * (AxisWidth)) - (textWidth / 2.4)) + ',' + parseFloat(canvasYHeight * parseFloat((parseFloat(100 - chartData.graphBubbles.Data[n].y) / 100)) - parseFloat(bubbleHeight)) + ')');

            var textYcord = parseFloat(canvasYHeight * parseFloat((parseFloat(100 - chartData.graphBubbles.Data[n].y) / 100)) - 2);

            /*Appending triangle-down*/

            var arc = d3.svg.symbol().type('triangle-down')
                .size(function (d) {
                    return scale(d);
                });

            textWidth = (((chartData.graphBubbles.Data[n].text.length)));
            //set unit size
            var data = [bubbleHeight * 10];

            var scale = d3.scale.linear()
                .domain([0, AxisWidth])
                .range([0, canvasYHeight]);

            var group = svg.append('g')
                .attr("class", "bubbleArrow")
                .attr('transform', 'translate(' + (parseFloat(parseFloat(parseFloat(chartData.graphBubbles.Data[n].x) / 100) * (AxisWidth - (textWidth / 3)))) + ',' + parseFloat(canvasYHeight * parseFloat((parseFloat(100 - chartData.graphBubbles.Data[n].y) / 100))) + ')');

            var line1 = group.selectAll('path')
                .data(data)
                .enter()
                .append('path')
                .attr('d', arc)
                .attr('fill', chartData.graphBubbles.Data[n].backgroundColor);

            var textBubble = svg.append("text")
                .attr("class", "graphBubbleText graphBubbleText" + n)
                .attr("id", "graphBubbleTextId" + n)
                .text(chartData.graphBubbles.Data[n].text)
                .style({"fill": chartData.graphBubbles.Data[n].textColor, "cursor": "normal"})
                .attr({"font-weight": "bold"})
                .attr('transform', 'translate(' + bubbleTextXCord + ',' + textYcord + ')');

            var computedtextWidth = document.getElementById('graphBubbleTextId' + n).getComputedTextLength();

            document.getElementById("graphBubbleSpace." + n).setAttribute("width", (computedtextWidth + parseInt(computedtextWidth / textWidth)));

        }


    },

    /** End of: MM GraphLine**/

    /** Donut Graph**/
    donutGraph: function () {
        var donut = document.querySelectorAll('[data-donut-container="true"]');
        var rootUnit;
        var screenUnit = "--unit";

        //For Universal Form Factor
        if (window.matchMedia("(min-width: 500px)").matches) {
            rootUnit = Root._maxUnit;// 6.3;
            screenUnit = "--maxUnitBase";
        } else {
            rootUnit = (Root.unit());
        }

        if (donut.length > 0) {

            var subElements = donut[0];
            subElements.setAttribute("data-donut-container", "false");

            var graph = subElements.getAttribute("data-donut-graph");
            graph = JSON.parse(graph);
            var total = 0;
            var greyArea;
            var dataset = [];

            for (i = 0; i < graph.subElements.lineRange.length; i++) {
                //Get colour from our scss variables
                graph.subElements.lineRange[i].colour = getComputedStyle(document.documentElement).getPropertyValue("--" + graph.subElements.lineRange[i].colour);

                total = total + (graph.subElements.lineRange[i].end - graph.subElements.lineRange[i].start);
                dataset.push({
                    colour: graph.subElements.lineRange[i].colour,
                    percent: graph.subElements.lineRange[i].end - graph.subElements.lineRange[i].start
                });
            }

            if (total < 100) {
                greyArea = 100 - total;
                dataset.push({colour: '#E0E0E0', percent: greyArea});
            }

            var pie = d3.layout.pie()
                .value(function (d) {
                    return d.percent
                })
                .sort(null)
                .padAngle(.0)

            //Width and height of SVG and radius of donut
            var w = rootUnit * 50, h = rootUnit * 50, r = rootUnit * 18;
            var outerRadius = r;
            var innerRadius = rootUnit * 15.6;
            var shadowWidth = rootUnit * 1;
            var outerRadiusArcShadow = innerRadius + 1;
            var innerRadiusArcShadow = innerRadius - shadowWidth;

            var arc = d3.svg.arc()
                .outerRadius(outerRadius)
                .innerRadius(innerRadius)

            var outerArc = d3.svg.arc()
                .innerRadius(r * (rootUnit * 0.18))
                .outerRadius(r * (rootUnit * 0.18));

            var svg = d3.select("#donutGraph")
                .append("svg")
                .attr({
                    width: w,
                    height: h,
                    class: 'shadow'
                }).append('g')
                .attr({
                    transform: 'translate(' + w / 2 + ',' + h / 2 + ')'
                });

            svg.append("g")
                .attr("class", "line");

            var path = svg.selectAll('path')
                .data(pie(dataset))
                .enter()
                .append('path')
                .attr({
                    d: arc,
                    fill: function (d, i) {
                        return d.data.colour;
                    }
                });

            /*CREATE INNER WHITE CIRCLE*/
            var createChart = function (svg, outerRadius, innerRadius, fillFunction, className) {
                var innerDataset = [];
                innerDataset.push({colour: '#FFFFFF', percent: 100});
                var arc = d3.svg.arc()
                    .innerRadius(outerRadius)
                    .outerRadius(innerRadius);

                var path = svg.selectAll('.' + className)
                    .data(pie(innerDataset))
                    .enter()
                    .append('path')
                    .style("fill", "#FFFFFF")

                path.transition()
                    .duration(1000)
                    .attrTween('d', function (d) {
                        var interpolate = d3.interpolate({startAngle: 0, endAngle: 0}, d);
                        return function (t) {
                            return arc(interpolate(t));
                        };
                    });

                var chart = {path: path, arc: arc};

                return chart;
            };

            var shadowChart = createChart(svg, outerRadiusArcShadow, innerRadiusArcShadow, function (d, i) {
                var c = d3.hsl(color(d.data.colour))

                return d3.hsl((c.h + 5), (c.s - .07), (c.l - .15));
            }, 'path2');

            path.transition()
                .duration(1000)
                .attrTween('d', function (d) {
                    var interpolate = d3.interpolate({startAngle: 0, endAngle: 0}, d);
                    return function (t) {
                        return arc(interpolate(t));
                    };
                });

            //Add percentages based on notchWithLabel attribute
            var percentageDisplay = function () {
                var percentageDataset = [];
                var percentageText = [];

                //Sets counter to avoid getting index out of bounds if dataset lenghts are not the same.
                if (graph.subElements.lineRange.length - graph.subElements.notchWithLabel.length > 0) {
                    var p = graph.subElements.notchWithLabel.length - graph.subElements.lineRange.length;
                } else if (graph.subElements.lineRange.length - graph.subElements.notchWithLabel.length < 0) {
                    var p = graph.subElements.lineRange.length - graph.subElements.notchWithLabel.length;
                } else {
                    var p = -1;
                }

                var notchIndex = percentageDataset.length - 1;
                var notchColourIndex = percentageDataset.length;
                var total = 0;

                //Adds data to calculate arc area for location of text
                for (j = 0; j < graph.subElements.notchWithLabel.length; j++) {
                    if (j === 0) {
                        percentageDataset.push({
                            colour: graph.subElements.notchWithLabel[0].colour,
                            percent: graph.subElements.notchWithLabel[0].position
                        });
                        total = total + (graph.subElements.notchWithLabel[j].position * 1);
                    } else if (graph.subElements.notchWithLabel.length === (j + 1)) {
                        percentageDataset.push({
                            colour: graph.subElements.notchWithLabel[j].colour,
                            percent: (graph.subElements.notchWithLabel[j].position - graph.subElements.notchWithLabel[j - 1].position)
                        });
                        total = total + (graph.subElements.notchWithLabel[j].position - graph.subElements.notchWithLabel[j - 1].position);
                    } else {
                        percentageDataset.push({
                            colour: graph.subElements.notchWithLabel[j].colour,
                            percent: (graph.subElements.notchWithLabel[j].position - graph.subElements.notchWithLabel[j - 1].position)
                        });
                        total = total + (graph.subElements.notchWithLabel[j].position - graph.subElements.notchWithLabel[j - 1].position);
                    }
                }

                //Adds label so that percentage shows out 100 and not just perecentage of arc
                for (j = 0; j < graph.subElements.notchWithLabel.length; j++) {
                    if (j === 0) {
                        percentageText.push({
                            colour: graph.subElements.notchWithLabel[0].colour,
                            percent: graph.subElements.notchWithLabel[0].position
                        });
                    } else if (graph.subElements.notchWithLabel.length === (j + 1)) {
                        percentageText.push({
                            colour: graph.subElements.notchWithLabel[j].colour,
                            percent: graph.subElements.notchWithLabel[j].position
                        });
                    } else {
                        percentageText.push({
                            colour: graph.subElements.notchWithLabel[j].colour,
                            percent: graph.subElements.notchWithLabel[j].position
                        });
                    }
                }

                //Calculates unallocaed space and sets colour to transparent to avoid displaying the percentage
                if (total < 100) {
                    greyArea = 100 - total;
                    percentageDataset.push({colour: 'transparent', percent: greyArea});
                    percentageText.push({colour: 'transparent', percent: greyArea});
                }

                var text = svg.selectAll('text')
                    .data(pie(percentageDataset))
                    .enter()
                    .append("text")
                    .transition()
                    .duration(200)
                    .attr("dy", rootUnit * 0.8)
                    .attr("dx", ".0em")
                    .attr("transform", function (d) {
                        //radius of the text
                        var radius = rootUnit * 19;
                        return "translate(" +
                            ((radius + 4) * Math.sin((((d.endAngle + 0.15) - d.startAngle)) + d.startAngle)) +
                            ", " +
                            (-1 * (radius + 8) * Math.cos(((d.endAngle - d.startAngle)) + d.startAngle)) +
                            ")";
                    })

                    //specify which side of arc must text display
                    .attr("text-anchor", function (d) {
                        var rads = ((d.endAngle - d.startAngle) / 2) + d.startAngle;
                        if ((rads > 7 * Math.PI / 4 && rads < Math.PI / 4) || (rads > 3 * Math.PI / 4 && rads < 5 * Math.PI / 4)) {
                            return "end";
                        } else if (rads >= Math.PI / 4 && rads <= 3 * Math.PI / 4) {
                            return "start";
                        } else if (rads >= 5 * Math.PI / 4 && rads <= 7 * Math.PI / 4) {
                            return "end";
                        } else if (rads > 5 * Math.PI / 4) {
                            return "end";
                        } else {
                            return "middle";
                        }
                    })
                    //make text transparent if not specified in xml
                    .text(function (d) {
                        p++;
                        if (p >= 0) {
                            if (percentageDataset[p].colour != 'transparent') {
                                return percentageText[p].percent + "%";
                            }
                        }
                    })
                    .style({
                        fill: '#000',
                        'font-size': 'calc(3 * var(--' + screenUnit + '));'
                    })

                var notch = svg.selectAll('line')
                    .data(pie(percentageDataset))
                    .enter()
                    .append("line")
                    .attr("stroke", percentageDataset[notchColourIndex].colour)
                    .attr("y1", innerRadius)
                    .attr("y2", outerRadius + 5)
                    .attr("transform", function (d) {
                        notchIndex++;
                        notchColourIndex++;
                        if (percentageDataset[notchIndex].colour != 'transparent') {
                            return "rotate(" + (d.endAngle + Math.PI) * (180 / Math.PI) + ")"
                        }
                    });
            };

            setTimeout(percentageDisplay, 1000);
        }
    },

    /** End of: Donut Graph**/

    /**Check for saved password **/
    copyValueOnFocus: function (e) {

        var passwordInput = "";
        var hiddenInput = ""
        if (document.getElementById("id_field").value != null) {
            hiddenInput = document.getElementById("id_field").value;
        }
        passwordInput = document.getElementById("showInput").value;

        wrongValue = e.getAttribute("data-wrongValue").valueOf();
        e.setAttribute("data-inputValue", document.getElementById("showInput").value);
        if (wrongValue.length > 0 && passwordInput.length > 0) {
            document.getElementById("id_field").value = wrongValue;
            document.getElementById("showInput").value = random_password();
        } else if (passwordInput.length > 0 && hiddenInput.length === 0) {
            document.getElementById("id_field").value = passwordInput;
        }

        function random_password() {
            var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return chars.substr(Math.floor(Math.random() * 62), wrongValue.length);
        }
    },

    savedValueCheck: function (e) {

        var passwordValue = document.getElementById("showInput").value;
        var hiddenInput = ""
        if (document.getElementById("id_field").value != null) {
            hiddenInput = document.getElementById("id_field").value;
        }
        var inputCounter = e.getAttribute("data-counter").valueOf();
        var dataInputValue = e.getAttribute("data-inputValue").valueOf();

        if (passwordValue.length < e.getAttribute("data-inputValue").valueOf().length) {
            if (inputCounter > 0) {
                inputCounter = ((inputCounter * 1) - (1));
                if (passwordValue.length === 0) {
                    inputCounter = 0;
                }
                e.setAttribute("data-counter", inputCounter);
                document.getElementById("dataCounter").value = inputCounter;
            }

            if (document.getElementById("id_field").value.length > 0) {
                hiddenInput = hiddenInput.substring(0, hiddenInput.length - 1);
                document.getElementById("id_field").value = hiddenInput;
            }
        } else if (hiddenInput.length > e.getAttribute("data-inputValue").valueOf().length) {
            document.getElementById("id_field").value = e.getAttribute("data-wrongValue").valueOf();
            document.getElementById("showInput").value = random_password();
            e.setAttribute("data-inputValue", document.getElementById("showInput").value);


        } else {
            hiddenInput = hiddenInput + passwordValue.substring(passwordValue.length - 1, passwordValue.length);
            document.getElementById("id_field").value = hiddenInput;
            passwordValue = passwordValue.substring(0, passwordValue.length - 1);
            passwordValue = passwordValue + random_character();
            document.getElementById("showInput").value = passwordValue;
            inputCounter = ((inputCounter * 1) + (1));
            e.setAttribute("data-counter", inputCounter);
            document.getElementById("dataCounter").value = inputCounter;
        }

        e.setAttribute("data-inputValue", document.getElementById("showInput").value);

        if (passwordValue.length === 0) {
            document.getElementById("id_field").value = "";
        }

        function random_password() {
            var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return chars.substr(Math.floor(Math.random() * 62), wrongValue.length);
        }

        function random_character() {
            var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            return chars.substr(Math.floor(Math.random() * 62), 1);
        }
    },
    /*End of Check for saved password*/

    /*Copy to clipboard*/
    copyToClipboard: function (text) {
        var input = document.body.appendChild(document.createElement("input"));
        input.value = text;
        input.focus();
        input.select();
        document.execCommand('copy');
        input.parentNode.removeChild(input);
    },
    /*End of Copy to clipboard*/

    passwordPopup: function () {
        var popup = document.getElementById("passwordPopup");
        var popupBackdrop = document.getElementById("passwordPopUpBackdrop");
        popup.style.visibility = "visible";
        popupBackdrop.style.visibility = "visible";

    },
    closePasswordPopup: function () {
        var popup = document.getElementById("passwordPopup");
        var popupBackdrop = document.getElementById("passwordPopUpBackdrop");
        popup.style.visibility = "hidden";
        popupBackdrop.style.visibility = "hidden";
    },

    /*AccordionWithPill*/

    accordionSinglePillList: function (el) {
        var key = el.getAttribute("data-key");
        var keyElement = document.getElementById("hidden_" + key);

        if (keyElement.value == "EXPANDED") {
            keyElement.value = "COLLAPSED";
            el.style.transform = "rotate(135deg)";
        } else {
            keyElement.value = "EXPANDED";
            el.style.transform = "rotate(-45deg)";
        }
        keyElement.id = key;
        MM.partialUpdate(keyElement, true);
        keyElement.id = "hidden_" + key;

    },

    accordionDualPillList: function (el) {
        var key = el.getAttribute("data-key");
        var keyElement = document.getElementById("hidden_" + key);

        if (keyElement.value == "EXPANDED") {
            keyElement.value = "COLLAPSED";
            el.style.transform = "rotate(135deg)";
        } else {
            keyElement.value = "EXPANDED";
            el.style.transform = "rotate(-45deg)";
        }
        keyElement.id = key;
        MM.partialUpdate(keyElement, true);
        keyElement.id = "hidden_" + key;

    },

    /*AccordionWithPill*/

    /*Virtual Card*/
    setVirtualCard: function () {

        var Card = document.getElementById("Card");

        if (Card == null) {
            return;
        }

        //Decrypt card values
        var cardElement = document.querySelector(".cardNumber");
        var cardVal = cardElement.innerHTML;
        cardElement.innerHTML = SecurityTools.privateKeyDecryption(window.atob(cardVal.substring(2, cardVal.length - 1)));

        cardElement = document.querySelector(".expiryDate");
        cardVal = cardElement.innerHTML;
        cardElement.innerHTML = SecurityTools.privateKeyDecryption(window.atob(cardVal.substring(2, cardVal.length - 1)));

        cardElement = document.querySelector(".backCvv");
        cardVal = cardElement.innerHTML;
        cardElement.innerHTML = (SecurityTools.privateKeyDecryption(window.atob(cardVal.substring(2, cardVal.length - 1))));
        cardElement.innerHTML = (cardElement.innerHTML).substring(3, cardElement.innerHTML.length); //Removing CVV text as CVV text and number have different styling

        //deactivate flip
        if (Card.getAttribute("data-canFlip") == "N") {
            return;
        }

        Card.CurrentPos = 0;
        Card.To = 0;
        Card.FrontBack = 0;
        Card.ClickType = 0;

        var cardBack = document.querySelector(".CardBack");

        setTimeout(function ()//give images time to load in before animation
        {
            MM.flipCard();
            setTimeout(function () {
                MM.flipCard();
            }, 1000);
        }, 1000);

    },

    flipCard: function () {
        var Card = document.getElementById("Card");
        // var Shine = document.querySelector(".Shine");

        //deactivate flip
        if (Card.getAttribute("data-canFlip") == "N") {
            return;
        }

        //Check if user flipping card or trying to copy
        var copyFlip = Card.getAttribute("data-Copy");
        if (copyFlip == "true") {
            Card.setAttribute("data-Copy", "false");
            return;
        }

        var CardStyle = document.querySelector(".CardStyle");
        Card.style.pointerEvents = "none";//disable click

        if (Card.ClickType == 0)//result of normal click
        {
            if (Card.FrontBack == 0) {
                Card.FrontBack = 1;
            } else {
                Card.FrontBack = 0;
            }
            if ((Card.CurrentPos >= 0 && Card.CurrentPos <= 90) || (Card.CurrentPos >= 270 && Card.CurrentPos <= 360)
                || (Card.CurrentPos <= 0 && Card.CurrentPos >= -90) || (Card.CurrentPos <= -270 && Card.CurrentPos >= -360)) {
                Card.To = 180; //Flip to front of card
            } else {
                Card.To = 0; //Flip to Back of card
            }
        }

        Card.style.animationName = "";
        if (Card.FrontBack == 0) {
            CardStyle.innerHTML = "@keyframes FlipForward\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    transform: rotateY(" + Card.CurrentPos + "deg);\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    transform: rotateY(" + Card.To + "deg);\n" +
                "  }\n" +
                "\n" +
                "}";
            Card.style.animationName = "FlipForward";
            Card.style.animationDuration = "1.00s";
            Card.style.animationFillMode = "forwards";
        } else {
            CardStyle.innerHTML = "@keyframes FlipBack\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    transform: rotateY(" + Card.CurrentPos + "deg);\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    transform: rotateY(" + Card.To + "deg);\n" +
                "  }\n" +
                "\n" +
                "}";
            Card.style.animationName = "FlipBack";
            Card.style.animationDuration = "1.00s";
            Card.style.animationFillMode = "forwards";
        }
        Card.CurrentPos = Card.To;
        setTimeout(function () {
            Card.style.pointerEvents = "auto";//enable click
        }, 500);
    },

    copyCardInfo: function (copyString) {

        //Decrypt
        if (copyString.charAt(0) == "#") {
            copyString = SecurityTools.privateKeyDecryption(window.atob(copyString.substring(2, copyString.length - 1)));
        }

        var Card = document.getElementById("Card");

        var input = document.createElement('input');
        Card.setAttribute("data-Copy", "true");
        Card.appendChild(input);

        if (parseInt(copyString)) {//Is a number
            input.value = copyString.replace(/\s+/g, "");//Remove spaces
        } else {//Is a name
            input.value = copyString;
        }

        //Select the text
        input.focus();
        input.select();

        //Copy to clipboard
        var successful = document.execCommand('copy');
        input.style.visibility = "hidden";

        if (successful != false) {

            var Copied = document.createElement('div');
            Copied.innerHTML = "Copied";
            Copied.style.height = "calc(5 * var(--unit))";
            Copied.style.width = "calc(12 * var(--unit))";
            Copied.style.backgroundColor = "black";
            Copied.style.color = "white";
            Copied.style.borderRadius = "calc(5 * var(--unit)) calc(5 * var(--unit)) calc(5 * var(--unit)) calc(5 * var(--unit)) ";
            Copied.style.paddingLeft = "calc(1 * var(--unit))";
            Copied.style.paddingTop = "calc(1 * var(--unit))";
            Copied.style.position = "absolute";
            Copied.style.left = "calc(8 * var(--unit))";
            Card.appendChild(Copied);
            setTimeout(function () {
                Card.removeChild(Copied);
            }, 400);

        }
        Card.removeChild(input);
    },
    /*End of Virtual Card*/

    /*Bar Graph*/
    setBarGraph: function () {
        var graph = document.getElementById("graph");

        if (graph === null || graph.getAttribute("data-alreadyLoaded") == "true") {
            return;
        }

        //get active col id from hidden div
        var hiddenDiv = document.getElementById("hidden");
        var col = document.getElementById(hiddenDiv.attributes.activeColID.value);

        if (col.children.length === 2) {
            hiddenDiv.setAttribute("activeColID", col.firstElementChild.id);
            col = document.getElementById(col.firstElementChild.id);
        }

        //move active col to center on load
        MM.move('', '1s', 'clicked', col.parentElement);

        //swipe action
        var barGraphArea = document.querySelector(".barGraphArea");
        barGraphArea.ontouchstart = function (event) {
            var x = event.touches[0].clientX;

            barGraphArea.ontouchmove = function (e) {
                var xMoved = e.touches[0].clientX;

                var diffX = x - xMoved;

                if (Math.abs(diffX) > 70) {
                    x = xMoved;
                    if (diffX < 0) {
                        //animation duration of 0 seconds does not work on safari
                        MM.move("right", "0.00000000000000000000000000000001s", "swipe");
                    } else if (diffX > 0) {
                        MM.move("left", "0.00000000000000000000000000000001s", "swipe");
                    }
                }
            }//ontouchmove

            barGraphArea.ontouchend = function (event) {

                //checking if the user just clicked on a bar or swiped
                var xEnd = event.changedTouches[0].clientX;
                if (Math.abs(x - xEnd) > 5) {
                    var hiddenDiv = document.getElementById("hidden");
                    var newActiveColID = hiddenDiv.attributes.activeColID.value;
                    var newCol = document.getElementById(newActiveColID).parentElement;

                    /* partial update goes here*/
                    var graph = newCol.parentElement.parentElement.parentElement.parentElement;
                    MM.partialUpdateSubElementKey(graph, newCol.id, false);
                }
            }//ontouchend
        }//ontouchstart

        graph.setAttribute("data-alreadyLoaded", "true");
    },
    move: function (direction, animationDuration, action, col) {

        var graph = document.getElementById("graph");
        var currentStr = window.getComputedStyle(graph).right;

        //get active col id from hidden div
        var hiddenDiv = document.getElementById("hidden");
        var newActiveColID = parseInt(hiddenDiv.attributes.activeColID.value);

        //to get the center of screen from hidden div
        var hiddenDivStr = window.getComputedStyle(hiddenDiv).right;
        var centerVal = parseInt(hiddenDivStr.substring(0, hiddenDivStr.length - 2));

        if (direction === "left") {
            newActiveColID += 1;
        } else if (direction === "right") {
            newActiveColID -= 1;
        } else {
            newActiveColID = col.firstElementChild.id;
        }

        newValue = (centerVal + ((parseInt(newActiveColID)) * +(7 * Root._unit))) + "px";

        //get new active column
        var newCol = document.getElementById(newActiveColID).parentElement;
        var newColIsNull = (newCol === null);

        if (newColIsNull) {
            newCol = document.getElementById(hiddenDiv.attributes.activeColID.value).parentElement;
        }

        //newColor stores the text color of the new active column
        var newColor = newCol.children[1].attributes.color.value;

        //oldColor stores the text color of the old active column
        var oldCol = document.getElementById(hiddenDiv.attributes.activeColID.value).parentElement;
        var oldColor = oldCol.children[1].attributes.color.value;

        //animation to move left and right
        var animationStyle = document.querySelector(".barGraphAnimationStyle");
        animationStyle.innerHTML = "@keyframes mymove {\n" +
            "  from {right: " + currentStr + ";}\n" +
            "  to {right: " + newValue + ";}\n" +
            "}\n\n" + "@keyframes mymove1 {\n" +
            "  from {right: " + currentStr + ";}\n" +
            "  to {right: " + newValue + ";}\n" +
            "}\n" +
            "@keyframes addGreyDot{\n" +
            "  from {background-color:white; color:" + "var--" + newColor + ");}\n" +
            "  to {background-color:#9A9A9A; color:white;}\n" +
            "}\n\n" + "@keyframes removeGreyDot {\n" +
            "  from {background-color:#9A9A9A; color:white;}\n" +
            "  to {background-color:white; color:" + "var(--" + oldColor + ");}";

        if (graph.style.animationName === "mymove") {
            graph.style.animationName = "mymove1";
        } else {
            graph.style.animationName = "";
            graph.style.animationName = "mymove";
        }
        graph.style.animationDuration = animationDuration;
        graph.style.animationFillMode = "forwards";

        //check if theres a next column and if not then move first or last column to the center
        if (newColIsNull === false) {
            if (action === "swipe") {
                //animation duration of 0 seconds does not work on safari
                MM.animateActiveDot(newCol, '0.00000000000000000000000000000001s');
            } else {
                MM.animateActiveDot(newCol, '1.25s');
            }
            if (action === 'ArrowClicked' || action === 'clicked') {
                /* partial update goes here*/
                var graph = newCol.parentElement.parentElement.parentElement.parentElement;
                MM.partialUpdateSubElementKey(graph, newCol.id, false);
            }
        } else {
            MM.move("", "1.25s", "", newCol);
        }
    },//move
    animateActiveDot: function (newCol, animationDuration) {

        //change text above graph
        var dateValue = document.querySelector(".barGraphDateValue");
        dateValue.innerHTML = newCol.children[0].attributes.toptext.value;

        var amount = document.querySelector(".barGraphAmount");
        amount.innerHTML = newCol.children[0].attributes.middletext.value;

        var additionalText = document.querySelector(".barGraphAdditionalText");
        additionalText.innerHTML = newCol.children[0].attributes.bottomtext.value;

        //remove grey dot from old active col
        var hiddenDiv = document.getElementById("hidden");
        var oldActiveCol = document.getElementById(hiddenDiv.attributes.activeColID.value).parentElement;
        var oldActiveMnth = oldActiveCol.children[1];

        oldActiveMnth.style.animationName = "removeGreyDot";
        oldActiveMnth.style.animationDuration = animationDuration;
        oldActiveMnth.style.animationFillMode = "forwards";
        oldActiveMnth.style.animationName = "";

        //animate grey dot
        var newActiveMnth = newCol.children[1];
        newActiveMnth.style.animationName = "addGreyDot";
        newActiveMnth.style.animationDuration = animationDuration;
        newActiveMnth.style.animationFillMode = "forwards";

        //set active col id in hidden div
        var colID = newCol.firstElementChild.id;
        hiddenDiv.setAttribute("activeColID", colID);

    },//animateActiveDot

    /*End of Bar graph*/

    /*Calendar*/

    setMeetingCalendar: function (leftRight) {

        //Check if calendar screen
        var topDate = document.querySelector(".topDate");
        var calenderContainer = document.querySelector(".calenderContainer");

        if (topDate == null || calenderContainer == null) {
            return;
        }

        //Month & Year
        var months = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        var calenderDays = document.querySelector(".calenderDays");
        var date;
        var currentEpoch = calenderContainer.getAttribute("data-date");

        date = new Date(parseInt(currentEpoch));

        var monthMover = parseInt(calenderContainer.getAttribute("data-monthMover"));
        var currentMonth = date.getMonth();
        var currentYear = date.getFullYear();

        //Done in this way so as to keep track of more than one year
        var movingMonth = new Date(date.getFullYear(), date.getMonth() + monthMover, 1).getMonth();//returns 0-11
        var year = new Date(date.getFullYear(), date.getMonth() + monthMover, 1).getFullYear();

        var numberOfDaysForPrevMonth = new Date(year, movingMonth, 0).getDate();
        var numberOfDaysForMovingMonth = new Date(year, movingMonth + 1, 0).getDate();//returns 1-31 (month also starts from 1 here)
        var numberOfDaysForNextMonth = new Date(year, movingMonth + 2, 0).getDate();

        var prevMonth = "";
        var nextMonth = "";

        //UFF
        var unit = Root.determineVariableUnitNeeded();

        if ((movingMonth - 1) == -1) {
            prevMonth = months[11];
        } else {
            prevMonth = months[movingMonth - 1];
        }

        if ((movingMonth + 1) == 12) {
            nextMonth = months[0];
        } else {
            nextMonth = months[movingMonth + 1];
        }

        var todaysDayOfMonth = date.getDate();
        var dropDownArrow = document.querySelector(".bottomCalenderDropDown");

        //Week View
        if (dropDownArrow.getAttribute("data-CollapseExpand") === "Expand") {

            var isPublicHolidays = document.querySelectorAll(".isPublicHoliday");

            //Reset public holiday styling as different divs need to be styled based on week view or month view
            isPublicHolidays.forEach(function (value) {
                value.classList.remove("isPublicHoliday");
            });

            MM.weekView(calenderContainer, numberOfDaysForPrevMonth, prevMonth, numberOfDaysForMovingMonth, months[movingMonth]
                , numberOfDaysForNextMonth, nextMonth, movingMonth, year, leftRight, currentEpoch);

            MM.calendarDeselectHighlightedDay(calenderContainer);

            //Set public holidays
            MM.setPublicHolidays();
            return;
        }

        //Month View
        //Days
        var currentDayOfTheWeek = "";

        var sundayCounter = 0;
        var sundayCollection = MM.getCalendarDayCssClasses("sunday");
        var sundayEventCollection = MM.getCalendarEventCssClasses("sunday");

        var mondayCounter = 0;
        var mondayCollection = MM.getCalendarDayCssClasses("monday");
        var mondayEventCollection = MM.getCalendarEventCssClasses("monday");

        var tuesdayCounter = 0;
        var tuesdayCollection = MM.getCalendarDayCssClasses("tuesday");
        var tuesdayEventCollection = MM.getCalendarEventCssClasses("tuesday");

        var wednesdayCounter = 0;
        var wednesdayCollection = MM.getCalendarDayCssClasses("wednesday");
        var wednesdayEventCollection = MM.getCalendarEventCssClasses("wednesday");

        var thursdayCounter = 0;
        var thursdayCollection = MM.getCalendarDayCssClasses("thursday");
        var thursdayEventCollection = MM.getCalendarEventCssClasses("thursday");

        var fridayCounter = 0;
        var fridayCollection = MM.getCalendarDayCssClasses("friday");
        var fridayEventCollection = MM.getCalendarEventCssClasses("friday");

        var saturdayCounter = 0;
        var saturdayCollection = MM.getCalendarDayCssClasses("saturday");
        var saturdayEventCollection = MM.getCalendarEventCssClasses("saturday");

        var dayRow6 = document.querySelectorAll(".dayRow6");
        var calenderStyle = document.getElementById("CalenderStyle");

        //Clear calendar
        var rows = 5;
        for (var i = 0; i < rows; i++) {
            sundayCollection[i].innerText = "";
            mondayCollection[i].innerText = "";
            tuesdayCollection[i].innerText = "";
            wednesdayCollection[i].innerText = "";
            thursdayCollection[i].innerText = "";
            fridayCollection[i].innerText = "";
            saturdayCollection[i].innerText = "";

            sundayEventCollection[i].style.display = "none";
            mondayEventCollection[i].style.display = "none";
            tuesdayEventCollection[i].style.display = "none";
            wednesdayEventCollection[i].style.display = "none";
            thursdayEventCollection[i].style.display = "none";
            fridayEventCollection[i].style.display = "none";
            saturdayEventCollection[i].style.display = "none";

            //reset day colors
            mondayCollection[i].style.color = "var(--INK)";
            tuesdayCollection[i].style.color = "var(--INK)";
            wednesdayCollection[i].style.color = "var(--INK)";
            thursdayCollection[i].style.color = "var(--INK)";
            fridayCollection[i].style.color = "var(--INK)";

            mondayCollection[i].setAttribute("data-partOfMonth", "");
            tuesdayCollection[i].setAttribute("data-partOfMonth", "");
            wednesdayCollection[i].setAttribute("data-partOfMonth", "");
            thursdayCollection[i].setAttribute("data-partOfMonth", "");
            fridayCollection[i].setAttribute("data-partOfMonth", "");
        }

        var elementName = "";
        var eventTracker = [];
        var inactiveColor = calenderContainer.getAttribute("data-inactiveDayColour");

        var week = 7;
        var lastRow = saturdayCollection.length;
        var firstRow = 0;

        topDate.innerText = months[movingMonth] + " " + year;

        //Displaying days start at 1
        for (var i = 1; i < numberOfDaysForMovingMonth + 1; i++) {
            currentDayOfTheWeek = new Date(year, movingMonth, i).getDay();

            //Checking if month needs 5 or 6 rows to display properly (Check if first day is on a friday or saturday and the number of days for the month)
            if (i == 1) {
                if ((currentDayOfTheWeek == 5 && numberOfDaysForMovingMonth > 30) || (currentDayOfTheWeek == 6 && numberOfDaysForMovingMonth > 29)) {
                    calenderDays.style.height = "calc(56 * var(" + unit + "))";
                    calenderContainer.setAttribute("data-calendarHeight", "calc(55 * var(" + unit + "))");
                    calenderContainer.setAttribute("data-6Rows", "true");
                    calenderStyle.innerHTML = "";

                    for (var iLoop = 0; iLoop < dayRow6.length; iLoop++) {
                        dayRow6[iLoop].style.display = "grid";
                        dayRow6[iLoop].parentElement.style.gridTemplateRows = "repeat(7, calc(7 * " + unit + "px))";
                    }

                    lastRow = lastRow - 1;
                } else {
                    calenderDays.style.height = "calc(49 * var(" + unit + "))";
                    calenderContainer.setAttribute("data-calendarHeight", "calc(48 * var(" + unit + "))");
                    calenderContainer.setAttribute("data-6Rows", "false");
                    calenderStyle.innerHTML = "";

                    for (var iLoop = 0; iLoop < dayRow6.length; iLoop++) {
                        dayRow6[iLoop].style.display = "none";
                        dayRow6[iLoop].parentElement.style.gridTemplateRows = "repeat(6, calc(7 * " + unit + "px))";
                    }

                    lastRow = lastRow - 2;
                }
            }

            elementName = MM.getElementNameDayAndMonth(i, (movingMonth + 1), year);

            switch (currentDayOfTheWeek) {
                case 0://Sunday
                    sundayCollection[sundayCounter].innerText = i;
                    sundayCollection[sundayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);//Keeps track of which month the user clicked on

                    if (sundayCollection[sundayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {//Highlight todays day
                        MM.calenderHighlightDaySetUp(sundayCollection[sundayCounter]);
                        calenderContainer.selectedDay = sundayCollection[sundayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, sundayEventCollection[sundayCounter], eventTracker, sundayCollection[sundayCounter]);
                    sundayCounter++;
                    break;
                case 1://Monday
                    mondayCollection[mondayCounter].innerText = i;
                    mondayCollection[mondayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    if (mondayCollection[mondayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(mondayCollection[mondayCounter]);
                        calenderContainer.selectedDay = mondayCollection[mondayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, mondayEventCollection[mondayCounter], eventTracker, mondayCollection[mondayCounter]);
                    mondayCounter++;
                    break;
                case 2://Tuesday
                    tuesdayCollection[tuesdayCounter].innerText = i;
                    tuesdayCollection[tuesdayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    if (tuesdayCollection[tuesdayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(tuesdayCollection[tuesdayCounter]);
                        calenderContainer.selectedDay = tuesdayCollection[tuesdayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, tuesdayEventCollection[tuesdayCounter], eventTracker, tuesdayCollection[tuesdayCounter]);
                    tuesdayCounter++;
                    break;
                case 3://Wednesday
                    wednesdayCollection[wednesdayCounter].innerText = i;
                    wednesdayCollection[wednesdayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    if (wednesdayCollection[wednesdayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(wednesdayCollection[wednesdayCounter]);
                        calenderContainer.selectedDay = wednesdayCollection[wednesdayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, wednesdayEventCollection[wednesdayCounter], eventTracker, wednesdayCollection[wednesdayCounter]);
                    wednesdayCounter++;
                    break;
                case 4://Thursday
                    thursdayCollection[thursdayCounter].innerText = i;
                    thursdayCollection[thursdayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, thursdayEventCollection[thursdayCounter], eventTracker, thursdayCollection[thursdayCounter]);

                    if (thursdayCollection[thursdayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(thursdayCollection[thursdayCounter]);
                        calenderContainer.selectedDay = thursdayCollection[thursdayCounter];
                    }

                    thursdayCounter++;
                    break;
                case 5://Friday
                    fridayCollection[fridayCounter].innerText = i;
                    fridayCollection[fridayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    if (fridayCollection[fridayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(fridayCollection[fridayCounter]);
                        calenderContainer.selectedDay = fridayCollection[fridayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, fridayEventCollection[fridayCounter], eventTracker, fridayCollection[fridayCounter]);
                    fridayCounter++;
                    break;
                case 6://Saturday
                    saturdayCollection[saturdayCounter].innerText = i;
                    saturdayCollection[saturdayCounter].setAttribute("data-weekViewMonthTracker", months[movingMonth] + " " + year);

                    if (saturdayCollection[saturdayCounter].innerText == todaysDayOfMonth && currentMonth === movingMonth && currentYear === year) {
                        MM.calenderHighlightDaySetUp(saturdayCollection[saturdayCounter]);
                        calenderContainer.selectedDay = saturdayCollection[saturdayCounter];
                    }

                    //Display event indicator
                    MM.CheckifEventMonth(elementName, saturdayEventCollection[saturdayCounter], eventTracker, saturdayCollection[saturdayCounter]);
                    saturdayCounter++;

                    //Make sure days go to right rows (saturday last day in row)
                    if (sundayCounter < saturdayCounter) {
                        sundayCollection[sundayCounter].innerText = "";
                        sundayCounter++;
                    }

                    if (mondayCounter < saturdayCounter) {
                        mondayCollection[mondayCounter].innerText = "";
                        mondayCounter++;
                    }

                    if (tuesdayCounter < saturdayCounter) {
                        tuesdayCollection[tuesdayCounter].innerText = "";
                        tuesdayCounter++;
                    }

                    if (wednesdayCounter < saturdayCounter) {
                        wednesdayCollection[wednesdayCounter].innerText = "";
                        wednesdayCounter++;
                    }

                    if (thursdayCounter < saturdayCounter) {
                        thursdayCollection[thursdayCounter].innerText = "";
                        thursdayCounter++;
                    }

                    if (fridayCounter < saturdayCounter) {
                        fridayCollection[fridayCounter].innerText = "";
                        fridayCounter++;
                    }
                    break;
            }
        }

        //Display days of previous month only applies to row one (position 0 in collection)
        for (var iLoop = 0; iLoop < week; iLoop++) {
            elementName = MM.getElementNameMonth(numberOfDaysForPrevMonth, movingMonth, year);

            if (saturdayCollection[firstRow].innerText === "") {//Saturday
                MM.setCalenderNextMonthDays(saturdayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (fridayCollection[firstRow].innerText === "") {//Friday
                MM.setCalenderNextMonthDays(fridayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (thursdayCollection[firstRow].innerText === "") {//Thrusday
                MM.setCalenderNextMonthDays(thursdayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (wednesdayCollection[firstRow].innerText === "") {//Wednesday
                MM.setCalenderNextMonthDays(wednesdayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (tuesdayCollection[firstRow].innerText === "") {//Tuesday
                MM.setCalenderNextMonthDays(tuesdayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (mondayCollection[firstRow].innerText === "") {//Monday
                MM.setCalenderNextMonthDays(mondayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            } else if (sundayCollection[firstRow].innerText === "") {//Sunday
                MM.setCalenderNextMonthDays(sundayCollection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker);
            }

            numberOfDaysForPrevMonth--;
        }

        //Display days of next month only applies to row five or six (position length in collection)
        for (var iLoop = 0; iLoop < week; iLoop++) {
            elementName = MM.getElementNameDayAndMonth(iLoop + 1, (movingMonth + 2), year);

            if (sundayCollection[lastRow].innerText === "") {//Sunday
                MM.setCalenderPreviousMonthDays(sundayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (mondayCollection[lastRow].innerText === "") {//Monday
                MM.setCalenderPreviousMonthDays(mondayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (tuesdayCollection[lastRow].innerText === "") {//Tuesday
                MM.setCalenderPreviousMonthDays(tuesdayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (wednesdayCollection[lastRow].innerText === "") {//Wednesday
                MM.setCalenderPreviousMonthDays(wednesdayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (thursdayCollection[lastRow].innerText === "") {//Thrusday
                MM.setCalenderPreviousMonthDays(thursdayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (fridayCollection[lastRow].innerText === "") {//Friday
                MM.setCalenderPreviousMonthDays(fridayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            } else if (saturdayCollection[lastRow].innerText === "") {//Saturday
                MM.setCalenderPreviousMonthDays(saturdayCollection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker);
            }
        }

        //Event array to keep track of which elements have events for display purposes
        calenderContainer.eventTracker = eventTracker;

        //Set up animation
        var dropDownArrowContainer = document.querySelector(".bottomCalenderDropDownContainer");

        dropDownArrowContainer.onpointerdown = function (ev) {
            var y = ev.clientY;

            dropDownArrowContainer.onpointermove = function (eve) {
                var yM = eve.clientY;
                if ((yM < y))//Swiped up
                {
                    if (dropDownArrow.getAttribute("data-CollapseExpand") != "Expand") {//User can't collapse while view already collapsed
                        if ((y - yM) > "5")/*&& (yM - y) < "40")*/ {
                            MM.calenderCollapseExpand("Collapse");
                            dropDownArrow.setAttribute("data-CollapseExpand", "Expand");
                        }
                    }

                } else {//swiped down

                    if (dropDownArrow.getAttribute("data-CollapseExpand") != "Collapse") {//User can't expand while view already expanded
                        if ((yM - y) > "5")/*&& (yM - y) < "40")*/ {
                            MM.calenderCollapseExpand("Expand");
                            dropDownArrow.setAttribute("data-CollapseExpand", "Collapse");
                        }
                    }

                }
            }
        };

        //Set public holidays
        MM.setPublicHolidays();

        //Calender Meetings
        MM.setCalenderMeetingsHeight();
        MM.displayMeetingsForSelectedDay(todaysDayOfMonth, movingMonth + 1, year);

    },

    setCalenderMeetingsHeight: function () {
        var calenderMeetings = document.querySelector(".calenderMeetings");

        if(calenderMeetings == null){
            return;
        }

        //Set height of calender meetings element dynamically for scrolling purposes
        var footer = document.getElementById("footer");
        var footerHeight = 0;
        if(footer != null){
            var footerHeight = document.getElementById("footer").offsetHeight;
        }

        var headerHeight = document.getElementById("headerFixed").offsetHeight;

        var calenderDateHeight = document.querySelector(".calenderDate").offsetHeight;
        var calenderDaysHeight = document.querySelector(".calenderDays").offsetHeight;

        var totalHeightOfSurroundingElements = headerHeight + footerHeight + calenderDateHeight + calenderDaysHeight;

        var leftOverHeight = (window.innerHeight - totalHeightOfSurroundingElements) - parseFloat(window.getComputedStyle(calenderMeetings).paddingTop);

        if(leftOverHeight != null && leftOverHeight <= 0){
            calenderMeetings.style.height = "fit-content";
        }else{
            calenderMeetings.style.height = leftOverHeight + "px";
        }
    },

    setPublicHolidays: function () {
        var publicHolidays = document.querySelectorAll(".publicHolidayDiv");

        publicHolidays.forEach(function (value) {

            var start = value.getAttribute("data-start");
            var end = value.getAttribute("data-end");

            var date = new Date(parseInt(start));
            var day = date.getDate();
            var dayOfTheWeek = date.getDay();
            var month = date.getMonth() + 1; //Months start at 0
            var year = date.getFullYear();

            var dateEnd = new Date(parseInt(end));
            var dayEnd = dateEnd.getDate();
            var monthEnd = dateEnd.getMonth() + 1; //Months start at 0
            var yearEnd = dateEnd.getFullYear();

            if (day == dayEnd) {//Starts and ends on same day

                MM.checkPublicHolidayDayOfWeek(dayOfTheWeek, day, date, value);

            } else {//Spans multiple days

                var iLoopStart = day;
                var iLoopEnd = dayEnd;
                var movingDate;
                var movingDayOfTheWeek;
                var newMonthDay = 0;
                var newMonth = false;
                var end = false;

                //Passing 0 for day gets last day of previous month hence the +1 month
                var lastDayOfMonth = new Date(year, month, 0).getDate();

                if (month == monthEnd) {

                    for (var iLoop = iLoopStart; iLoop <= iLoopEnd; iLoop++) {
                        if (newMonth == false) {
                            movingDate = new Date(year + "-" + month + "-" + iLoop);
                            movingDayOfTheWeek = movingDate.getDay();
                            MM.checkPublicHolidayDayOfWeek(movingDayOfTheWeek, iLoop, movingDate, value);
                        } else if ((newMonth == true) && (year == yearEnd)) { //Moved into new month
                            newMonthDay++;
                            movingDate = new Date(year + "-" + monthEnd + "-" + newMonthDay);
                            movingDayOfTheWeek = movingDate.getDay();
                            MM.checkPublicHolidayDayOfWeek(movingDayOfTheWeek, newMonthDay, movingDate, value);
                        } else if ((newMonth == true) && (year != yearEnd)) {//Moved into new year and new month
                            newMonthDay++;
                            movingDate = new Date(yearEnd + "-" + monthEnd + "-" + newMonthDay);
                            movingDayOfTheWeek = movingDate.getDay();
                            MM.checkPublicHolidayDayOfWeek(movingDayOfTheWeek, newMonthDay, movingDate, value);
                        }
                    }

                } else {
                    while (end != true) {

                        if (newMonth == true && (day == dayEnd)) {
                            end = true;
                        }

                        if (newMonth == false) {
                            movingDate = new Date(year + "-" + month + "-" + day);
                        } else if ((newMonth == true) && (year == yearEnd)) { //Moved into new month
                            movingDate = new Date(year + "-" + monthEnd + "-" + day);
                        } else if ((newMonth == true) && (year != yearEnd)) {//Moved into new year and new month
                            movingDate = new Date(yearEnd + "-" + monthEnd + "-" + day);
                        }

                        movingDayOfTheWeek = movingDate.getDay();
                        MM.checkPublicHolidayDayOfWeek(movingDayOfTheWeek, day, movingDate, value);

                        day++;
                        if (day > lastDayOfMonth) {
                            day = 1;
                            newMonth = true;
                        }
                    }
                }
            }

        });
    },

    setCalenderNextMonthDays : function (collection, firstRow, numberOfDaysForPrevMonth, inactiveColor, prevMonth, year, elementName, eventTracker) {
            collection[firstRow].innerText = numberOfDaysForPrevMonth;
            collection[firstRow].style.color = inactiveColor;
            collection[firstRow].setAttribute("data-partOfMonth", false);
            collection[firstRow].setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
            MM.CheckifEventMonth(elementName, collection[firstRow], eventTracker);
    },

    setCalenderPreviousMonthDays : function (collection, lastRow, iLoop, inactiveColor, elementName, nextMonth, year, eventTracker) {
            collection[lastRow].innerText = iLoop + 1;
            collection[lastRow].style.color = inactiveColor;
            collection[lastRow].setAttribute("data-partOfMonth", false);
            collection[lastRow].setAttribute("data-weekViewMonthTracker", nextMonth + " " + year);
            MM.CheckifEventMonth(elementName, collection[lastRow], eventTracker);
    },

    checkPublicHolidayDayOfWeek: function (dayOfTheWeek, day, date, value) {

        var calenderContainer = document.querySelector(".calenderContainer");
        var textColour = window.getComputedStyle(value).color;

        var backgroundColor = value.getAttribute("data-backgroundColor");
        var description = value.getAttribute("data-description");
        var descriptionTextColour = value.getAttribute("data-descriptionTextColour");
        var holidayType = value.getAttribute("data-type");
        var typeDescription = value.getAttribute("data-typeDescription");
        var typeTextColour = value.getAttribute("data-typeTextColour");
        var month = date.getMonth() + 1;
        var year = date.getFullYear();
        var fullDate = "";
        var holidaysExists = false;

        //Set public holiday styling
        if (dayOfTheWeek == 1) {//Monday
            MM.setStyleOnPublicHolidays(".monday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 2) {
            MM.setStyleOnPublicHolidays(".tuesday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 3) {
            MM.setStyleOnPublicHolidays(".wednesday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 4) {
            MM.setStyleOnPublicHolidays(".thursday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 5) {
            MM.setStyleOnPublicHolidays(".friday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 6) {
            MM.setStyleOnPublicHolidays(".saturday", dayOfTheWeek, day, textColour, backgroundColor);
        } else if (dayOfTheWeek == 0) {
            MM.setStyleOnPublicHolidays(".sunday", dayOfTheWeek, day, textColour, backgroundColor);
        }

        day = parseInt(day) < 10 ? "0" + day : day;
        month = parseInt(month) < 10 ? "0" + month : month;
        fullDate = day + "-" + month + "-" + year;

        document.getElementsByName(fullDate).forEach(function (element) {
            if (element.getAttribute("data-isHoliday") == "true") {
                holidaysExists = true;
            }
        });

        if (holidaysExists == false) {
            //Public holiday descriptions
            var calendarReadoutDiv = document.createElement('div');
            calendarReadoutDiv.setAttribute("class", "calendarReadout");
            calendarReadoutDiv.setAttribute("name", fullDate);
            calenderContainer.name = fullDate;
            calendarReadoutDiv.setAttribute("data-isHoliday", "true");

            var timeAreaDiv = document.createElement('div');
            timeAreaDiv.setAttribute("class", "timeArea");
            calendarReadoutDiv.appendChild(timeAreaDiv);

            var indicatorAreaDiv = document.createElement('div');
            indicatorAreaDiv.setAttribute("class", "indicatorArea");
            indicatorAreaDiv.style.backgroundColor = "var(--HIGHLIGHT)";
            calendarReadoutDiv.appendChild(indicatorAreaDiv);

            var rightSideWrapperDiv = document.createElement('div');
            rightSideWrapperDiv.setAttribute("class", "rightSideWrapper");

            var subjectAreaDiv = document.createElement('div');
            subjectAreaDiv.setAttribute("class", "subjectArea");

            var topTextDiv = document.createElement('div');
            topTextDiv.setAttribute("class", "topText");
            topTextDiv.style.color = descriptionTextColour != "" ? descriptionTextColour : "var(--INK)";
            topTextDiv.innerHTML = description;
            subjectAreaDiv.appendChild(topTextDiv);

            var bottomTextDiv = document.createElement('div');
            bottomTextDiv.setAttribute("class", "bottomText");
            bottomTextDiv.style.color = typeTextColour != "" ? typeTextColour : "var(--GHOST_MEDIUM)";
            bottomTextDiv.innerHTML = typeDescription;
            subjectAreaDiv.appendChild(bottomTextDiv);

            rightSideWrapperDiv.appendChild(subjectAreaDiv);
            calendarReadoutDiv.appendChild(rightSideWrapperDiv);

            var calenderMeetingsDiv = document.querySelector(".calenderMeetings");
            calenderMeetingsDiv.prepend(calendarReadoutDiv);
        }

    },

    setStyleOnPublicHolidays : function (classDay, dayOfTheWeek, day, textColour, backgroundColor) {
        var column = document.querySelector(classDay);
        var calenderContainer = document.querySelector(".calenderContainer");

        column.childNodes.forEach( function (value) {
            if (value.textContent == day){
                //Don't override selected day styling if the selected day and public holiday are the same
                if(value != calenderContainer.selectedDay){
                    value.style.color = textColour;
                    value.style.background = backgroundColor;
                    value.style.border = "solid " + backgroundColor + " " + Root.determineVariableUnitNeeded() * 1.4 + "px";
                }else if(value == calenderContainer.selectedDay){
                    calenderContainer.selectedDay.dayBlockColour = backgroundColor;
                    calenderContainer.selectedDay.dayBorderColour = "solid " + backgroundColor + " " + Root.determineVariableUnitNeeded() * 1.4 + "px";
                }
                value.classList.add("isPublicHoliday");
                value.setAttribute("data-isHolidayTextColour", textColour);
            }
        })
    },

    getCalendarDayCssClasses: function (day) {
        var Row1 = document.querySelector(".calenderDays ." + day + " .dayRow1");
        var Row2 = document.querySelector(".calenderDays ." + day + " .dayRow2");
        var Row3 = document.querySelector(".calenderDays ." + day + " .dayRow3");
        var Row4 = document.querySelector(".calenderDays ." + day + " .dayRow4");
        var Row5 = document.querySelector(".calenderDays ." + day + " .dayRow5");
        var Row6 = document.querySelector(".calenderDays ." + day + " .dayRow6");
        return [Row1, Row2, Row3, Row4, Row5, Row6];
    },

    getCalendarEventCssClasses: function (eventDay) {
        var Row1 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator1");
        var Row2 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator2");
        var Row3 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator3");
        var Row4 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator4");
        var Row5 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator5");
        var Row6 = document.querySelector(".calenderDays ." + eventDay + " .calenderEventIndicator6");
        return [Row1, Row2, Row3, Row4, Row5, Row6];
    },

    CheckifEventMonth: function (elementName, event, eventTracker, day) {
        //Get all events/meetings/holidays happening on that day
        var eventArray = document.getElementsByName(elementName);

        //Day contains meeting
        if (eventArray.length != 0) {

            eventArray.forEach(function (element) {
                //Don't count holidays as meetings
                if(element.getAttribute("data-isHoliday") != "true"){
                    event.style.display = "block";//Display indicator on day
                    eventTracker.push(event);
                }

                //Change day block and border colour accordingly
                if(day != null){
                    day.dayBlockColour = element.getAttribute("data-blockColour");
                    day.dayBorderColour = "solid " + element.getAttribute("data-borderColour") + " " + Root.determineVariableUnitNeeded() * 1.4 + "px";
                    day.style.background = day.dayBlockColour;
                    day.style.border = day.dayBorderColour;
                }
            });

        }
    },

    getElementNameDayAndMonth: function (day, movingMonth, year) {

        var addDay0;
        var addMonth0;

        //Element name used to display event indicator on the relevant element
        if (day < 10) {//single digits
            addDay0 = "0";
        } else {
            addDay0 = "";
        }

        if ((movingMonth) < 10) {
            addMonth0 = "0";
        } else {
            addMonth0 = "";
        }

        return addDay0 + day + "-" + addMonth0 + movingMonth + "-" + year;
    },

    getElementNameMonth: function (day, movingMonth, year) {
        var addMonth0;

        //Element name used to display event indicator on the relevant element
        if ((movingMonth) < 10) {
            addMonth0 = "0";
        } else {
            addMonth0 = "";
        }

        return day + "-" + addMonth0 + movingMonth + "-" + year;
    },

    calenderHighlightDaySetUp: function (day) {
        var skin = "var(--PRIMARY)";

        day.style.background = skin;
        day.style.borderColor = skin;
        day.style.color = "var(--PAPER)";
        day.style.border = "solid " + skin + " " + Root.determineVariableUnitNeeded() * 1.4 + "px";
    },

    calendarDeselectHighlightedDay: function (calenderContainer) {
        var state = document.querySelector(".bottomCalenderDropDown").getAttribute("data-collapseExpand");

        //Deselecting currently selected day
        if (calenderContainer.selectedDay != null) {
            calenderContainer.selectedDay.style.background = "none";
            calenderContainer.selectedDay.style.borderColor = "none";
            calenderContainer.selectedDay.style.border = "none";

            //Checking for weekends and inactive days
            if (calenderContainer.selectedDay.classList.contains("isPublicHoliday")) {
                MM.setCalenderDayColours(calenderContainer.selectedDay, calenderContainer.selectedDay.getAttribute("data-isHolidayTextColour"));
            }else if (state === "Expand") {
                MM.setCalenderDayColours(calenderContainer.selectedDay, "var(--INK)");
            }else if (calenderContainer.selectedDay.parentNode.className === "sunday" || calenderContainer.selectedDay.parentNode.className === "saturday") {
                MM.setCalenderDayColours(calenderContainer.selectedDay, calenderContainer.getAttribute("data-inactiveDayColour"));
            }else if (calenderContainer.selectedDay.getAttribute("data-partOfMonth") === "false") {
                MM.setCalenderDayColours(calenderContainer.selectedDay, calenderContainer.getAttribute("data-inactiveDayColour"));
            }else {
                MM.setCalenderDayColours(calenderContainer.selectedDay, "var(--INK)");
            }

        }
    },

    setCalenderDayColours: function (day, colour) {
        if(day.dayBlockColour != null && day.dayBorderColour != null){
            day.style.color = colour;
            day.style.background = day.dayBlockColour;
            day.style.border = day.dayBorderColour;
        }else{
            day.style.color = colour;
            day.style.border = "none";
            day.style.background = "transparent";
        }
    },

    calenderHighlightDay: function (day) {
        var calenderContainer = document.querySelector(".calenderContainer");
        var topDate = document.querySelector(".topDate");

        MM.calendarDeselectHighlightedDay(calenderContainer);

        day.style.background = "var(--PRIMARY)";
        day.style.borderColor = "var(--PRIMARY)";

        day.style.color = "var(--PAPER)";
        day.style.border = "solid var(--PRIMARY) " + Root.determineVariableUnitNeeded() * 1.4 + "px";
        calenderContainer.selectedDay = day;

        //Calender Meetings
        //getting meetings for selected date
        var meetingDay;
        var meetingMonth;
        var meetingYear;

        var months = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"];

        meetingDay = day.innerText;
        meetingMonth = new Date(Date.parse(day.getAttribute("data-weekViewMonthTracker").split(" ")[0] + " 01 " + day.getAttribute("data-weekViewMonthTracker").split(" ")[1])).getMonth() + 1;
        meetingYear = day.getAttribute("data-weekViewMonthTracker").split(" ")[1];
        topDate.innerText = months[meetingMonth - 1] + " " + meetingYear;

        MM.displayMeetingsForSelectedDay(meetingDay, meetingMonth, meetingYear);
    },

    displayMeetingsForSelectedDay: function (day, month, year) {

        //removing meetings from previous selected date
        var previousSelectedDate = document.getElementById("selectedDate").attributes.value.value;

        if (previousSelectedDate != "") {
            var previousMeetings = document.getElementsByName(previousSelectedDate);

            for (j = 0; j < previousMeetings.length; j++) {
                previousMeetings[j].style.display = "none";
                previousMeetings[j].children[0].classList.remove("highlight");
                previousMeetings[j].children[1].classList.remove("highlight");
            }
        }

        day = parseInt(day) < 10 ? "0" + day : day;
        month = parseInt(month) < 10 ? "0" + month : month;

        var selectedDate = day + "-" + month + "-" + year;
        var selectedDateMeetings = document.getElementsByName(selectedDate);

        for (i = 0; i < selectedDateMeetings.length; i++) {
            selectedDateMeetings[i].style.display = "grid";

            var currentTime = Math.round(new Date().getTime());

            if (selectedDateMeetings[i].children[0].children[0] != null && selectedDateMeetings[i].children[0].children[1] != null) {
                var meetingStart = selectedDateMeetings[i].children[0].children[0].getAttribute("data-start");
                var meetingEnd = selectedDateMeetings[i].children[0].children[1].getAttribute("data-end");
                if (currentTime >= meetingStart && currentTime <= meetingEnd) {
                    selectedDateMeetings[i].children[0].classList.add("highlight");
                    selectedDateMeetings[i].children[1].classList.add("highlight");
                }
            }
        }

        //used to store which date is selected
        document.getElementById("selectedDate").setAttribute("value", selectedDate);
    },

    moveCalendarMonthWeekLeft: function () {
        var calenderContainer = document.querySelector(".calenderContainer");
        var monthMover = calenderContainer.getAttribute("data-monthMover");
        var state = document.querySelector(".bottomCalenderDropDown").getAttribute("data-CollapseExpand");

        //Deselecting currently selected day
        if (calenderContainer.selectedDay != null) {
            calenderContainer.selectedDay.style.background = "none";
            calenderContainer.selectedDay.style.borderColor = "none";
            calenderContainer.selectedDay.style.color = "var(--INK)";
            calenderContainer.selectedDay.style.border = "none";
        }

        if (state != "Expand") {//Month view update
            calenderContainer.setAttribute("data-monthMover", parseInt(monthMover) - 1);

            var keyElement = document.querySelector(".calenderContainer");
            var key = keyElement.getAttribute("data-key");
            var currentEpoch = calenderContainer.getAttribute("data-date");
            keyElement = document.getElementById("calendarInput");

            keyElement.value = currentEpoch;
            keyElement.name = key + ":previous";
            MM.partialUpdate(keyElement);
        } else {//Week view update
            MM.setMeetingCalendar("left");
        }

    },

    moveCalendarMonthWeekRight: function () {
        var calenderContainer = document.querySelector(".calenderContainer");
        var monthMover = calenderContainer.getAttribute("data-monthMover");
        var state = document.querySelector(".bottomCalenderDropDown").getAttribute("data-CollapseExpand");

        //Deselecting currently selected day
        if (calenderContainer.selectedDay != null) {
            calenderContainer.selectedDay.style.background = "none";
            calenderContainer.selectedDay.style.borderColor = "none";
            calenderContainer.selectedDay.style.color = "var(--INK)";
            calenderContainer.selectedDay.style.border = "none";
        }

        if (state != "Expand") {//Month view update
            calenderContainer.setAttribute("data-monthMover", parseInt(monthMover) + 1);

            var keyElement = document.querySelector(".calenderContainer");
            var key = keyElement.getAttribute("data-key");
            var currentEpoch = calenderContainer.getAttribute("data-date");
            keyElement = document.getElementById("calendarInput");

            keyElement.value = currentEpoch;
            keyElement.name = key + ":next";
            MM.partialUpdate(keyElement);
        } else {//Week view update
            MM.setMeetingCalendar("right");
        }
    },

    calenderCollapseExpand: function (state) {
        var calenderContainer = document.querySelector(".calenderContainer");
        var calenderStyle = document.getElementById("CalenderStyle");
        var calender = document.getElementById("calenderDays");
        var dropDownArrow = document.querySelector(".bottomCalenderDropDown");
        var topDate = document.querySelector(".topDate");
        var calenderDate = document.querySelector(".calenderDate");

        var dayRow2 = document.querySelectorAll(".dayRow2");
        var dayRow3 = document.querySelectorAll(".dayRow3");
        var dayRow4 = document.querySelectorAll(".dayRow4");
        var dayRow5 = document.querySelectorAll(".dayRow5");
        var dayRow6 = document.querySelectorAll(".dayRow6");

        var dayEvent2 = document.querySelectorAll(".calenderEventIndicator2");
        var dayEvent3 = document.querySelectorAll(".calenderEventIndicator3");
        var dayEvent4 = document.querySelectorAll(".calenderEventIndicator4");
        var dayEvent5 = document.querySelectorAll(".calenderEventIndicator5");
        var dayEvent6 = document.querySelectorAll(".calenderEventIndicator6");

        var sunday = document.querySelector(".sunday");
        var monday = document.querySelector(".monday");
        var tuesday = document.querySelector(".tuesday");
        var wednesday = document.querySelector(".wednesday");
        var thursday = document.querySelector(".thursday");
        var friday = document.querySelector(".friday");
        var saturday = document.querySelector(".saturday");

        var calenderChevronSpaceLeft = document.querySelector(".calenderChevronSpaceLeft");
        var calenderChevronSpaceRight = document.querySelector(".calenderChevronSpaceRight");

        var calendarHeight = calenderContainer.getAttribute("data-calendarHeight");
        var row6Enabled = calenderContainer.getAttribute("data-6Rows");

        //UFF
        var unit = Root.determineUnitNeeded();

        if (state === "Collapse") {
            //Disable and then enable touch events once animation finished
            var dropDownArrowContainer = document.querySelector(".bottomCalenderDropDownContainer");

            dropDownArrowContainer.style.pointerEvents = "none";

            setTimeout(function () {
                dropDownArrowContainer.style.pointerEvents = "auto";
                MM.setCalenderMeetingsHeight();
            }, 500);

            //Animate calender days

            calenderStyle.innerHTML = "@keyframes Collapse\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    height: " + calendarHeight + ";\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    height: calc(18 * var(" + unit + "));\n" +
                "  }\n" +
                "\n" +
                "}";

            calender.style.animationName = "Collapse";
            calender.style.animationDuration = "0.40s";
            calender.style.animationFillMode = "forwards";

            dropDownArrow.setAttribute("data-CollapseExpand", "Expand");

            //Hide days and events
            for (var i = 0; i < dayRow2.length; i++) {

                dayRow2[i].style.display = "none";
                dayRow3[i].style.display = "none";
                dayRow4[i].style.display = "none";
                dayRow5[i].style.display = "none";

                dayEvent2[i].style.display = "none";
                dayEvent3[i].style.display = "none";
                dayEvent4[i].style.display = "none";
                dayEvent5[i].style.display = "none";

                if (row6Enabled === "true") {
                    dayRow6[i].style.display = "none";
                    dayEvent6[i].style.display = "none";
                }

            }

            //Correct calender days row heights
            var rowHeightHandler;
            rowHeightHandler = "calc(5 * var(" + unit + ")) calc(7 * var(" + unit + "))";

            sunday.style.gridTemplateRows = rowHeightHandler;
            monday.style.gridTemplateRows = rowHeightHandler;
            tuesday.style.gridTemplateRows = rowHeightHandler;
            wednesday.style.gridTemplateRows = rowHeightHandler;
            thursday.style.gridTemplateRows = rowHeightHandler;
            friday.style.gridTemplateRows = rowHeightHandler;
            saturday.style.gridTemplateRows = rowHeightHandler;


            //Move side arrows down
            calenderChevronSpaceLeft.style.gridRow = 2;
            calenderChevronSpaceRight.style.gridRow = 2;
            topDate.style.margin = "calc(1.6 * var(" + unit + ")) 0px";

            //Animate calender month height

            calenderStyle.innerHTML += "@keyframes adjustMonthHeight\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    height: calc(12 * var(" + unit + "));\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    height: calc(7 * var(" + unit + "));\n" +
                "  }\n" +
                "\n" +
                "}";

            calenderDate.style.animationName = "adjustMonthHeight";
            calenderDate.style.animationDuration = "0.40s";
            calenderDate.style.animationFillMode = "forwards";

            //Week view
            MM.setMeetingCalendar("");

            //making the meetings div grow as the calendar Collapses
            document.getElementsByClassName("calenderMeetings")[0].style.height = "calc(100 * var(" + unit + "))";

        } else {//reverse

            //Disable and then enable touc events once animation finished
            var dropDownArrowContainer = document.querySelector(".bottomCalenderDropDownContainer");

            dropDownArrowContainer.style.pointerEvents = "none";

            setTimeout(function () {
                dropDownArrowContainer.style.pointerEvents = "auto";
                MM.setCalenderMeetingsHeight();
            }, 800);

            //Deselecting currently selected day
            if (calenderContainer.selectedDay != null) {
                calenderContainer.selectedDay.style.background = "none";
                calenderContainer.selectedDay.style.borderColor = "none";
                calenderContainer.selectedDay.style.color = "var(--INK)";
                calenderContainer.selectedDay.style.border = "none";
            }

            //Animate calender days

            calenderStyle.innerHTML = "@keyframes Expand\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    height: calc(18 * var(" + unit + "));\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    height: " + calendarHeight + ";\n" +
                "  }\n" +
                "\n" +
                "}";

            calender.style.animationName = "Expand";
            calender.style.animationDuration = "0.70s";
            calender.style.animationFillMode = "forwards";

            dropDownArrow.setAttribute("data-CollapseExpand", "Collapse");

            //Unhide days and events

            setTimeout(
                function () {
                    for (var i = 0; i < calenderContainer.eventTracker.length; i++) {
                        calenderContainer.eventTracker[i].style.display = "block";
                    }

                }, 100);

            setTimeout(
                function () {
                    for (var i = 0; i < dayRow2.length; i++) {
                        dayRow2[i].style.display = "grid";
                    }
                }, 200);

            setTimeout(
                function () {
                    for (var i = 0; i < dayRow2.length; i++) {
                        dayRow3[i].style.display = "grid";
                    }
                }, 300);

            setTimeout(
                function () {
                    for (var i = 0; i < dayRow2.length; i++) {
                        dayRow4[i].style.display = "grid";
                    }
                }, 400);

            setTimeout(
                function () {
                    for (var i = 0; i < dayRow2.length; i++) {
                        dayRow5[i].style.display = "grid";
                    }
                }, 500);

            setTimeout(
                function () {
                    for (var i = 0; i < dayRow2.length; i++) {
                        if (row6Enabled === "true") {
                            dayRow6[i].style.display = "grid";
                        }
                    }

                    //Month view (Initialise days for month)
                    MM.setMeetingCalendar("animation");
                }, 600);

            //Correct calender days row heights
            var rowHeightHandler = "calc(7 * var(" + unit + ")) calc(7 * var(" + unit + "))";
            var numberOfRowRemovals;

            if (row6Enabled === "true") {
                numberOfRowRemovals = 5;
            } else {
                numberOfRowRemovals = 4;
            }

            for (var i = numberOfRowRemovals; i > 0; i--) {
                setTimeout(
                    function () {
                        sunday.style.gridTemplateRows = rowHeightHandler;
                        monday.style.gridTemplateRows = rowHeightHandler;
                        tuesday.style.gridTemplateRows = rowHeightHandler;
                        wednesday.style.gridTemplateRows = rowHeightHandler;
                        thursday.style.gridTemplateRows = rowHeightHandler;
                        friday.style.gridTemplateRows = rowHeightHandler;
                        saturday.style.gridTemplateRows = rowHeightHandler;

                        rowHeightHandler = rowHeightHandler + " calc(7 * var(" + unit + "))";

                    }, 100);
            }

            //Move side arrows up

            calenderChevronSpaceLeft.style.gridRow = 1;
            calenderChevronSpaceRight.style.gridRow = 1;
            topDate.style.margin = "0px auto";

            //Animate calender month height

            calenderStyle.innerHTML += "@keyframes adjustMonthHeight\n" +
                "{\n" +
                "\n" +
                "  from\n" +
                "  {\n" +
                "    height: calc(7 * var(" + unit + "));\n" +
                "  }\n" +
                "  to\n" +
                "  {\n" +
                "    height: calc(12 * var(" + unit + "));\n" +
                "  }\n" +
                "\n" +
                "}";

            calenderDate.style.animationName = "adjustMonthHeight";
            calenderDate.style.animationDuration = "0.40s";
            calenderDate.style.animationFillMode = "forwards";

            //making the meetings div small as the calendar expands
            document.getElementsByClassName("calenderMeetings")[0].style.height = "calc(60 * var( " + unit + "))";

        }
    },

    weekView: function (calenderContainer, numberOfDaysForPrevMonth, prevMonth, numberOfDaysForCurrMonth, currMonth, numberOfDaysForNextMonth, nextMonth, movingMonth, year, direction, currentEpoch) {

        if (direction == null) {
            direction = "";
        }

        var sunday = document.querySelector(".calenderDays .sunday .dayRow1");
        var monday = document.querySelector(".calenderDays .monday .dayRow1");
        var tuesday = document.querySelector(".calenderDays .tuesday .dayRow1");
        var wednesday = document.querySelector(".calenderDays .wednesday .dayRow1");
        var thursday = document.querySelector(".calenderDays .thursday .dayRow1");
        var friday = document.querySelector(".calenderDays .friday .dayRow1");
        var saturday = document.querySelector(".calenderDays .saturday .dayRow1");
        var days = [sunday, monday, tuesday, wednesday, thursday, friday, saturday];

        for (var iLoop = 0; iLoop < days.length; iLoop++) {
            if(calenderContainer.selectedDay == days[iLoop]){
                //Colour stays as is
            }else if(days[iLoop].className.includes("isPublicHoliday")){
                days[iLoop].style.color = days[iLoop].getAttribute("data-isHolidayTextColour");
            }else{
                days[iLoop].style.color = "var(--INK)";
            }
        }

        var currentDayOfTheWeek;
        var week = 7;

        var sundayEvent = document.querySelector(".calenderDays .sunday .calenderEventIndicator1");
        var mondayEvent = document.querySelector(".calenderDays .monday .calenderEventIndicator1");
        var tuesdayEvent = document.querySelector(".calenderDays .tuesday .calenderEventIndicator1");
        var wednesdayEvent = document.querySelector(".calenderDays .wednesday .calenderEventIndicator1");
        var thursdayEvent = document.querySelector(".calenderDays .thursday .calenderEventIndicator1");
        var fridayEvent = document.querySelector(".calenderDays .friday .calenderEventIndicator1");
        var saturdayEvent = document.querySelector(".calenderDays .saturday .calenderEventIndicator1");
        var events = [sundayEvent, mondayEvent, tuesdayEvent, wednesdayEvent, thursdayEvent, fridayEvent, saturdayEvent];

        var calenderContainer = document.querySelector(".calenderContainer");
        var monthMover = calenderContainer.getAttribute("data-monthMover");

        //Used to get element names whose months start at (1-12) taking into account year edge cases
        var prevMonthNumber = 0;
        var currMonthNumber = 0;
        var nextMonthNumber = 0;

        if (movingMonth == 0) {
            prevMonthNumber = 12;
            currMonthNumber = 1;
            nextMonthNumber = 2;
        } else if (movingMonth == 11) {
            prevMonthNumber = 11;
            currMonthNumber = 12;
            nextMonthNumber = 1;
        } else {
            prevMonthNumber = movingMonth;
            currMonthNumber = movingMonth + 1;
            nextMonthNumber = movingMonth + 2;
        }

        var elementName = "";

        MM.weekViewEventCleaner(sundayEvent);
        MM.weekViewEventCleaner(mondayEvent);
        MM.weekViewEventCleaner(tuesdayEvent);
        MM.weekViewEventCleaner(wednesdayEvent);
        MM.weekViewEventCleaner(thursdayEvent);
        MM.weekViewEventCleaner(fridayEvent);
        MM.weekViewEventCleaner(saturdayEvent);

        if (direction === "") {//Sets up week view after animation
            for (var i = 1; i < week + 1; i++) {
                currentDayOfTheWeek = new Date(year, movingMonth, i).getDay();
                elementName = MM.getElementNameDayAndMonth(i, currMonthNumber, year);

                switch (currentDayOfTheWeek) {
                    case 0://Sunday
                        sunday.innerText = i;
                        sunday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);//Keeps track of which month the user clicked on
                        MM.CheckifEventNoHide(elementName, sundayEvent);
                        break;
                    case 1://Monday
                        monday.innerText = i;
                        monday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, mondayEvent);
                        break;
                    case 2://Tuesday
                        tuesday.innerText = i;
                        tuesday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, tuesdayEvent);
                        break;
                    case 3://Wednesday
                        wednesday.innerText = i;
                        wednesday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, wednesdayEvent);
                        break;
                    case 4://Thursday
                        thursday.innerText = i;
                        thursday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, thursdayEvent);
                        break;
                    case 5://Friday
                        friday.innerText = i;
                        friday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, fridayEvent);
                        break;
                    case 6://Saturday
                        saturday.innerText = i;
                        saturday.setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEventNoHide(elementName, saturdayEvent);
                        break;
                }
            }

            MM.weekViewDayCleaner(sunday, saturday);
            MM.weekViewDayCleaner(monday, saturday);
            MM.weekViewDayCleaner(tuesday, saturday);
            MM.weekViewDayCleaner(wednesday, saturday);
            MM.weekViewDayCleaner(thursday, saturday);
            MM.weekViewDayCleaner(friday, saturday);

            for (var i = numberOfDaysForPrevMonth; i > (numberOfDaysForPrevMonth - week); i--) {
                currentDayOfTheWeek = new Date(year, movingMonth - 1, i).getDay();
                elementName = MM.getElementNameDayAndMonth(i, prevMonthNumber, year);

                switch (currentDayOfTheWeek) {
                    case 0://Sunday
                        if (sunday.innerText === "") {
                            sunday.innerText = i;
                            sunday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, sundayEvent);
                        }
                        break;
                    case 1://Monday
                        if (monday.innerText === "") {
                            monday.innerText = i;
                            monday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, mondayEvent);
                        }
                        break;
                    case 2://Tuesday
                        if (tuesday.innerText === "") {
                            tuesday.innerText = i;
                            tuesday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, tuesdayEvent);
                        }
                        break;
                    case 3://Wednesday
                        if (wednesday.innerText === "") {
                            wednesday.innerText = i;
                            wednesday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, wednesdayEvent);
                        }
                        break;
                    case 4://Thursday
                        if (thursday.innerText === "") {
                            thursday.innerText = i;
                            thursday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, thursdayEvent);
                        }
                        break;
                    case 5://Friday
                        if (friday.innerText === "") {
                            friday.innerText = i;
                            friday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, fridayEvent);
                        }
                        break;
                    case 6://Saturday
                        if (saturday.innerText === "") {
                            saturday.innerText = i;
                            saturday.setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, saturdayEvent);
                        }
                        break;
                }
            }
        } else {//Sets up week view movement (left right)

            var movementPlace = parseInt(saturday.innerText);
            var nextMonthCounter = 0;
            var topDate = document.querySelector(".topDate");

            var prevMovementPlace = parseInt(sunday.innerText);

            if (direction === "right") {

                if ((movementPlace + week) <= numberOfDaysForCurrMonth) {//No Month change

                    for (var iLoop = 1; iLoop < week + 1; iLoop++) {
                        elementName = MM.getElementNameDayAndMonth((movementPlace + iLoop), currMonthNumber, year);

                        days[iLoop - 1].innerText = movementPlace + iLoop;
                        days[iLoop - 1].setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEvent(elementName, events[iLoop - 1]);
                    }

                } else {//Month change

                    //Update
                    var keyElement = document.querySelector(".calenderContainer");
                    var key = keyElement.getAttribute("data-key");
                    keyElement = document.getElementById("calendarInput");

                    if (direction == "left") {
                        keyElement.value = currentEpoch;
                        keyElement.name = key + ":previous";
                    } else {
                        keyElement.value = currentEpoch;
                        keyElement.name = key + ":next";
                    }
                    MM.partialUpdate(keyElement, true);

                    if (nextMonth === "January") {
                        year++;
                    }

                    topDate.innerText = nextMonth + " " + year;
                    calenderContainer.setAttribute("data-monthMover", parseInt(monthMover) + 1);

                    for (var iLoop = 1; iLoop < week + 1; iLoop++) {

                        //Element name used to display event indicator on the relevant element
                        if ((movingMonth) < 10) {
                            addMonth0 = "0";
                        } else {
                            addMonth0 = "";
                        }

                        if ((movementPlace + iLoop) < numberOfDaysForCurrMonth + 1) {//Display days of that month still

                            elementName = (movementPlace + iLoop) + "-" + addMonth0 + currMonthNumber + "-" + year;
                            days[iLoop - 1].innerText = movementPlace + iLoop;
                            days[iLoop - 1].setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                            MM.CheckifEvent(elementName, events[iLoop - 1]);

                        } else {//Display new days month

                            nextMonthCounter++;
                            elementName = "0" + (nextMonthCounter) + "-" + addMonth0 + nextMonthNumber + "-" + year;
                            days[iLoop - 1].innerText = nextMonthCounter;
                            days[iLoop - 1].setAttribute("data-weekViewMonthTracker", nextMonth + " " + year);
                            MM.CheckifEvent(elementName, events[iLoop - 1]);

                        }
                    }

                }

            } else if (direction === "left") {

                var dayCounter = 0;

                if ((prevMovementPlace > week)) {//No Month change

                    for (var iLoop = week; iLoop > 0; iLoop--) {
                        elementName = MM.getElementNameDayAndMonth((prevMovementPlace - iLoop), currMonthNumber, year);

                        days[dayCounter].innerText = prevMovementPlace - iLoop;
                        days[dayCounter].setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                        MM.CheckifEvent(elementName, events[dayCounter]);
                        dayCounter++;
                    }

                } else {//Month change

                    //Update
                    var keyElement = document.querySelector(".calenderContainer");
                    var key = keyElement.getAttribute("data-key");
                    keyElement = document.getElementById("calendarInput");

                    if (direction == "left") {
                        keyElement.value = currentEpoch;
                        keyElement.name = key + ":previous";
                    } else {
                        keyElement.value = currentEpoch;
                        keyElement.name = key + ":next";
                    }
                    MM.partialUpdate(keyElement, true);

                    if (prevMonth === "December") {
                        year--;
                    }

                    dayCounter = days.length;

                    topDate.innerText = prevMonth + " " + year;
                    calenderContainer.setAttribute("data-monthMover", parseInt(monthMover) - 1);

                    for (var iLoop = 1; iLoop < week + 1; iLoop++) {
                        //Element name used to display event indicator on the relevant element
                        if ((movingMonth) < 10) {
                            addMonth0 = "0";
                        } else {
                            addMonth0 = "";
                        }

                        if ((prevMovementPlace - iLoop) > 0) {//Display days of that month still

                            dayCounter--;
                            elementName = "0" + (prevMovementPlace - iLoop) + "-" + addMonth0 + currMonthNumber + "-" + year;
                            days[dayCounter].innerText = prevMovementPlace - iLoop;
                            days[dayCounter].setAttribute("data-weekViewMonthTracker", currMonth + " " + year);
                            MM.CheckifEvent(elementName, events[dayCounter]);

                        } else {

                            dayCounter--;
                            elementName = numberOfDaysForPrevMonth + "-" + addMonth0 + prevMonthNumber + "-" + year;
                            days[dayCounter].innerText = numberOfDaysForPrevMonth;
                            days[dayCounter].setAttribute("data-weekViewMonthTracker", prevMonth + " " + year);
                            MM.CheckifEvent(elementName, events[dayCounter]);
                            numberOfDaysForPrevMonth--;

                        }

                    }
                }

            }

        }

    },

    weekViewDayCleaner: function (day, saturday) {
        if (day.innerText > saturday.innerText) {
            day.innerText = "";
        }
    },

    weekViewEventCleaner: function (day) {
        day.style.display = "none";
    },

    CheckifEventNoHide: function (elementName, event) {
        var eventArray = document.getElementsByName(elementName);

        //Day contains meeting
        if (eventArray.length != 0) {

            eventArray.forEach(function (element) {
                //Don't count holidays as meetings
                if(element.getAttribute("data-isHoliday") != "true"){
                    event.style.display = "block";
                }
            });

        }
    },

    CheckifEvent: function (elementName, event) {
        var eventArray = document.getElementsByName(elementName);

        //Day contains meeting
        if (document.getElementsByName(elementName).length != 0) {

            eventArray.forEach(function (element) {
                //Don't count holidays as meetings
                if(element.getAttribute("data-isHoliday") != "true"){
                    event.style.display = "block";
                }
            });
        } else {
            event.style.display = "none";
        }
    },

    /*End Calendar*/

    /*Scroll to bottom of container button*/
    checkDisplayOfScrollToBottomBtn: function (parentContainer) {
        if (parentContainer == null) {
            parentContainer = document.getElementsByClassName("StructuredContainerBodyAndBottom")[0];
            if (parentContainer == null) {
                return;
            }
        }

        if (parentContainer.scrollTop == (parentContainer.scrollHeight - parentContainer.offsetHeight) && parentContainer.getAttribute("scrollToBottomBtnClicked") == "true") {
            parentContainer.setAttribute("scrollToBottomBtnClicked", "false");
            var element = document.querySelector(".scrollToBottomButtonContainer");
            MM.partialUpdateSubElementKeyFrontEnd(element, element.getAttribute("data-modelMapIdForButton"));
        }

        var btn = document.getElementsByClassName("scrollToBottomButtonContainer")[0];
        var btnArea = document.getElementById("scrollToBottomButtonArea");

        if (btn != null && btnArea != null && parentContainer != null) {
            if(document.getElementsByClassName("composedMessage") != null && document.getElementsByClassName("composedMessage").length > 0){
                btnArea.style.marginBottom = document.getElementsByClassName("composedMessage")[0].clientHeight + "px";
            }

            var alreadyVisible = btn.getAttribute("data-Scrolled");

            var youScrolled = parentContainer.scrollTop;
            if (youScrolled > 0) {
                var screenSize = parentContainer.clientHeight;
                var maxScrollable = document.getElementById("messagingBody").scrollHeight;
                var show = youScrolled < maxScrollable - screenSize;
                if (show) {
                    btnArea.style.display = "block";

                    if (alreadyVisible == "false") {
                        //used to set scrolled attribute in conversation
                        btn.setAttribute("data-Scrolled", "true");
                        MM.partialUpdateSubElementKeyFrontEnd(btn, btn.getAttribute("data-userScrolledTrueModelMapId"));
                    }
                } else {
                    btnArea.style.display = "none";

                    if (alreadyVisible == "true") {
                        //used to set scrolled attribute in conversation
                        btn.setAttribute("data-Scrolled", "false");
                        MM.partialUpdateSubElementKeyFrontEnd(btn, btn.getAttribute("data-userScrolledFalseModelMapId"));

                        if (btn.getAttribute("data-text") != "0") {
                            MM.partialUpdateSubElementKeyFrontEnd(btn, btn.getAttribute("data-modelMapIdForButton"));
                        }
                    }
                }
            }
        }
    },

    scrollToBottomOfContainer: function (element, parentContainerID) {
        var container = document.getElementsByClassName("StructuredContainerBodyAndBottom")[0];
        container.setAttribute("scrollToBottomBtnClicked", "true");

        var scrollToBottomContainer = document.getElementById(parentContainerID);
        scrollToBottomContainer.lastElementChild.scrollIntoView({behavior: 'smooth'});
    },
    /*End Scroll to bottom of container button*/

    /*Messaging Mentions*/
    setWindowHeightWithoutKeyboard: function () {
        var composedMessage = document.querySelector(".composedMessage");

        if(composedMessage != null){
            //Only set once (partial update set it multiple times)
            if(composedMessage.getAttribute("data-windowInnerHeightWithoutKeyboard") == null || composedMessage.getAttribute("data-windowInnerHeightWithoutKeyboard") == ""){
                composedMessage.setAttribute("data-windowInnerHeightWithoutKeyboard", window.innerHeight);
            }
        }
    },

    getRemainingHeightForMentions: function (windowHeight) {
        var composedMessage = document.querySelector(".composedMessage");
        var footer = document.getElementById("footer");
        var headerFixed = document.getElementById("headerFixed");
        var heightRemaining = composedMessage.clientHeight + (footer != null ? footer.clientHeight : 0) + (headerFixed != null ? headerFixed.clientHeight : 0);
        return parseInt(windowHeight) - heightRemaining;
    },

    checkForMention: function (el) {
        var words = el.innerHTML.split(" ");
        var lastWord = words[words.length - 1];
        var temp = "";

        //End Mention
        if (el.getAttribute("data-Mentions") === "true") {
            if (el.innerHTML[el.innerHTML.length - 1] === " " || el.innerHTML === "") {//user starts new word || user removes @
                temp = el.innerHTML;
                el.setAttribute("data-Mentions", "false");

                var hiddenInputName = el.getAttribute("data-hiddenInputName");
                var composedMessageHiddenInput = document.getElementsByName(hiddenInputName)[0];
                if (composedMessageHiddenInput != null) {
                    composedMessageHiddenInput.setAttribute("value", el.innerHTML + "_[groupMentionsUpdateFE]EndMention");
                    MM._partialUpdateFrontEnd(composedMessageHiddenInput);
                    composedMessageHiddenInput.setAttribute("value", temp);
                }
            }
        }

        //Begin Mention
        if (lastWord.startsWith("@")) {
            temp = el.innerHTML;
            el.classList.add("ignoreKeyboardRemoval");
            el.setAttribute("data-Mentions", "true");
            var hiddenInputName = el.getAttribute("data-hiddenInputName");
            var composedMessageHiddenInput = document.getElementsByName(hiddenInputName)[0];
            if (composedMessageHiddenInput != null) {
                composedMessageHiddenInput.setAttribute("value", el.innerHTML + "_[groupMentionsUpdateFE]");
                MM._partialUpdateFrontEnd(composedMessageHiddenInput);
                composedMessageHiddenInput.setAttribute("value", temp);
            }
            el.value = el.value + "_[groupMentionsUpdateFE]";
            MM._partialUpdateFrontEnd(el, null, null);
            el.value = temp;

            //Style tag holds styling for incoming mentions container
            var composedMessage = document.querySelector(".composedMessage");
            var style = composedMessage.querySelector(".styleTagForMentions");
            if(style == null || style == ""){
                composedMessage.setAttribute("data-windowInnerHeightWitKeyboard", window.innerHeight);
                style = document.createElement("style");
                style.classList.add("styleTagForMentions");
                composedMessage.appendChild(style);
                MM.adjustMentionsContainerHeight(el);
            }
        }
    },

    adjustMentionsContainerHeight: function (el) {
        var mentionsContainer = document.getElementById("mentionsContainer");
        var composedMessage = document.querySelector(".composedMessage");
        var style = composedMessage.querySelector(".styleTagForMentions");
        var windowHeightWithOutKeyBoard = composedMessage.getAttribute("data-windowInnerHeightWithoutKeyboard");
        var windowHeightWithKeyBoard = composedMessage.getAttribute("data-windowInnerHeightWitKeyboard");

        //Container height is adjusted based on whether keyboard is on/off screen
        //Don't need to adjust for UFF
        if (document.activeElement == el && style != null) {//Keyboard up

            el.classList.add("ignoreKeyboardRemoval");

            style.innerHTML = "#mentionsContainer\n" +
                "{\n" +
                "\n" +
                "    height: fit-content;\n" +
                "    overflow: scroll;\n" +
                "    max-height: " + MM.getRemainingHeightForMentions(windowHeightWithKeyBoard) + "px;\n" +
                "\n" +
                "}";

        } else if (mentionsContainer != null  && style != null) {//Keyboard down or UFF

            el.classList.remove("ignoreKeyboardRemoval");

            style.innerHTML = "#mentionsContainer\n" +
                "{\n" +
                "\n" +
                "    overflow: scroll;\n" +
                "    height: fit-content;\n" +
                "    max-height: " + MM.getRemainingHeightForMentions(windowHeightWithOutKeyBoard) + "px;\n" +
                "\n" +
                "}";

        }
    },

    applyHighlightToMention: function () {
        var messageBubble = document.querySelectorAll(".messageBubbleText");
        if (messageBubble.length <= 0) {
            return;
        }

        var markedUpText;

        messageBubble.forEach(function (value) {
            if (value.getAttribute("data-textMarkUp") != "" && value.getAttribute("data-textMarkUp") != null) {

                if (value.innerHTML.includes("<mention>")) {
                    if (value.getAttribute("data-direction") == "LEFT") {
                        markedUpText = value.innerHTML.replace(/<mention>/g, "<span class='messageBubbleHighlightMentionsTextLeft'>");
                        markedUpText = markedUpText.replace(/<\/mention>/g, "</span>");
                    } else if (value.getAttribute("data-direction") == "RIGHT") {
                        markedUpText = value.innerHTML.replace(/<mention>/g, "<span class='messageBubbleHighlightMentionsTextRight'>");
                        markedUpText = markedUpText.replace(/<\/mention>/g, "</span>");
                    }

                    value.innerHTML = markedUpText;
                }

            }
        });

    },
    /*End Messaging Mentions*/

    /*save unsent messages*/
    saveText: function (el) {
        var originalName = el.getAttribute("data-hiddenInputName");
        var composedMessageHiddenInput = document.getElementsByName(originalName)[0];
        if (composedMessageHiddenInput != null) {
            composedMessageHiddenInput.setAttribute("name", "savingText:" + originalName);
            MM._partialUpdateFrontEnd(composedMessageHiddenInput);
            composedMessageHiddenInput.setAttribute("name", originalName);
        }

        if(el.innerHTML == "") {
            MM.clearComposedMessage();
        }
    },
    /*save unsent messages*/

    /*TabCollection*/
    tabContainerSelect: function () {

        var tabCollectionContainer = document.querySelector(".tabCollectionContainer");

        //Check if tab collection flow
        if (tabCollectionContainer == null) {
            return;
        }

        //set title text for all tabs here so BE can update the tab heading with a symbolupdate
        var tabs = tabCollectionContainer.children;
        for (i = 0; i < tabs.length; i++) {
            var tabCollectionTab = tabs[i];
            var tabContentID = tabCollectionTab.getAttribute("name");
            var tabContent = document.getElementById(tabContentID);
            if (tabContent != null) {
                tabCollectionTab.innerHTML = tabContent.getAttribute("data-tabTitle");
            }
        }

        if(tabCollectionContainer.getAttribute("data-partialUpdatePreload") == "true"){
            //For preload
            tabCollectionContainer.setAttribute("data-partialUpdatePreload", "false");
            return;
        }else if(tabCollectionContainer.getAttribute("data-partialUpdate") == "true"){
            //After partial update for loadonce show correct tab content
            Root.onImagesLoadedWithCallback(Root.setBodyContentsHeight);
            tabCollectionContainer.setAttribute("data-partialUpdate", "false");
            document.getElementById((tabCollectionContainer.currentSelectedTab.id).replace("tabCollectionTab", "")).style.display = "block";
            return;
        }else if(tabCollectionContainer.setupDone == true){//Partial update happened within a tab triggering MM.Init(). We don't need to do anything to the screen
            document.getElementById((tabCollectionContainer.currentSelectedTab.id).replace("tabCollectionTab", "")).style.display = "block";
            return;
        }

        if(tabCollectionContainer.setupDone == null){//Signal that we have run through setup and don't need to again during updates and tab navigation
            tabCollectionContainer.setupDone = true;
        }

        //We handle caching for this symbol by hiding/showing the display attribute of the element
        var selectedTab = tabCollectionContainer.getAttribute("data-selectedTab");
        var selectedColour = tabCollectionContainer.getAttribute("data-selectedColour");

        MM.tabCollectionOuterContainer();

        document.querySelectorAll(".tabCollectionTab").forEach(function selectStartTab(element) {

            if ((element.id).replace("tabCollectionTab", "") == selectedTab) {
                tabCollectionContainer.currentSelectedTab = element;
                element.style.borderBottomColor = selectedColour;
                element.style.color = selectedColour;

                //Display selected tab content
                document.getElementById(selectedTab).style.display = "block";
            }

        });

        //Send update for tabcontent if preload true and tabcontent empty
        document.querySelectorAll(".tabContent").forEach(function preLoad(tabContent) {

            if (tabContent.childElementCount <= 0 && tabContent.getAttribute("data-preload") == "Y") {

                tabCollectionContainer.setAttribute("data-partialUpdatePreload", "true");
                MM.partialUpdate(tabContent, true);
            }

        });

    },

    tabCollectionOuterContainer: function () {
        var tabCollectionOuterContainer = document.querySelector(".tabCollectionOuterContainer");
        if(tabCollectionOuterContainer != null){
            tabCollectionOuterContainer.style.width = document.getElementById("base-content").clientWidth + "px";
        }
    },

    tabCollectionSwitch: function (currentlySelectedTab) {

        var tabCollectionContainer = document.querySelector(".tabCollectionContainer");
        var unselectedColour = tabCollectionContainer.getAttribute("data-unselectedColour");
        var selectedColour = tabCollectionContainer.getAttribute("data-selectedColour");
        var unselectedTextColour = tabCollectionContainer.getAttribute("data-unselectedTextColour");

        var previouslySelectedTab = document.getElementById((tabCollectionContainer.currentSelectedTab.id).replace("tabContainer", ""));
        var previouslySelectedTabContent = document.getElementById((previouslySelectedTab.id).replace("tabCollectionTab", ""));

        var currentlySelectedTab = document.getElementById((currentlySelectedTab.id).replace("tabContainer", ""));
        var currentlySelectedTabContent = document.getElementById((currentlySelectedTab.id).replace("tabCollectionTab", ""));

        //Change tabs
        previouslySelectedTab.style.borderBottomColor = unselectedColour;
        previouslySelectedTabContent.style.display = "none";
        previouslySelectedTab.style.color = unselectedTextColour;

        currentlySelectedTab.style.borderBottomColor = selectedColour;
        currentlySelectedTabContent.style.display = "block";
        currentlySelectedTab.style.color = selectedColour;

        tabCollectionContainer.currentSelectedTab = currentlySelectedTab;

        //Stop MM from calling tabsetup function again on partial update
        tabCollectionContainer.setAttribute("data-partialUpdate", "true");

        //Check if we need to load/re-load content for current tab
        if ((currentlySelectedTabContent.getAttribute("data-preload") == "N" && currentlySelectedTabContent.childElementCount <= 0) || currentlySelectedTabContent.getAttribute("data-loadOnce") == "N") {

            //delete/hide tab content if any to smooth out update
            currentlySelectedTabContent.style.display = "none";

            MM.partialUpdate(currentlySelectedTabContent, true);

            if (currentlySelectedTabContent.getAttribute("data-loadOnce") == "Y") {
                //Cache tab content
                currentlySelectedTabContent.setAttribute("data-preload", "Y");
            }

        }else{

            //Easy scroller needs to be attached again
            var elements = document.querySelectorAll('[data-scrollable="n"]');
            for (var i = 0; i < elements.length; i++) {
                elements[i].setAttribute("data-scrollable", "y");
            }

            //Sometimes screen heights/widths are changed due to mm.init being called on partial update.
            //Call again when returning to other tabs without updates to make sure screen measurements are correct there as well
            MM.init();
            AttachEasyScroller();
        }

    },
    /*End TabCollection*/

    /*Radial graph*/
    setRadialGraphStyling: function () {

        var radialGraphAreas = document.getElementsByClassName("radialGraphArea");

        if (radialGraphAreas != null) {
            for (var i = 0; i < radialGraphAreas.length; i++) {
                var graphType = radialGraphAreas[i].getAttribute("data-graphType");

                var maxGraphValue = 360;
                var notch;

                if (graphType == "RADIAL") {
                    maxGraphValue = 270;
                    notch = "";
                } else {
                    notch = "black 2deg, ";
                }

                var outerGraph = radialGraphAreas[i].querySelector(".outerGraph");

                //Same logic used for ThreeLineOneRadial radial graph as well
                if(outerGraph == null){
                    outerGraph = radialGraphAreas[i].querySelector(".threeLineOneRadialOuterGraph");
                }

                if (outerGraph != null) {
                    var outerColour = outerGraph.getAttribute("data-colour");
                    var outerBackgoundColour = outerGraph.getAttribute("data-backgoundcolour") != "" ? outerGraph.getAttribute("data-backgoundcolour") : "transparent";
                    var outerEnd = outerGraph.getAttribute("data-end");
                    var outerEndValue = Math.round(parseInt(outerEnd) / 100 * maxGraphValue);
                    outerGraph.style.backgroundImage = "conic-gradient(" + outerColour + " 0 " + outerEndValue.toString() + "deg," + outerBackgoundColour + " 0)";
                }

                var innerGraph = radialGraphAreas[i].querySelector(".innerGraph");

                //Same logic used for ThreeLineOneRadial radial graph as well
                if(innerGraph == null){
                    innerGraph = radialGraphAreas[i].querySelector(".threeLineOneRadialInnerGraph");
                }

                if (innerGraph != null) {
                    var innerColour = innerGraph.getAttribute("data-colour");
                    var innerBackgoundColour = innerGraph.getAttribute("data-backgoundcolour") != "" ? innerGraph.getAttribute("data-backgoundcolour") : "transparent";
                    var innerEnd = innerGraph.getAttribute("data-end");
                    var innerEndValue = Math.round(parseInt(innerEnd) / 100 * maxGraphValue);

                    if(innerEndValue == "0"){
                        notch = "";
                    }

                    innerGraph.style.backgroundImage = "conic-gradient(" + notch + innerColour + " 0 " + innerEndValue.toString() + "deg," + innerBackgoundColour + " 0)";
                }
            }

        }
    },
    /*End Radial graph*/

    /*autoload container */

    /*this function is used to remove any overflow and max-height styling on any child element of an autoloadcontainer*/
    removeStylingForAutoLoadContainer: function () {
        var autoloadContainer = document.getElementsByClassName("autoLoadContainer")[0];
        if (autoloadContainer != null) {
            for (var i = 0; i < autoloadContainer.children.length; i++) {
                autoloadContainer.children[i].classList.add("removeStylingForAutoLoadContainer");
            }
        }
    },

    /*this function looks at the position the user scrolled to,
      if user scrolled to the top/bottom of the container then request for more info*/
    autoLoadContainerUpdate: function (e) {
        var hiddenInput = document.getElementById("hidden_" + e.getAttribute("data-key"));
        var eScrollHeight = e.scrollHeight;
        var eScrollTop = e.scrollTop;

        if (eScrollTop == 0) {
            hiddenInput.value = "UP";
            if (e.getAttribute("data-type") != "UPDATEFE") {
                MM.partialUpdate(e, true);
            }

        } else if (eScrollHeight - eScrollTop <= e.clientHeight + 1) {
            hiddenInput.value = "DOWN";
            if (e.getAttribute("data-type") == "UPDATEFE") {
                if (e.getAttribute("data-justUpdated") == "false") {
                    e.setAttribute("data-justUpdated", "true");
                    hiddenInput.setAttribute("id", e.getAttribute("id"));
                    MM._partialUpdateFrontEnd(hiddenInput, null, true);
                    hiddenInput.setAttribute("id", "hidden_" + e.getAttribute("data-key"));
                } else {
                    e.setAttribute("data-justUpdated", "false");
                }

            } else {
                MM.partialUpdate(e, true);
            }
        }
    },
    /*End autoload container*/

    /*FrontEnd AMI Timer*/
    calculateFrontEndConversationTimerAndNotificationHeight: function () {
        //Set top value for notification and timer based on size of the header

        var frontEndConversationTimer = document.getElementById("frontEndConversationTimer");
        var base = document.getElementById("base-content");

        if (frontEndConversationTimer == null || base == null) {
            return;
        }

        var notification = document.querySelector(".headerToaster");

        if (notification == null) {//No notification display normally
            frontEndConversationTimer.style.top = window.getComputedStyle(base).marginTop;
            frontEndConversationTimer.style.width = window.getComputedStyle(document.querySelector(".baseBody")).width;
        } else {//display below notification

            notification.style.top = window.getComputedStyle(base).marginTop;
            frontEndConversationTimer.style.top = parseFloat(window.getComputedStyle(base).marginTop.replace("px", "")) + parseFloat(window.getComputedStyle(notification).height.replace("px", "")) + "px";
            frontEndConversationTimer.style.width = window.getComputedStyle(document.querySelector(".baseBody")).width;
        }
    },

    frontEndConversationTimer: function () {

        if (document.getElementById("frontEndConversationTimer") == null) {
            return;
        }

        //adding space to cater for the timer being on screen
        if (document.querySelector(".StructuredContainerBody") != null) {
            var structuredContainerBody = document.querySelector(".StructuredContainerBody");
            structuredContainerBody.classList.add("extraPaddingTop");
        }

        var timerInterval;

        timerInterval = setInterval(function () {

            var timerElement = document.getElementById("frontEndConversationTimer");

            //Check if user still in conversation
            if (timerElement == null) {
                clearInterval(timerInterval);
                return;
            }

            var datePast = new Date(parseInt(timerElement.getAttribute("data-time")));
            var dateNow = new Date();

            var seconds = Math.floor(((dateNow) - (datePast)) / 1000);
            var minutes = Math.floor(seconds / 60);
            var hours = Math.floor(minutes / 60);

            var tempTime = "";

            minutes = minutes - (hours * 60);
            seconds = seconds - (hours * 60 * 60) - (minutes * 60);

            seconds = seconds < 10 ? "0" + seconds : seconds;

            if (hours > 0) {

                minutes = minutes < 10 ? "0" + minutes : minutes;
                hours = hours < 10 ? "0" + hours : hours;

                timerElement.children[0].innerText = hours + ":" + minutes + ":" + seconds;

            } else if (minutes > 0) {

                minutes = minutes < 10 ? "0" + minutes : minutes;
                timerElement.children[0].innerText = minutes + ":" + seconds;

            } else {
                timerElement.children[0].innerText = seconds;
            }

        }, 1000);

    },
    /*End FrontEnd AMI Timer*/

    /*FrontEnd Display Notification*/
    frontEndRemoveHeaderNotification: function () {

        if (document.querySelector(".headerToaster") == null) {
            return;
        }

        var headerToasters = document.querySelectorAll(".headerToaster");
        for (var i = 0; i < headerToasters.length; i++) {
            var headerToaster = headerToasters[i];
            var ttl = headerToaster.getAttribute("data-ttl");

            if (ttl != null && ttl != "" && ttl != "0") {
                var timer = setTimeout(function () {

                    //Make sure element is still on page before removal

                    if (document.querySelector(".headerToaster") != null) {
                        headerToaster.parentElement.removeChild(headerToaster);
                        MM.structuredContainerHeaderFooterCalc();
                    }

                }, parseInt(ttl));

                Timers.register(timer);
            }
        }

    },
    /*End FrontEnd Display Notification*/

    /*does all checks on a text area, including fixing the height if BE sends a textArea with text already in it*/
    correctTextAreaSize: function () {
        var textAreas = document.querySelectorAll(".composedMessageTextBoxFull");
        if (textAreas == null || textAreas.length == 0) {
            textAreas = document.querySelectorAll(".composedMessageTextBox");
        }
        for (var i = 0; i < textAreas.length; i++) {
            var textArea = textAreas[i];
            //forced to use replace with regular expressions due to lower version ios not supporting replaceAll
            //avoid <br/> tags in textAreas- make them newlines
            textArea.innerHTML = textArea.innerHTML.replace(MM.convertStringToRegExp("<br/>"),"\n");

            MM.composedMessageApplyRestrictionsAlphaNumericSpecial(textArea);
            MM.switchButtons(textArea);
            MM.charCounter(textArea);
            MM.resetErrorText(textArea);
            MM.composedMessageConstraintsAndResize(textArea);
        }
    },
    /*End correctTextAreaSize*/

    /*remove subtitle text after ttl seconds*/
    removeHeaderSubtitleWithTtl: function () {

        if (document.querySelector(".headerSubtitle") == null) {
            return;
        }

        var headerSubtitle = document.querySelector(".headerSubtitle");
        var ttl = headerSubtitle.getAttribute("data-ttl");

        if (ttl != null && ttl != "" && ttl != "0") {
            var timer = setTimeout(function () {

                //Make sure element is still on page before removal
                if (document.querySelector(".headerSubtitle") != null) {
                    var headerSubtitle = document.querySelector(".headerSubtitle");
                    headerSubtitle.innerHTML = "";
                }
            }, parseInt(ttl));
            Timers.register(timer);
        }
    },
    /*End remove subtitle text after ttl*/

    /*start power Card Create Change Pin Pad*/
    powerCardCreateChangePin: function (element, number) {
        var pinLength = element.getAttribute("data-pinLength");
        var errorMessage = element.getAttribute("data-inLineErrorPinpad");

        var dots = document.getElementById("dots_" + element.id).children;

        var hiddenPin = element.pin1;
        var text = document.getElementById("errorText_" + element.id);

        //clears error text
        if (text.innerHTML != "") {
            text.innerHTML = "";
            text.className = "";
        }

        var confirmingPin = false;  //true means user is confirming the pin
        if (element.pin1 != null && element.pin1.length == pinLength) {
            //Already entered pin for the first time
            hiddenPin = element.pin2;
            confirmingPin = true;
        }

        if (hiddenPin == null) {
            hiddenPin = "";
        }

        if ((number === "deleteKey") && (hiddenPin.length >= 0)) {
            //user clicked backspace and there is something to delete
            hiddenPin = hiddenPin.slice(0, hiddenPin.length - 1);
            dots[hiddenPin.length].style.opacity = "0.2";

            if (confirmingPin)
                element.pin2 = hiddenPin;
            else
                element.pin1 = hiddenPin;

        } else if (hiddenPin.length >= 0 && hiddenPin.length < pinLength) {
            //user clicked a number
            hiddenPin = hiddenPin.concat(number);
            dots[hiddenPin.length - 1].style.opacity = "1";

            if (confirmingPin)
                element.pin2 = hiddenPin;
            else
                element.pin1 = hiddenPin;

            if (hiddenPin.length == pinLength) {
                //reached pin length

                if (confirmingPin) {
                    //reached pin length when confirming

                    if (element.pin1 == element.pin2) {
                        MM.encryptPowerCardPin(element, element.pin1);
                    } else {
                        //pins do not match so confirm again
                        for (var i = 0; i < pinLength; i++) {
                            dots[i].style.opacity = "0.2";
                        }

                        text.innerHTML = errorMessage;
                        text.className = "powerCardPin_errorText";
                        element.pin2 = "";
                    }
                } else {
                    //reached pin length first time
                    var instructionText = document.getElementById("ChangePinInstructionArea");
                    instructionText.innerHTML = element.getAttribute("data-confirmInstructionText");

                    for (var i = 0; i < pinLength; i++) {
                        dots[i].style.opacity = "0.2";
                    }
                }
            }
        }
    },

    encryptPowerCardPin: function (element, clearPin) {
        var submitUiid = element.getAttribute("data-submitUiid");
        var publicKey = element.getAttribute("data-publicKey");
        var publicKeyAuthId = element.getAttribute("data-publicKeyAuthId");
        var pan = element.getAttribute("data-pan");
        var sdkErrorMessage = element.getAttribute("data-sdkErrorMessage");

        if (submitUiid == "" || publicKey == "" || publicKeyAuthId == "" || pan == "") {
            console.log("Error trying to change pin (data missing)");
            var text = document.getElementById("errorText_" + element.id);
            text.innerHTML = sdkErrorMessage;
            text.className = "powerCardPin_errorText";
            return;
        }

        try {
            var publicKeyJson = {"id": publicKeyAuthId, "publicKey": publicKey};
            var localKey = keystone.generateLocalKey({
                onetimekey: publicKeyJson,
                keyType: "des"
            });

            var encrypted = keystone.encryptPin({pin: clearPin, key: localKey, pan: pan});

            var localKeyZPKEl = document.createElement("input");
            localKeyZPKEl.setAttribute("type", "hidden");
            localKeyZPKEl.setAttribute("value", encrypted.encryptedZPK);
            localKeyZPKEl.setAttribute("name", "localkeyzpk");
            element.appendChild(localKeyZPKEl);

            var pinBlockFormatEl = document.createElement("input");
            pinBlockFormatEl.setAttribute("type", "hidden");
            pinBlockFormatEl.setAttribute("value", encrypted.format);
            pinBlockFormatEl.setAttribute("name", "pinblockformat");
            element.appendChild(pinBlockFormatEl);

            var pinBlockDataEl = document.createElement("input");
            pinBlockDataEl.setAttribute("type", "hidden");
            pinBlockDataEl.setAttribute("value", encrypted.EncryptedPinblock);
            pinBlockDataEl.setAttribute("name", "pinblockdata");
            element.appendChild(pinBlockDataEl);

            var pinBlockPanEl = document.createElement("input");
            pinBlockPanEl.setAttribute("type", "hidden");
            pinBlockPanEl.setAttribute("value", pan);
            pinBlockPanEl.setAttribute("name", "pinblockpan");
            element.appendChild(pinBlockPanEl);

            Form.submit(submitUiid);

        } catch (e) {
            console.log("Error trying to changing pin...");
            var text = document.getElementById("errorText_" + element.id);
            text.innerHTML = sdkErrorMessage;
            text.className = "powerCardPin_errorText";
        }
    },
    /*end power Card Create Change Pin Pad*/

    /*power card view pin decryption process*/
    powerCardViewPin: function () {
        if (document.getElementById("powerCardViewPin") == null) {
            return;
        }

        var viewPinElement = document.getElementById("powerCardViewPin");

        //attributes sent by BE
        var publicKey = viewPinElement.getAttribute("data-publicKey");
        var publicKeyAuthId = viewPinElement.getAttribute("data-publicKeyAuthId");
        var requestType = viewPinElement.getAttribute("data-pinBlockDatasource");
        var sdkErrorMessage = viewPinElement.getAttribute("data-sdkErrorMessage");

        try {
            var publicKeyJson = {"id": publicKeyAuthId, "publicKey": publicKey};

            var localKey = keystone.generateLocalKey({
                onetimekey: publicKeyJson,
                keyType: "des"
            });

            viewPinElement.data = localKey;

            var localKeyZPK = btoa(String.fromCharCode.apply(null, localKey.encryptedKeyData));
            localKeyZPK = encodeURIComponent(localKeyZPK);

            MM.requestPinBlock(publicKey, localKeyZPK, requestType, publicKeyAuthId);
        } catch (Exception) {
            console.log("Error trying to view pin...");
            viewPinElement.innerHTML = sdkErrorMessage;
        }
    },
    /* Start card pin */
    changeCardPin : function(element, number) {
        var pinLength = element.getAttribute("data-pinLength");
        var errorMessage = element.getAttribute("data-inLineErrorPinpad");
        var publicKey = element.getAttribute("data-publicKey");

        var dots = document.getElementById("dots_" + element.id).children;

        var hiddenPin = element.pin1;
        var text = document.getElementById("errorText_" + element.id);

        //clears error text
        if (text.innerHTML != "") {
            text.innerHTML = "";
            text.className = "";
        }

        var confirmingPin = false;  //true means user is confirming the pin
        if (element.pin1 != null && element.pin1.length == pinLength) {
            //Already entered pin for the first time
            hiddenPin = element.pin2;
            confirmingPin = true;
        }

        if (hiddenPin == null) {
            hiddenPin = "";
        }

        if ((number === "deleteKey") && (hiddenPin.length >= 0)) {
            //user clicked backspace and there is something to delete
            hiddenPin = hiddenPin.slice(0, hiddenPin.length - 1);
            dots[hiddenPin.length].style.opacity = "0.2";

            if (confirmingPin) {
                element.pin2 = hiddenPin;
            }
            else {
                element.pin1 = hiddenPin;
            }

        } else if (hiddenPin.length >= 0 && hiddenPin.length < pinLength) {
            //user clicked a number
            hiddenPin = hiddenPin.concat(number);
            dots[hiddenPin.length - 1].style.opacity = "1";

            if (confirmingPin)
                element.pin2 = hiddenPin;
            else
                element.pin1 = hiddenPin;

            if (hiddenPin.length == pinLength) {
                //reached pin length

                if (confirmingPin) {
                    //reached pin length when confirming

                    if (element.pin1 == element.pin2) {
                        var submitUiid = element.getAttribute("data-submitUiid");
                        element.pin1  = SecurityTools.publicKeyInputEncryption(element.pin1 , window.atob(publicKey));
                        hiddenPin = element.pin1;
                        Form.submit(submitUiid);
                    } else {
                        //pins do not match so confirm again
                        for (var i = 0; i < pinLength; i++) {
                            dots[i].style.opacity = "0.2";
                        }

                        text.innerHTML = errorMessage;
                        text.className = "changeCardPin_errorText";
                        element.pin2 = "";
                    }
                } else {
                    //reached pin length first time
                    var instructionText = document.getElementById("cardPinInstructionArea");
                    instructionText.innerHTML = element.getAttribute("data-confirmInstructionText");

                    setTimeout(function () {
                        for (var i = 0; i < pinLength; i++) {
                            dots[i].style.opacity = "0.2";
                        }
                    },1000);

                }
            }
        }

    },
    /* End card pin */

    requestPinBlock: function (publicKey, localKeyZPK, requestType, publicKeyAuthId) {
        Loader.showPartialUpdate(true);
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "/banking/partialMMDataForPin?requestType=" + requestType + "&localkeyzpk=" + localKeyZPK + "&authid=" + publicKeyAuthId);
        xhr.onload = MM.powerCardPinResponseHandler.bind(xhr);
        xhr.send();
    },

    powerCardDecryptPin: function (powerCardPinBlock) {
        var viewPinElement = document.getElementById("powerCardViewPin");
        var sdkErrorMessage = viewPinElement.getAttribute("data-sdkErrorMessage");

        if (powerCardPinBlock.modelresult != "SUCCESS") {
            console.log("Error in response for pinblock...");
            viewPinElement.innerHTML = sdkErrorMessage;
            return;
        }

        try {
            var localKey = viewPinElement.data;
            var pinBlock = {
                "data": powerCardPinBlock.pinblock,
                "format": powerCardPinBlock.format,
                "pan": powerCardPinBlock.pan
            };
            var decryptedPin = keystone.decryptPin({pinblock: pinBlock, key: localKey});
            viewPinElement.innerHTML = decryptedPin;
        } catch (Exception) {
            console.log("Error trying to decrypt pin...");
            viewPinElement.innerHTML = sdkErrorMessage;
        }
    },
    /*End power card view pin decryption process*/

    /*Start image cropper*/
    setCropAttributes: function (input, element, subElementKey, cropStyle, cropSource, doneText) {

        //Possibility of multiple image croppers on one page so using input to uniquely identify each cropper

        var el = input.parentElement;
        var canvasContainer = el.querySelector(".cropImageCanvasContainer");
        var canvas = el.querySelector(".cropImageCanvas");
        var cropImageBackDrop = el.querySelector(".cropImageBackDrop");
        var pillButton = el.querySelector(".cropPillButton");

        if (canvasContainer == null || canvasContainer == "") {
            return;
        }

        MM.setcropCanvasDimensions(el);
        pillButton.innerText = doneText;
        canvasContainer.setAttribute("data-cropStyle", cropStyle);
        cropImageBackDrop.element = element;
        cropImageBackDrop.subElementKey = subElementKey;

        var shape = canvasContainer.getAttribute("data-cropStyle");
        var degrees = parseInt(canvas.getAttribute("data-rotationDegrees"));
        var img = new Image();

        //zoom functionality for non touch devices
        var zoomInOut = function (e) {

            var scale = parseFloat(canvas.getAttribute("data-scale"));
            degrees = parseInt(canvas.getAttribute("data-rotationDegrees"));

            if (e.wheelDelta > 0) {//mouse scroll up (zoom in by factor of 0.2)

                scale = scale + 0.2;
                if (scale > 2) {
                    scale = 2;
                }

                canvas.setAttribute("data-zoomed", "true");
                canvas.setAttribute("data-scale", scale);
                MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

            } else {//mouse scroll down (zoom out by factor of 0.2)

                scale = scale - 0.2;
                if (scale < 0.05) {
                    scale = 0.05;
                }

                canvas.setAttribute("data-zoomed", "true");
                canvas.setAttribute("data-scale", scale);
                MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

            }
        };

        //Once image loaded add events and save image as objectURL
        img.onload = function () {

            // URL.revokeObjectURL(img.src); //no longer needed, free memory
            canvas.addEventListener("mousewheel", zoomInOut);
            MM.cropAddToucheEvents(cropImageBackDrop, canvas, img, shape);
            MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

        };

        img.src = window.URL.createObjectURL(input.files[0]);// set src to blob url
        canvas.img = img;
        canvas.imgBlobUrl = [];
        canvas.imgBlobUrl.push(input.files[0]);
        cropImageBackDrop.fileType = input.files[0].type;
        cropImageBackDrop.inputParent = input.id;

    },

    setcropCanvasDimensions: function (input) {

        var cropImageBackDrop = input.querySelector(".cropImageBackDrop");
        var canvasContainer = input.querySelector(".cropImageCanvasContainer");
        var canvas = input.querySelector(".cropImageCanvas");
        var footer = document.getElementById("footer");

        //Attach to body so that it overlays everything
        document.body.appendChild(cropImageBackDrop);
        //Disable body scroll (scroll is used to zoom in and out on cropper)
        document.body.style.overflow = "hidden";

        cropImageBackDrop.style.display = "block";
        document.getElementById("headerFixed").style.zIndex = "-1";
        document.getElementById("nativeOverlay").style.zIndex = "-1";

        //Important to set height like this as canvas will not render image properly otherwise
        cropImageBackDrop.style.height = "-webkit-fill-available";
        canvas.style.height = "100%";
        canvas.style.width = "100%";
        canvas.height = canvasContainer.clientHeight;
        canvas.width = canvasContainer.clientWidth;

    },

    cropAddToucheEvents: function (canvasContainer, canvas, img, shape) {

        var cropTouchMove;
        var cropTouchEnd;
        var degrees;
        var touches = [];
        var prevDiff = 0;

        var cropTouchDown = function (e) {

            canvasContainer.touchStartY = e.clientY;
            canvasContainer.touchStartX = e.clientX;
            touches.push(e); //store touches

            cropTouchMove = function (ev) {

                if (touches.length < 2) {//user moving image

                    canvasContainer.touchMoveY = ev.clientY;
                    canvasContainer.touchMoveX = ev.clientX;
                    degrees = parseInt(canvas.getAttribute("data-rotationDegrees"));

                    if (canvasContainer.touchMoveY < canvasContainer.touchStartY) {//moving up
                        //move then re-draw image
                        canvas.setAttribute("data-moved", "true");
                        canvas.setAttribute("data-moveDirection", "Up");
                        MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);
                    } else if (canvasContainer.touchMoveY > canvasContainer.touchStartY) {//moving down
                        //move then re-draw image
                        canvas.setAttribute("data-moved", "true");
                        canvas.setAttribute("data-moveDirection", "Down");
                        MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);
                    }

                    if (canvasContainer.touchMoveX < canvasContainer.touchStartX) {//moving left
                        //move then re-draw image
                        canvas.setAttribute("data-moved", "true");
                        canvas.setAttribute("data-moveDirection", "Left");
                        MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);
                    } else if (canvasContainer.touchMoveX > canvasContainer.touchStartX) {//moving right
                        //move then re-draw image
                        canvas.setAttribute("data-moved", "true");
                        canvas.setAttribute("data-moveDirection", "Right");
                        MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);
                    }

                    canvasContainer.touchStartY = ev.clientY;
                    canvasContainer.touchStartX = ev.clientX;

                } else if (touches.length == 2) {//zoom functionality for touch devices (pinching gesture)

                    var scale = parseFloat(canvas.getAttribute("data-scale"));

                    //update array with new event so that it reads the latest X values from the touches
                    for (var i = 0; i < touches.length; i++) {
                        if (ev.pointerId == touches[i].pointerId) {
                            touches[i] = ev;
                            break;
                        }
                    }

                    // Calculate the distance between the two pointers
                    var curDiff = Math.abs(touches[0].clientX - touches[1].clientX);

                    if (prevDiff > 0) {
                        if (curDiff > prevDiff) {//zoom out by factor of 0.01 (touch events get called a lot)

                            //Distance between two pointers has increased
                            scale = scale + 0.01;
                            if (scale > 2) {
                                scale = 2;
                            }

                            canvas.setAttribute("data-scale", scale);
                            MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

                        }
                        if (curDiff < prevDiff) {//zoom in by factor of 0.01

                            //Distance between pointers has decreased
                            scale = scale - 0.01;
                            if (scale < 0.05) {
                                scale = 0.05;
                            }

                            canvas.setAttribute("data-scale", scale);
                            MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

                        }
                    }

                    // Cache the distance for the next move event
                    prevDiff = curDiff;

                }
            };

            cropTouchEnd = function () {
                //reset zoom variables
                touches = [];
                prevDiff = 0;

                canvas.removeEventListener("pointermove", cropTouchMove);
                canvas.removeEventListener("pointerup", cropTouchEnd);
                canvas.removeEventListener("pointerleave", cropTouchEnd);
                canvas.removeEventListener("pointerout", cropTouchEnd);
                canvas.removeEventListener("pointercancel", cropTouchEnd);

                canvas.eventsAdded = false;
            };

            if (canvas.eventsAdded == null || canvas.eventsAdded != true) {
                canvas.addEventListener("pointermove", cropTouchMove);
                canvas.addEventListener("pointerup", cropTouchEnd);
                canvas.addEventListener("pointerleave", cropTouchEnd);
                canvas.addEventListener("pointerout", cropTouchEnd);
                canvas.addEventListener("pointercancel", cropTouchEnd);

                canvas.eventsAdded = true; //Check if events have been added to avoid duplicate events
            }
        };

        canvas.addEventListener("pointerdown", cropTouchDown);
        canvas.pointerDownEventFunction = cropTouchDown;//Keeping function for remove event later

    },

    cropRotateImage: function (el) {

        var cropImageBackDrop = el.parentElement.parentElement;

        var canvas = cropImageBackDrop.querySelector(".cropImageCanvas");
        var canvasContainer = cropImageBackDrop.querySelector(".cropImageCanvasContainer");
        var shape = canvasContainer.getAttribute("data-cropStyle");
        var img = new Image();
        var degrees = parseInt(canvas.getAttribute("data-rotationDegrees")) - 90;

        //reset back to default drawing flow
        canvas.setAttribute("data-moved", "false");

        if (degrees <= -360) {
            degrees = 0;
        }
        canvas.setAttribute("data-rotationDegrees", degrees);
        //canvas.setAttribute("data-scale",1);

        img.onload = function () {

            // URL.revokeObjectURL(img.src); //no longer needed, free memory
            MM.cropSetupCanvasForDrawing(img, shape, degrees, canvasContainer, canvas);

        };

        img.src = window.URL.createObjectURL(new Blob(canvas.imgBlobUrl, {type: "application/zip"})) // set src to blob url

    },

    cropSetupCanvasForDrawing: function (img, shape, degrees, canvasContainer, canvas) {

        var unit = Root.determineVariableUnitNeeded();
        // var canvasContainer = document.querySelector(".cropImageCanvasContainer");

        // var canvas = document.getElementById("cropImageCanvas");
        var context = canvas.getContext("2d");

        var croppedCanvas = document.createElement("canvas");//Canvas that saves final image
        var croppedContext = croppedCanvas.getContext("2d");

        var cropShapeHeight = canvas.height / 2;
        var cropShapeWidth = canvas.width - (6 * unit);

        croppedCanvas.height = canvas.height;
        croppedCanvas.width = canvas.width;
        canvas.croppedCanvas = croppedCanvas;

        //Make sure to clear before drawing
        context.clearRect(0, 0, canvas.width, canvas.height);

        //Setup canvas
        context.globalAlpha = 0.15;//Turn transparency on

        context.save();//save context before rotations
        MM.cropRotateCanvasImage(degrees, canvas, context, img);
        context.restore();//restore context back to pre-rotation

        //Draw crop shape: circle/square
        context.globalAlpha = 1;//Turn transparency off
        context.strokeStyle = window.getComputedStyle(canvasContainer).color;
        context.beginPath();

        if (shape == "SQUARE") {

            context.rect((canvas.width / 2 - cropShapeWidth / 2), (canvas.height / 2 - cropShapeHeight / 2), cropShapeWidth, cropShapeHeight);
            context.stroke();
            context.closePath();
            context.fillStyle = "transparent";
            context.fill();
            context.save();
            MM.cropFinishDrawing(canvas, context, croppedCanvas, croppedContext, img, shape, degrees);
            context.restore();

            //Draw rule of thirds
            MM.cropDrawRuleOfThirds(canvas, context, cropShapeHeight, shape, unit);

        } else if (shape == "ROUND") {

            //x y r startAngle endAngle
            context.arc(canvas.width / 2, canvas.height / 2, cropShapeHeight / 2, 0, 2 * Math.PI);
            context.stroke();
            context.closePath();
            context.fillStyle = "transparent";
            context.fill();
            context.save();
            MM.cropFinishDrawing(canvas, context, croppedCanvas, croppedContext, img, shape, degrees);
            context.restore();

            //Draw rule of thirds
            MM.cropDrawRuleOfThirds(canvas, context, cropShapeHeight, shape, unit);

        } else {//None

            context.rect(0, 0, canvas.width, canvas.height);
            context.stroke();
            context.closePath();
            context.fillStyle = "transparent";
            context.fill();
            context.save();
            MM.cropFinishDrawing(canvas, context, croppedCanvas, croppedContext, img, shape, degrees);
            context.restore();

            //Draw rule of thirds
            MM.cropDrawRuleOfThirds(canvas, context, cropShapeHeight, shape, unit);

        }

    },

    cropDrawRuleOfThirds: function (canvas, context, cropShapeHeight, shape, unit) {
        var margin = 0;

        //Set rule of thirds spacing for each crop style
        if (shape == "SQUARE") {
            margin = unit * 2;
        } else {
            margin = unit * 8;
        }

        //centre = canvas.width/2
        //radius = cropShapeHeight/2
        //one third = cropShapeHeight/2)/3

        //Top horizontal line:
        context.beginPath();
        context.moveTo(((canvas.width / 2 - cropShapeHeight / 2)) + margin, ((canvas.height / 2 - cropShapeHeight / 2) + cropShapeHeight / 3));
        context.lineTo(((canvas.width / 2 + cropShapeHeight / 2)) - margin, (canvas.height / 2 - (cropShapeHeight / 2) + cropShapeHeight / 3));
        context.strokeStyle = window.getComputedStyle(canvas).color;
        context.closePath();
        context.stroke();

        //Bottom horizontal line:
        context.beginPath();
        context.moveTo(((canvas.width / 2 - cropShapeHeight / 2)) + margin, (canvas.height / 2 + cropShapeHeight / 2) - cropShapeHeight / 3);
        context.lineTo(((canvas.width / 2 + cropShapeHeight / 2)) - margin, (canvas.height / 2 + cropShapeHeight / 2) - cropShapeHeight / 3);
        context.strokeStyle = window.getComputedStyle(canvas).color;
        context.closePath();
        context.stroke();

        //Left vertical line:
        context.beginPath();
        context.moveTo((canvas.width / 2 - cropShapeHeight / 2) + cropShapeHeight / 3, ((canvas.height / 2 + cropShapeHeight / 2)) - margin);
        context.lineTo((canvas.width / 2 - cropShapeHeight / 2) + cropShapeHeight / 3, ((canvas.height / 2 - cropShapeHeight / 2)) + margin);
        context.strokeStyle = window.getComputedStyle(canvas).color;
        context.closePath();
        context.stroke();

        //Right vertical line:
        context.beginPath();
        context.moveTo((canvas.width / 2 + cropShapeHeight / 2) - cropShapeHeight / 3, ((canvas.height / 2 + cropShapeHeight / 2)) - margin);
        context.lineTo((canvas.width / 2 + cropShapeHeight / 2) - cropShapeHeight / 3, ((canvas.height / 2 - cropShapeHeight / 2)) + margin);
        context.strokeStyle = window.getComputedStyle(canvas).color;
        context.closePath();
        context.stroke();

    },

    cropRotateCanvasImage: function (degrees, canvas, context, img) {

        if (canvas.getAttribute("data-moved") == "true" && canvas.getAttribute("data-zoomed") != "true") {//Draw moving image

            MM.cropDrawMovedImage(degrees, canvas, context, img);

        } else if (canvas.getAttribute("data-lastDraw") == "true" || canvas.getAttribute("data-zoomed") == "true") {//Draw image with current X Y values

            MM.cropDrawImageWithCurrentXY(degrees, canvas, context, img);

        } else {//Draw image in default position

            MM.cropDrawOriginalPositionImage(degrees, canvas, context, img);

        }

    },

    cropDrawMovedImage: function (degrees, canvas, context, img) {

        var imgX = parseInt(canvas.getAttribute("data-imgX"));
        var imgY = parseInt(canvas.getAttribute("data-imgY"));
        var moveDistance = parseInt(canvas.getAttribute("data-moveDistance"));
        var moveDirection = canvas.getAttribute("data-moveDirection");

        //Origin of movement is dependant on the degrees so x and y have to be changed accordingly
        switch (degrees) {
            case 0:

                switch (moveDirection) {
                    case "Left":
                        imgX = imgX - moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Right":
                        imgX = imgX + moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Up":
                        imgY = imgY - moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Down":
                        imgY = imgY + moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                }

                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -90:

                context.translate(0, canvas.height);
                context.rotate(degrees * Math.PI / 180);

                switch (moveDirection) {
                    case "Left":
                        imgY = imgY - moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Right":
                        imgY = imgY + moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Up":
                        imgX = imgX + moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Down":
                        imgX = imgX - moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                }

                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -180:

                context.translate(canvas.width, canvas.height);
                context.rotate(degrees * Math.PI / 180);

                switch (moveDirection) {
                    case "Left":
                        imgX = imgX + moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Right":
                        imgX = imgX - moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Up":
                        imgY = imgY + moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Down":
                        imgY = imgY - moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                }

                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -270:

                context.translate(canvas.width, 0);
                context.rotate(degrees * Math.PI / 180);

                switch (moveDirection) {
                    case "Left":
                        imgY = imgY + moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Right":
                        imgY = imgY - moveDistance;
                        canvas.setAttribute("data-imgY", imgY);
                        break;
                    case "Up":
                        imgX = imgX - moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                    case "Down":
                        imgX = imgX + moveDistance;
                        canvas.setAttribute("data-imgX", imgX);
                        break;
                }

                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;
        }

    },

    cropDrawOriginalPositionImage: function (degrees, canvas, context, img) {

        //Rotate image if needed, switching height and width accordingly due to origin change
        //x y w h

        switch (degrees) {
            case 0:
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, 0, 0, img.width, img.height);

                //Save x and y for movement
                canvas.setAttribute("data-imgX", 0);
                canvas.setAttribute("data-imgY", 0);

                break;
            case -90:
                context.translate(0, canvas.height);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, 0, 0, img.width, img.height);

                //Save x and y for movement
                canvas.setAttribute("data-imgX", 0);
                canvas.setAttribute("data-imgY", 0);

                break;
            case -180:
                context.translate(canvas.width, canvas.height);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, 0, 0, img.width, img.height);

                //Save x and y for movement
                canvas.setAttribute("data-imgX", 0);
                canvas.setAttribute("data-imgY", 0);

                break;
            case -270:
                context.translate(canvas.width, 0);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, 0, 0, img.width, img.height);

                //Save x and y for movement
                canvas.setAttribute("data-imgX", 0);
                canvas.setAttribute("data-imgY", 0);

                break;
        }
    },

    cropDrawImageWithCurrentXY: function (degrees, canvas, context, img) {

        var imgX = parseInt(canvas.getAttribute("data-imgX"));
        var imgY = parseInt(canvas.getAttribute("data-imgY"));

        switch (degrees) {
            case 0:

                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -90:

                context.translate(0, canvas.height);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -180:

                context.translate(canvas.width, canvas.height);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;

            case -270:

                context.translate(canvas.width, 0);
                context.rotate(degrees * Math.PI / 180);
                context.scale(canvas.getAttribute("data-scale"), canvas.getAttribute("data-scale"));
                context.drawImage(img, imgX, imgY, img.width, img.height);
                break;
        }

    },

    cropFinishDrawing: function (canvas, context, croppedCanvas, croppedContext, img, shape, degrees) {

        var unit = Root.determineVariableUnitNeeded();
        var cropShapeHeight = canvas.height / 2;
        var cropShapeWidth = canvas.width - (6 * unit);

        //Draw cropped image
        context.beginPath();

        if (shape == "SQUARE") {
            context.rect((canvas.width / 2 - cropShapeWidth / 2), (canvas.height / 2 - cropShapeHeight / 2), cropShapeWidth, cropShapeHeight);
        } else if (shape == "ROUND") {
            //x y r startAngle endAngle
            context.arc(canvas.width / 2, canvas.height / 2, cropShapeHeight / 2, 0, 2 * Math.PI);
        } else {
            context.rect(0, 0, canvas.width, canvas.height);
        }

        //Use clip to create a clipping region according to the shape of a circular arc
        context.clip();

        //draw image (image is drawn in clipped region only)
        context.save();//save context before rotations
        MM.cropRotateCanvasImage(degrees, canvas, context, img);
        context.restore();//restore context back to pre-rotation
        canvas.setAttribute("data-zoomed", "false");

    },

    cropDismissPopup: function (el) {

        var cropImageBackDrop = el.parentElement.parentElement;
        var canvas = cropImageBackDrop.querySelector(".cropImageCanvas");

        //Enable scrolling again
        document.body.style.overflow = "";

        //reset attributes and whatever styling took place to display cropper pop up
        cropImageBackDrop.style.display = "none";
        document.getElementById(cropImageBackDrop.inputParent).parentElement.appendChild(cropImageBackDrop);//Place cropper back in nativeFilePicker symbol
        canvas.setAttribute("data-move", "false");
        canvas.setAttribute("data-imgX", 0);
        canvas.setAttribute("data-imgY", 0);
        canvas.setAttribute("data-moveDirection", "");
        canvas.setAttribute("data-rotationDegrees", 0);
        canvas.setAttribute("data-scale", 1);
        canvas.img = null;
        canvas.imgBlobUrl = null;
        canvas.removeEventListener("pointerdown", canvas.pointerDownEventFunction);

        document.getElementById("headerFixed").style.zIndex = "unset";
    },

    cropDone: function (el) {
        var cropImageBackDrop = el.parentElement.parentElement;
        var canvas = cropImageBackDrop.querySelector(".cropImageCanvas");
        var newFile = MM.cropDrawImageToUpload(cropImageBackDrop);

        //Enable scrolling again
        document.body.style.overflow = "";

        //reset attributes and whatever styling took place to display cropper pop up
        // cropImageBackDrop.parentElement.removeChild(cropImageBackDrop);
        cropImageBackDrop.style.display = "none";
        canvas.setAttribute("data-move", "false");
        canvas.setAttribute("data-imgX", 0);
        canvas.setAttribute("data-imgY", 0);
        canvas.setAttribute("data-moveDirection", "");
        canvas.setAttribute("data-rotationDegrees", 0);
        canvas.setAttribute("data-scale", 1);
        canvas.img = null;
        canvas.imgBlobUrl = null;
        canvas.removeEventListener("pointerdown", canvas.pointerDownEventFunction);

        document.getElementById("headerFixed").style.zIndex = "unset";
        document.getElementById("nativeOverlay").style.zIndex = "100";

        MM.uploadFilesNative(cropImageBackDrop.element, cropImageBackDrop.subElementKey, true, newFile);
    },

    cropDrawImageToUpload: function (cropImageBackDrop) {

        var unit = Root.determineVariableUnitNeeded();
        var canvasContainer = cropImageBackDrop.querySelector(".cropImageCanvasContainer");
        var shape = canvasContainer.getAttribute("data-cropStyle");
        var canvas = cropImageBackDrop.querySelector(".cropImageCanvas");
        var croppedCanvas = canvas.croppedCanvas;
        var croppedContext = croppedCanvas.getContext("2d");
        var cropShapeHeight = canvas.height / 2;
        var cropShapeWidth = canvas.width - (6 * unit);
        var degrees = parseInt(canvas.getAttribute("data-rotationDegrees"));
        var img = canvas.img;

        //Draw final cropped image for upload
        //Draw circle
        croppedContext.globalAlpha = 1;//Turn transparency off
        croppedContext.strokeStyle = "transparent";
        croppedContext.beginPath();

        if (shape == "SQUARE") {
            croppedContext.rect((canvas.width / 2 - cropShapeWidth / 2), (canvas.height / 2 - cropShapeHeight / 2), cropShapeWidth, cropShapeHeight);
        } else if (shape == "ROUND") {
            //x y r startAngle endAngle
            croppedContext.arc(75, canvas.height / 2, cropShapeHeight / 2, 0, 2 * Math.PI);
        } else {
            croppedContext.rect(0, 0, canvas.width, canvas.height);
        }

        croppedContext.stroke();
        croppedContext.closePath();
        croppedContext.fillStyle = "transparent";
        croppedContext.fill();

        //Draw cropped image
        croppedContext.beginPath();
        if (shape == "SQUARE") {
            croppedContext.rect((canvas.width / 2 - cropShapeWidth / 2), (canvas.height / 2 - cropShapeHeight / 2), cropShapeWidth, cropShapeHeight);
        } else if (shape == "ROUND") {
            //x y r startAngle endAngle
            croppedContext.arc(canvas.width / 2, canvas.height / 2, cropShapeHeight / 2, 0, 2 * Math.PI);
        } else {
            croppedContext.rect(0, 0, canvas.width, canvas.height);
        }

        //Use clip to create a clipping region according to the shape of a circular arc/square
        croppedContext.clip();
        croppedContext.save();//save context before rotations
        croppedCanvas.setAttribute("data-scale", canvas.getAttribute("data-scale"));
        croppedCanvas.setAttribute("data-imgX", canvas.getAttribute("data-imgX"));
        croppedCanvas.setAttribute("data-imgY", canvas.getAttribute("data-imgY"));
        croppedCanvas.setAttribute("data-moveDistance", canvas.getAttribute("data-moveDistance"));
        croppedCanvas.setAttribute("data-moveDirection", canvas.getAttribute("data-moveDirection"));
        croppedCanvas.setAttribute("data-moved", canvas.getAttribute("data-moved"));
        croppedCanvas.setAttribute("data-lastDraw", "true");
        MM.cropRotateCanvasImage(degrees, croppedCanvas, croppedContext, img);
        croppedContext.restore();//restore context back to pre-rotation

        // convert DataURL to a blob then to a file then save new file for upload
        var croppedDataURL = croppedCanvas.toDataURL(cropImageBackDrop.fileType);

        var byteString = atob(croppedDataURL.split(',')[1]);

        var arrayBuffer = new ArrayBuffer(byteString.length);
        var uint8Array = new Uint8Array(arrayBuffer);

        for (var i = 0; i < byteString.length; i++) {
            uint8Array[i] = byteString.charCodeAt(i);
        }

        var blob = new Blob([arrayBuffer], {type: cropImageBackDrop.fileType});

        return cropImageBackDrop.fileArray = [new File([blob], "croppedImage." + cropImageBackDrop.fileType.split("/")[1], {type: cropImageBackDrop.fileType})];

    },
    /*End image cropper*/

    /*start taglist actions*/
    taglistAction: function (currentTagEl, parentEl) {

        var type = parentEl.getAttribute("data-type");

        if (type != "" && type != "NONE") {
            if (type == "SUBMIT") {

                var tags = "";

                for (var i = 0; i < parentEl.children.length; i++) {
                    var tag = parentEl.children[i];
                    tags += tag.getAttribute("data-id") + ":" + tag.getAttribute("data-selected");

                    if (i != parentEl.children.length - 1)
                        tags += ",";
                }

                var tagsEl = document.createElement("input");
                tagsEl.setAttribute("type", "hidden");
                tagsEl.setAttribute("value", tags);
                tagsEl.setAttribute("name", parentEl.getAttribute("data-id"));
                parentEl.appendChild(tagsEl);

                var submitUiid = parentEl.getAttribute("data-submitUiid");
                Form.submit(submitUiid);
            }
        }
        return;
    },
    /*end taglist action*/

    /*Start Three Panel*/
    FullScreenPanelContainer: function () {
        if (document.querySelector(".panelContainer") != null) {
            MM.fullscreenPanel();
        }
    },

    fullscreenPanel: function () {
        var baseContent = document.getElementById("base-content");

        //If in iframe (embedded)
        if(self != top){
            Util.removeClass(baseContent, 'baseBody');
        }

        Util.addClass(baseContent, 'baseBodyThreePanel');
        if(document.getElementById("footer") != null){
            Util.addClass(document.getElementById("footer"), 'footerThreePanel');
        }

        MM.centreThreePanel();
    },

    centreThreePanel: function () {
        var panelContainer = document.querySelector(".panelContainer");
        var baseContent = document.getElementById("base-content");

        if (window.matchMedia("(min-width: 601px)").matches) {
            panelContainer.style.height = "calc(" + baseContent.clientHeight + "px - " + "(" + window.getComputedStyle(baseContent).paddingTop + " + " + window.getComputedStyle(baseContent).paddingBottom + "))";
        }else{
            panelContainer.setAttribute("style", "");
        }
    },
    /*End Three Panel*/

    inputEncrypt: function (value, publicKeyData) {
        var publicKey = publicKeyData;
        var input = value;
        encryptedCardNumber = SecurityTools.publicKeyInputEncryption(input, publicKey);
        return encryptedCardNumber;
    },

    /*selectable readout symbol created for messaging enhancements*/
    handleSelectableReadout: function (e) {
        var tickAreaDiv = e.querySelector(".tickArea");

        if (tickAreaDiv == null) {
            return;
        }

        var paragraph = document.getElementById(e.getAttribute("data-paragraphId"));
        var hiddenInput = document.getElementById(e.getAttribute("data-hiddenInputId"));
        var selecting = false;

        if (window.getComputedStyle(tickAreaDiv).display == "none") {
            tickAreaDiv.style.display = "grid";
            hiddenInput.setAttribute("value", "Y");
            selecting = true;
        } else {
            tickAreaDiv.style.display = "none";
            hiddenInput.setAttribute("value", "N");
        }

        var keyTextPair = paragraph.keyTextPair;
        if (keyTextPair == null) {
            keyTextPair = new Object();
            keyTextPair.texts = [];
            keyTextPair.ids = [];
            paragraph.numberSelected = 0;
            paragraph.style.paddingTop = "calc(2 * var(--unit))";
        }

        //selecting and no. already selected < max no. for selection
        if (selecting && paragraph.numberSelected < parseInt(e.getAttribute("data-maxSelection"))) {
            keyTextPair.texts.push(e.getAttribute("data-rightTopText"));
            keyTextPair.ids.push(e.getAttribute("data-id"));
            paragraph.numberSelected = paragraph.numberSelected + 1;

            //first item selected
            if (paragraph.numberSelected == 1) {
                if (document.querySelector(".right_button_container") != null) {
                    var rightButtonContainer = document.querySelector(".right_button_container");
                    rightButtonContainer.style.display = "";
                } else if (document.querySelector(".right_button_container_online") != null) {
                    var rightButtonContainer = document.querySelector(".right_button_container_online");
                    rightButtonContainer.style.display = "";
                }
                paragraph.style.display = "";
            }

            MM._partialUpdateFrontEnd(e, null, null);

        } else if (selecting && paragraph.numberSelected == parseInt(e.getAttribute("data-maxSelection"))) {
            //already selected max, send update to FE
            MM._partialUpdateFrontEnd(e, null, null);
            tickAreaDiv.style.display = "none";
            hiddenInput.setAttribute("value", "N");

        } else if (!selecting) {
            //unselecting
            var index = 0;

            keyTextPair.ids.forEach(function removeFromArray(element) {

                if (element == e.getAttribute("data-id")) {
                    keyTextPair.texts.splice(index, 1);
                    keyTextPair.ids.splice(index, 1);
                    paragraph.numberSelected = paragraph.numberSelected - 1;

                    //last item unselected
                    if (paragraph.numberSelected == 0) {
                        if (document.querySelector(".right_button_container") != null) {
                            var rightButtonContainer = document.querySelector(".right_button_container");
                            rightButtonContainer.style.display = "none";
                        } else if (document.querySelector(".right_button_container_online") != null) {
                            var rightButtonContainer = document.querySelector(".right_button_container_online");
                            rightButtonContainer.style.display = "none";
                        }
                        paragraph.style.display = "none";
                    }

                    MM._partialUpdateFrontEnd(e, null, null);
                }
                index++;
            });
        }

        paragraph.keyTextPair = keyTextPair;

        /*display*/
        var textToDisplay = "";
        var counter = 0;
        keyTextPair.texts.forEach(function addToText(element) {

            counter++;
            textToDisplay += element;

            if (counter < keyTextPair.texts.length) {
                textToDisplay += ", ";
            }
        });

        paragraph.children[0].innerHTML = textToDisplay;

    },
    /*end selectable readout */

    /*used for selectable readout to disable Right Button Before Selection*/
    disableRightButtonBeforeSelection: function () {

        if (document.querySelector(".selectableReadoutWrapper") == null)
            return;

        var firstSelectableReadout = document.querySelector(".selectableReadoutWrapper");
        var paragraph = document.getElementById(firstSelectableReadout.getAttribute("data-paragraphId"));

        //loading first time
        if (paragraph.keyTextPair == null) {
            if (document.querySelector(".right_button_container") != null) {
                var rightButtonContainer = document.querySelector(".right_button_container");
                rightButtonContainer.style.display = "none";
            } else if (document.querySelector(".right_button_container_online") != null) {
                var rightButtonContainer = document.querySelector(".right_button_container_online");
                rightButtonContainer.style.display = "none";
            }

            var keyTextPair = new Object();
            keyTextPair.texts = [];
            keyTextPair.ids = [];

            paragraph.numberSelected = 0;
            paragraph.keyTextPair = keyTextPair;
            paragraph.style.display = "none";

            paragraph.children[0].style.background = getComputedStyle(document.documentElement).getPropertyValue("--PRIMARY_LIGHT");
            paragraph.children[0].style.paddingTop = "calc(2 * var(--unit))";

            var elements = document.querySelectorAll(".selectableReadoutWrapper");
            for (var allElementCount = 0; allElementCount < elements.length; ++allElementCount) {


                var e = elements[allElementCount];

                var tickAreaDiv = e.querySelector(".tickArea");

                if (tickAreaDiv == null) {
                    continue;
                }

                var paragraph = document.getElementById(e.getAttribute("data-paragraphId"));
                var hiddenInput = document.getElementById(e.getAttribute("data-hiddenInputId"));

                if (hiddenInput.getAttribute("value") == "Y") {
                    keyTextPair.texts.push(e.getAttribute("data-rightTopText"));
                    keyTextPair.ids.push(e.getAttribute("data-id"));
                    paragraph.numberSelected = paragraph.numberSelected + 1;
                }
            }

            paragraph.keyTextPair = keyTextPair;

            /*display*/
            var textToDisplay = "";
            var counter = 0;
            keyTextPair.texts.forEach(function addToText(element) {

                counter++;
                textToDisplay += element;

                if (counter < keyTextPair.texts.length) {
                    textToDisplay += ", ";
                }
            });

            paragraph.children[0].innerHTML = textToDisplay;
        }

    },
    /*end used for selectable readout to disable Right Button Before Selection*/

    /*start Image Viewer Carousel*/
    downloadFileWithLink: function (el, downloadLink) {
        var filename = el.getAttribute("data-filename");
        var fileType = filename.substring(filename.lastIndexOf(".") + 1);

        //All other file types except image file types remain download on click
        if (MM.fileIsImage(fileType) == false) {
            window.open(downloadLink);
        }
    },

    setupImageViewerCarousel: function () {
        var elements = document.querySelectorAll(".imageViewFileAttributes");
        var imageViewCarousel = document.getElementById("imageViewCarousel");

        if (elements != null && elements.length > 0) {
            var imageCounter = imageViewCarousel.childElementCount;

            for (var count = 0; count < elements.length; ++count) {
                var alreadyAddedToCarousel = elements[count].getAttribute("data-alreadyAddedToCarousel");

                if (alreadyAddedToCarousel !== "true") {
                    var filename = elements[count].getAttribute("data-filename");
                    var fileType = filename.substring(filename.lastIndexOf(".") + 1);

                    //Add image to carousel
                    if (MM.fileIsImage(fileType)) {
                        var image = document.createElement("IMG");

                        //Save order for animation maths
                        elements[count].setAttribute("name", "imageViewFile" + imageCounter);
                        elements[count].order = imageCounter;
                        imageCounter++;

                        image.classList.add("imageInView");
                        image.src = elements[count].getAttribute("data-downloadLink");
                        imageViewCarousel.appendChild(image);
                        elements[count].setAttribute("data-alreadyAddedToCarousel", "true");
                    }

                }
            }

            //Save imageWidth and counter for animation maths (each image is 100% of the screen and 100% of base-content for UFF)
            imageViewCarousel.imageCounter = imageCounter - 1; //we start at 0
            imageViewCarousel.imageWidth = document.body.clientWidth;
            imageViewCarousel.style.gridTemplateColumns = "repeat(" + imageCounter + " , " + imageViewCarousel.imageWidth + "px)";

            //Set up animation
            imageViewCarousel.addEventListener("pointerdown", function (ev) {

                var x = ev.clientX;
                var movement = 4; //Speed and sensitivity of movement animation
                var threshold = 150; //required min distance traveled to be considered swipe
                var allowedTime = 3000; // maximum time allowed to travel that distance
                var startTime = new Date().getTime(); // save first touch time
                var xStart = x; // save first touch x position
                var moveDirection = "";
                var xM = 0;// New x value during movement

                var onTouchMoveHandler = function (eve) {

                    //Prevent scrolling
                    eve.preventDefault();

                    xM = eve.clientX;

                    if ((xM < x)){//Swiping left
                        x = xM;
                        moveDirection = "left";

                        var currentPos = parseFloat(imageViewCarousel.getAttribute("data-swipePos"));
                        var finalPos = currentPos - movement;
                        var carouselWidth = imageViewCarousel.imageCounter * imageViewCarousel.imageWidth;
                        var rightOrder = imageViewCarousel.currentImageOrder + 1 > imageCounter ? imageCounter : imageViewCarousel.currentImageOrder + 1;
                        var rightImagePos = rightOrder * imageViewCarousel.imageWidth;

                        //Switch all position values to negatives (animation is from 0 to -value)
                        rightImagePos *= -1;
                        imageViewCarousel.setAttribute("data-swipePos", finalPos);

                        //Stop any animating outside of end points
                        if (finalPos <= (carouselWidth * -1)) {
                            imageViewCarousel.style.transform = "translate3d(" + (carouselWidth * -1) + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", (carouselWidth * -1));
                        } else if (finalPos >= 0) {
                            imageViewCarousel.style.transform = "translate3d(" + 0 + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", 0);
                        } else if(finalPos <= rightImagePos){
                            imageViewCarousel.style.transform = "translate3d(" + rightImagePos + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", rightImagePos);
                        }else {
                            imageViewCarousel.style.transform = "translate3d(" + finalPos + "px, 0px,0) scale(1)";
                        }

                    } else {//Swiping right
                        x = xM;
                        moveDirection = "right";

                        var currentPos = parseFloat(imageViewCarousel.getAttribute("data-swipePos"));
                        var finalPos = currentPos + movement;
                        var carouselWidth = imageViewCarousel.imageCounter * imageViewCarousel.imageWidth;
                        var leftOrder = imageViewCarousel.currentImageOrder - 1 > 0 ? imageViewCarousel.currentImageOrder - 1 : 0;
                        var leftImagePos = leftOrder * imageViewCarousel.imageWidth;

                        //Switch all position values to negatives (animation is from 0 to -value)
                        leftImagePos *= -1;
                        imageViewCarousel.setAttribute("data-swipePos", finalPos);

                        //Stop any animating outside of end points
                        if (finalPos <= (carouselWidth * -1)) {
                            imageViewCarousel.style.transform = "translate3d(" + (carouselWidth * -1) + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", (carouselWidth * -1));
                        } else if (finalPos >= 0) {
                            imageViewCarousel.style.transform = "translate3d(" + 0 + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", 0);
                        } else if(finalPos >= leftImagePos){
                            imageViewCarousel.style.transform = "translate3d(" + leftImagePos + "px, 0px,0) scale(1)";
                            imageViewCarousel.setAttribute("data-swipePos", leftImagePos);
                        }  else {
                            imageViewCarousel.style.transform = "translate3d(" + finalPos + "px, 0px,0) scale(1)";
                        }

                    }
                };

                var onTouchEndHandler = function (ev) {
                    var imageCounter = imageViewCarousel.imageCounter;
                    var currentPos = parseFloat(imageViewCarousel.getAttribute("data-swipePos"));

                    var leftOrder = imageViewCarousel.currentImageOrder - 1 > 0 ? imageViewCarousel.currentImageOrder - 1 : 0;
                    var currentOrder = imageViewCarousel.currentImageOrder;
                    var rightOrder = imageViewCarousel.currentImageOrder + 1 > imageCounter ? imageCounter : imageViewCarousel.currentImageOrder + 1;

                    var leftImagePos = leftOrder * imageViewCarousel.imageWidth;
                    var currentImagePos = currentOrder * imageViewCarousel.imageWidth;
                    var rightImagePos = rightOrder * imageViewCarousel.imageWidth;

                    var midLeft = (leftImagePos + currentImagePos)/ 2;
                    var midRight = (rightImagePos + currentImagePos)/ 2;

                    //Switch all position values to negatives (animation is from 0 to -value)
                    leftImagePos *= -1;
                    currentImagePos *= -1;
                    rightImagePos *= -1;

                    //Check if user swiped and animate accordingly
                    var dist = 0;
                    var elapsedTime = new Date().getTime() - startTime; // get time elapsed
                    var swiped = false;

                    //Subtract accordingly so as to not end up with a negative value
                    if(moveDirection == "right"){
                        dist = xM - xStart; // get total dist traveled by finger
                    }else if(moveDirection == "left"){
                        dist = xStart - xM; // get total dist traveled by finger
                    }

                    if(elapsedTime <= allowedTime && dist >= threshold){
                        swiped = true;

                        if(moveDirection == "right"){//Go to left image

                            //Swipe if there's an image to swipe to
                            if(imageViewCarousel.currentImageOrder != 0){
                                MM.goToLeftImageInCarousel(imageViewCarousel, leftImagePos);
                            }else{
                                swiped = false;
                            }

                        }else if(moveDirection == "left"){//Go to right image

                            //Swipe if there's an image to swipe to
                            if(imageViewCarousel.currentImageOrder != imageCounter){
                                MM.goToRightImageInCarousel(imageViewCarousel, rightImagePos, imageCounter);
                            }else{
                                swiped = false;
                            }

                        }
                    }

                    //Snap animation (only snap to complete animation and not if user swiped)
                    if(swiped == false){
                        //In between left and current
                        if (currentPos <= leftImagePos && currentPos >= currentImagePos) {

                            var halfwayPoint = midLeft * -1;

                            if (currentPos >= halfwayPoint) { //Go to left image

                                MM.goToLeftImageInCarousel(imageViewCarousel, leftImagePos);

                            } else if (currentPos <= halfwayPoint) { //Stay at image

                                MM.stayCurrentImageInCarousel(imageViewCarousel, currentImagePos, imageCounter);

                            }

                        } else if (currentPos >= rightImagePos && currentPos <= currentImagePos) { //In between current and right

                            var halfwayPoint =  midRight * -1;

                            if (currentPos <= halfwayPoint) { //Go to right image

                                MM.goToRightImageInCarousel(imageViewCarousel, rightImagePos, imageCounter);

                            } else if (currentPos >= halfwayPoint) { //Stay at image

                                MM.stayCurrentImageInCarousel(imageViewCarousel, currentImagePos, imageCounter);

                            }
                        }
                    }

                    //Set forward
                    var file = document.getElementsByName("imageViewFile" + imageViewCarousel.currentImageOrder)[0];
                    var forward = document.querySelector(".messagingHeaderImageViwerCarouselForward");
                    forward.href = file.getAttribute("data-forwardLink");

                    imageViewCarousel.removeEventListener("pointermove", onTouchMoveHandler);
                    window.removeEventListener("pointerup", onTouchEndHandler);
                };

                imageViewCarousel.addEventListener("pointermove", onTouchMoveHandler);
                window.addEventListener("pointerup", onTouchEndHandler);

            });
        }
    },

    goToLeftImageInCarousel: function (imageViewCarousel, leftImagePos) {
        imageViewCarousel.style.transform = "translate3d(" + leftImagePos + "px, 0px,0) scale(1)";
        imageViewCarousel.setAttribute("data-swipePos", leftImagePos);

        //Set order to left image order (one step back)
        if ((imageViewCarousel.currentImageOrder - 1) >= 0) {
            imageViewCarousel.currentImageOrder -= 1;
        }
    },

    stayCurrentImageInCarousel: function (imageViewCarousel, currentImagePos, imageCounter) {
        imageViewCarousel.style.transform = "translate3d(" + currentImagePos + "px, 0px,0) scale(1)";
        imageViewCarousel.setAttribute("data-swipePos", currentImagePos);
    },

    goToRightImageInCarousel: function (imageViewCarousel, rightImagePos, imageCounter) {
        imageViewCarousel.style.transform = "translate3d(" + rightImagePos + "px, 0px,0) scale(1)";
        imageViewCarousel.setAttribute("data-swipePos", rightImagePos);

        //Set order to right image order (one step forward)
        if ((imageViewCarousel.currentImageOrder + 1) <= imageCounter) {
            imageViewCarousel.currentImageOrder += 1;
        }
    },

    ReSetupImageViewerCarousel: function () {
        var imageViewCarousel = document.getElementById("imageViewCarousel");

        if(imageViewCarousel != null){
            if(imageViewCarousel.downloaded != true){
                imageViewCarousel.imageWidth = document.body.clientWidth;
                imageViewCarousel.style.gridTemplateColumns = "repeat(" + (imageViewCarousel.imageCounter + 1) + " , " + imageViewCarousel.imageWidth + "px)";

                //Reset animations
                imageViewCarousel.currentImageOrder = 0;
                imageViewCarousel.setAttribute("data-swipePos", 0);
                imageViewCarousel.style.transform = "translate3d(" + 0 + "px, 0px,0) scale(1)";
            }
            imageViewCarousel.downloaded = false;
        }

    },

    fileIsImage: function (fileType) {
        var imageTypes = ["png", "jpg", "jpeg", "bmp", "PNG", "JPG", "JPEG", "BMP"];
        return imageTypes.includes(fileType);
    },

    showImageViewerCarousel: function (el) {
        var filename = el.getAttribute("data-filename");
        var fileType = filename.substring(filename.lastIndexOf(".") + 1);

        //making sure filetype is an image to display in carousel
        if (MM.fileIsImage(fileType)) {
            var imageViewerWrapper = document.querySelector(".imageViewerWrapper");
            var headerToolbar = document.querySelector(".messagingHeaderOptions");
            var finalPos = 0;
            var imageViewCarousel = document.getElementById("imageViewCarousel");
            var forward = document.querySelector(".messagingHeaderImageViwerCarouselForward");

            imageViewerWrapper.style.display = "grid";

            //Set header options
            MM.setHeaderToolbarForImageViewerCarousel("ADD", el);

            //Header animation
            headerToolbar.style.display = "grid";
            headerToolbar.style.animation = "phaseIn 0.5s forwards";

            //Animate selected image into view
            finalPos = (imageViewCarousel.imageWidth * el.order) * -1;

            imageViewCarousel.setAttribute("data-swipePos", finalPos);
            imageViewCarousel.currentImageOrder = el.order;
            imageViewCarousel.style.transform = "translate3d(" + finalPos + "px, 0px,0) scale(1)";

            //Set forward
            var file = document.getElementsByName("imageViewFile" + imageViewCarousel.currentImageOrder)[0];
            forward.href = file.getAttribute("data-forwardLink");

        }
    },

    downloadImageFromImageViewer: function () {
        var imageViewCarousel = document.getElementById("imageViewCarousel");
        var file = document.getElementsByName("imageViewFile" + imageViewCarousel.currentImageOrder)[0];
        window.open(file.getAttribute("data-downloadLink"), "_blank");
        imageViewCarousel.downloaded = true;
    },
    /*end Image Viewer Carousel*/

    /*scroll to message replied to*/
    goToOriginalMessage: function (el) {
        if (el != null) {
            var originalMessageBubble = document.getElementById(el.getAttribute("data-originalMessageBubbleId"));

            if (originalMessageBubble != null) {
                originalMessageBubble.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--PRIMARY_LIGHT");
                originalMessageBubble.scrollIntoView();

                setTimeout(function () {
                    var originalMessageBubble = document.getElementById(el.getAttribute("data-originalMessageBubbleId"));
                    originalMessageBubble.style.backgroundColor = "transparent";
                }, 3000);
            }

        }
    },
    /*end scroll to message replied to*/

    /*spinner symbol container*/
    loadSpinnerData: function () {

        if (document.querySelector(".spinnerSymbolContainer") == null)
            return;

        //add popup to body element to use full height of screen
        var popup = document.querySelector(".spinnerSymbolPopup");
        if (popup != null) {
            document.body.appendChild(popup);

            //dynamic maxHeight set for popup
            var baseContentHeight = window.getComputedStyle(document.getElementById("base-content")).height;
            var height = baseContentHeight.substring(0, baseContentHeight.length - 2);
            var popupWrapper = document.querySelector(".popupWrapper");
            popupWrapper.style.maxHeight = (parseInt(height)) + (10 * Root.unit()) + "px";
        }

        //onload of symbol check if slaveData matches selected masterData's  filter and filtertype
        var spinnerSymbolContainer = document.querySelector(".spinnerSymbolContainer");
        var selectedMasterDataDiv = spinnerSymbolContainer.querySelector(".selectedMasterData");
        MM.checkIfSlaveDataIsInMasterFilter(selectedMasterDataDiv.getAttribute("data-key"));

        var selectedSlaveData = document.querySelector(".selectedSlaveData");
        if (selectedSlaveData != null) {
            var selectedSlaveKey = selectedSlaveData.getAttribute("data-key");
            var selectedSlaveDataDiv = document.getElementById(selectedSlaveKey);
            if (selectedSlaveDataDiv != null)
                MM.filterBodyData(selectedSlaveDataDiv);
        }

    },

    displaySpinnerPopup: function (el, displayContent, instructionText) {

        //no data to display in popup
        if (el == null || el.getAttribute("data-key") == null || el.getAttribute("data-key") == '')
            return;

        var popup = document.querySelector(".spinnerSymbolPopup");
        if (popup != null) {
            var popupInstructionText = popup.querySelector(".popupInstructionText");
            popupInstructionText.innerHTML = instructionText;

            popup.style.display = "grid";

            var spinnerSymbolPopupBackdrop = popup.querySelector(".spinnerSymbolPopupBackdrop");
            spinnerSymbolPopupBackdrop.style.animationName = "animation_openSpinnerSymbolBackdrop";

            var popupWrapper = popup.querySelector(".popupWrapper");
            popupWrapper.style.animationName = "animation_openSpinnerSymbolPopup";

            var masterContent = popup.querySelector(".masterDataContents");
            var slaveContent = popup.querySelector(".slaveDataContents");
            var displayContentDiv = null;

            if (displayContent == 'MASTER') {
                masterContent.style.display = "block";
                slaveContent.style.display = "none";
                displayContentDiv = masterContent;
            } else if (displayContent == 'SLAVE') {
                slaveContent.style.display = "block";
                masterContent.style.display = "none";
                displayContentDiv = slaveContent;



                var selectedMasterData = document.querySelector(".selectedMasterData");
                var selectedMasterDataKey = selectedMasterData.getAttribute("data-key");
                var selectedMasterEl = document.getElementById(selectedMasterDataKey);
                var selectedFilter = selectedMasterEl.getAttribute("data-filter");

                if (selectedFilter != null && selectedFilter != "") {
                    //filter is not blank, remove all slave data then display what is needed
                    MM.resetBeforeApplyingFilter(slaveContent, ".readout", "none");
                    MM.filterData(selectedFilter, selectedMasterEl.getAttribute("data-filterType"), displayContentDiv);
                } else {
                    //filter is blank, display everything
                    MM.resetBeforeApplyingFilter(slaveContent, ".readout", "grid");
                }
            }

            //remove footer when displaying popup
            var footer = document.getElementById('footer');
            (footer != null) ? footer.classList.add("hideFooter") : null;
        }
    },

    closeSpinnerPopup: function () {
        var spinnerSymbolPopup = document.querySelector('.spinnerSymbolPopup');

        var spinnerSymbolPopupBackdrop = spinnerSymbolPopup.querySelector(".spinnerSymbolPopupBackdrop");
        spinnerSymbolPopupBackdrop.style.animationName = "animation_closeSpinnerSymbolBackdrop";

        var popupWrapper = spinnerSymbolPopup.querySelector(".popupWrapper");
        popupWrapper.style.animationName = "animation_closeSpinnerSymbolPopup";

        var timerId = setInterval(function () {
            Timers.clearOne(timerId);
            spinnerSymbolPopup.style.display = "none";

        }, 300);
        Timers.register(timerId);

        //display footer when removing popup
        var footer = document.getElementById('footer');
        (footer != null) ? footer.classList.remove("hideFooter") : null;
    },

    resetBeforeApplyingFilter: function (el, className, resetValue) {
        el.querySelectorAll(className).forEach(function (readout) {
            readout.style.display = resetValue;
        });
    },

    selectDataFromPopUp: function (el, classToPopulate, filterData) {

        MM.updateScreenWithSelectedData(el, classToPopulate);
        MM.closeSpinnerPopup();

        //filter slave data
        if (filterData) {
            MM.checkIfSlaveDataIsInMasterFilter(el.getAttribute("data-key"));
            var selectedSlaveData = document.querySelector(".selectedSlaveData");
            if (selectedSlaveData != null) {
                var selectedSlaveKey = selectedSlaveData.getAttribute("data-key");
                var selectedSlaveDataDiv = document.getElementById(selectedSlaveKey);
                if (selectedSlaveDataDiv != null)
                    MM.filterBodyData(selectedSlaveDataDiv);
            }
        }

    },

    filterData: function (filter, filterType, displayContentDiv) {
        //only displays what needs to be displayed
        //filters data according to filterType='IN/OUT/REGEXIN/REGEXOUT'

        if (filterType == "IN") {
            var filterIds = filter.split(',');
            filterIds.forEach(function (id) {
                var readouts = displayContentDiv.querySelectorAll(".readout");
                var found = false;
                for (var i = 0; i < readouts.length && !found; i++) {
                    var readoutId = readouts[i].getAttribute("id");

                    if (id == readoutId) {
                        readouts[i].style.display = "grid";
                        found = true;
                    }
                }
            });
        } else if (filterType == "OUT") {
            var filterIds = filter.split(',');
            var readouts = displayContentDiv.querySelectorAll(".readout");

            for (var i = 0; i < readouts.length; i++) {
                var display = true;
                var readoutId = readouts[i].getAttribute("id");

                filterIds.forEach(function (id) {
                    if (id == readoutId) {
                        display = false;
                    }
                });
                if (display)
                    readouts[i].style.display = "grid";
            }
        } else if (filterType == "REGEXIN") {
            var regExp = new RegExp(filter);

            var readouts = displayContentDiv.querySelectorAll(".readout");

            for (var i = 0; i < readouts.length; i++) {
                var readoutId = readouts[i].getAttribute("id");

                var matchesRegex = regExp.test(readoutId);
                if (matchesRegex)
                    readouts[i].style.display = "grid";

            }

        } else if (filterType == "REGEXOUT") {
            var regExp = new RegExp(filter);
            var readouts = displayContentDiv.querySelectorAll(".readout");

            for (var i = 0; i < readouts.length; i++) {
                var readoutId = readouts[i].getAttribute("id");

                var matchesRegex = regExp.test(readoutId);
                if (!matchesRegex)
                    readouts[i].style.display = "grid";

            }
        }
    },

    //function to check if current selected slaveData matches filter of selected master data
    //if it does not match mater data filter, we autoselect the next possible value that matches from list
    checkIfSlaveDataIsInMasterFilter: function (selectedMasterKey) {

        //master data filter details
        var selectedMasterEl = document.getElementById(selectedMasterKey);
        var filter = selectedMasterEl.getAttribute("data-filter");
        var filterType = selectedMasterEl.getAttribute("data-filterType");

        //currently selected in slave data
        var selectedSlaveData = document.querySelector(".selectedSlaveData");
        if (selectedSlaveData != null) {

            var selectedSlaveKey = selectedSlaveData.getAttribute("data-key");

            if (filterType == "IN") {
                var matchesFilter = false;
                filter.split(',').forEach(function (id) {
                    if (selectedSlaveKey == id)
                        matchesFilter = true;
                });

                if (!matchesFilter) {
                    var readouts = document.querySelector(".slaveDataContents").querySelectorAll(".readout");

                    var idToSelect = null;
                    for (var i = 0; i < readouts.length && idToSelect == null; i++) {

                        var readoutId = readouts[i].getAttribute("id");
                        var inFilter = false;
                        filter.split(',').forEach(function (id) {
                            if (id == readoutId)
                                inFilter = true;
                        });

                        if (inFilter)
                            idToSelect = readoutId;
                    }

                    var elToSelect = document.getElementById(idToSelect);
                    MM.updateScreenWithSelectedData(elToSelect, "selectedSlaveData");
                }
            } else if (filterType == "OUT") {
                var matchesFilter = selectedSlaveKey != "" ? true : false;
                filter.split(',').forEach(function (id) {
                    if (selectedSlaveKey == id)
                        matchesFilter = false;
                });

                if (!matchesFilter) {
                    //get 1st available id thats not part of the filter
                    var readouts = document.querySelector(".slaveDataContents").querySelectorAll(".readout");

                    var idToSelect = null;
                    for (var i = 0; i < readouts.length && idToSelect == null; i++) {

                        var readoutId = readouts[i].getAttribute("id");
                        var inFilter = false;
                        filter.split(',').forEach(function (id) {
                            if (id == readoutId)
                                inFilter = true;
                        });

                        if (!inFilter)
                            idToSelect = readoutId;
                    }

                    var elToSelect = document.getElementById(idToSelect);
                    MM.updateScreenWithSelectedData(elToSelect, "selectedSlaveData");
                }
            } else if (filterType == "REGEXIN") {
                var regExp = new RegExp(filter);
                var matchesFilter = selectedSlaveKey != "" ? regExp.test(selectedSlaveKey) : false;

                if (!matchesFilter) {

                    var idToSelect = null;
                    var readouts = document.querySelector(".slaveDataContents").querySelectorAll(".readout");
                    for (var i = 0; i < readouts.length && idToSelect == null; i++) {
                        var readoutId = readouts[i].getAttribute("id");

                        var matchesRegex = regExp.test(readoutId);
                        if (matchesRegex)
                            idToSelect = readoutId;
                    }

                    var elToSelect = document.getElementById(idToSelect);
                    MM.updateScreenWithSelectedData(elToSelect, "selectedSlaveData");

                }
            } else if (filterType == "REGEXOUT") {
                var regExp = new RegExp(filter);
                var withinRegex = selectedSlaveKey != "" ? regExp.test(selectedSlaveKey) : true;

                if (withinRegex) {
                    //get 1st available id thats not part of the filter
                    var readouts = document.querySelector(".slaveDataContents").querySelectorAll(".readout");

                    var idToSelect = null;
                    for (var i = 0; i < readouts.length && idToSelect == null; i++) {

                        var readoutId = readouts[i].getAttribute("id");
                        var withinRegex = regExp.test(readoutId);

                        if (!withinRegex)
                            idToSelect = readoutId;
                    }

                    var elToSelect = document.getElementById(idToSelect);
                    MM.updateScreenWithSelectedData(elToSelect, "selectedSlaveData");
                }
            }
        }else {
            MM.updateScreenWithSelectedData(null, "selectedSlaveData");
        }
    },

    //display correct data on screen
    updateScreenWithSelectedData: function (el, classToPopulate) {

        var key = "";
        var iconId = "";
        var topText = "";
        var middleText = "";
        var bottomText = "";

        if (el != null) {
            key = el.getAttribute("data-key");
            iconId = el.getAttribute("data-iconId");
            topText = el.getAttribute("data-topText");
            middleText = el.getAttribute("data-middleText");
            bottomText = el.getAttribute("data-bottomText");
        }

        var elToPopulate = document.querySelector("." + classToPopulate);
        elToPopulate != null ? elToPopulate.setAttribute("data-key", key) : null;

        if(elToPopulate != null) {

            var cardImg = elToPopulate.querySelector(".cardImg");
            if (cardImg != null) {
                cardImg.src = iconId;
                iconId != null && iconId != "" ? cardImg.style.display = "" : cardImg.style.display = "none";
            }

            var rightTopText = elToPopulate.querySelector(".rightTopText");
            rightTopText != null ? rightTopText.innerHTML = topText : null;

            var rightMiddleText = elToPopulate.querySelector(".rightMiddleText");
            rightMiddleText != null ? rightMiddleText.innerHTML = middleText : null;

            var rightBottomText = elToPopulate.querySelector(".rightBottomText");
            rightBottomText != null ? rightBottomText.innerHTML = bottomText : null;

            //update hidden input for submit
            var elToPopulate = document.getElementById(classToPopulate);
            elToPopulate.setAttribute("value", key);
        }

        //if no data to display then remove area from screen
        var readoutArea = document.querySelector("." + classToPopulate + "Area");
        if (key != null && key != "")
            readoutArea.style.display = "";
        else
            readoutArea.style.display = "none";

        //filter body data
        MM.filterBodyData(el);

    },

    //filters data according to filterType='IN/OUT/REGEXIN/REGEXOUT'
    filterBodyData: function (elToFilterBy) {

        if(elToFilterBy != null) {

            var filter = elToFilterBy.getAttribute("data-filter");
            var filterType = elToFilterBy.getAttribute("data-filterType");
            var body = document.querySelector(".spinnerSymbolBody");
            if (body != null) {
                var symbols = body.children;
                if (filter != null && filter != "") {
                    //filter is not blank - display what is needs to be displayed
                    if (filterType == "IN") {

                        for (var i = 0; i < symbols.length; i++) {

                            var found = false;
                            var symbolId = symbols[i].getAttribute("id");

                            var filterIds = filter.split(',');
                            filterIds.forEach(function (id) {

                                if (id == symbolId) {
                                    symbols[i].style.display = "";
                                    found = true;
                                }
                            });

                            //symbol not in filter IN so display none
                            if (!found) {
                                var symbol = document.getElementById(symbolId);
                                symbol.style.display = "none";
                            }
                        }

                    } else if (filterType == "OUT") {
                        var filterIds = filter.split(',');

                        for (var i = 0; i < symbols.length; i++) {
                            var display = true;
                            var symbolId = symbols[i].getAttribute("id");

                            filterIds.forEach(function (id) {
                                if (id == symbolId)
                                    display = false;
                            });

                            if (display)
                                symbols[i].style.display = "";
                            else
                                symbols[i].style.display = "none";
                        }
                    } else if (filterType == "REGEXIN") {
                        var regExp = new RegExp(filter);

                        for (var i = 0; i < symbols.length; i++) {
                            var symbolId = symbols[i].getAttribute("id");

                            var matchesRegex = regExp.test(symbolId);
                            if (matchesRegex)
                                symbols[i].style.display = "";
                            else
                                symbols[i].style.display = "none";

                        }

                    } else if (filterType == "REGEXOUT") {
                        var regExp = new RegExp(filter);

                        for (var i = 0; i < symbols.length; i++) {
                            var symbolId = symbols[i].getAttribute("id");

                            var matchesRegex = regExp.test(symbolId);
                            if (!matchesRegex)
                                symbols[i].style.display = "";
                            else
                                symbols[i].style.display = "none";
                        }
                    }
                } else {
                    //filter is blank - display everything
                    for (var i = 0; i < symbols.length; i++) {
                        symbols[i].style.display = "";
                    }
                }
                Root.setBodyContentsHeight();
            }
        }
    },

    /*end spinner symbol container*/

    /*Image wallet*/
    maintainIntrinsicSizeofImageWallet: function () {
        var img = document.querySelector(".imageWalletImageCardHidden");
        var imgWallet = document.querySelector(".imageWalletImageCard");
        var imgWalletPill = document.querySelector(".imageWalletPill");

        //for UFF only
        if(window.matchMedia("(min-width: 500px)").matches){
            if(img != null){

                img.onload = function () {
                    var imgWidth = img.naturalWidth;
                    var imgHeight = img.naturalHeight;

                    imgWallet.style.height = (imgHeight).toString() + "px";
                    imgWallet.style.width = (imgWidth).toString() + "px";

                    imgWalletPill.style.left = (imgWidth/2).toString() + "px";
                };

                img.src = img.getAttribute("data-src");
            }
        }else{
            if(img != null) {
                //Remove inline styling added. Reverting element back to non UFF mobi styling
                imgWallet.style.removeProperty("height");
                imgWallet.style.removeProperty("width");
                imgWalletPill.style.removeProperty("left");
            }
        }
    },
    /*end Image wallet*/

    /*function to copy text from an editable element to a hidden input for submitting*/
    copyToHiddenInput: function (inputsName, value) {
        var hiddenInput = document.getElementsByName(inputsName)[0];
        if (hiddenInput != null) {
            hiddenInput.setAttribute("value", MM.removeHtmlTags(value));
        }
    },

    /*function to convert a plain string into a regular expression*/
    convertStringToRegExp: function (string) {
        return new RegExp(string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
    },
    /*END function to convert a plain string into a regular expression*/

    /*yethu phase 2*/
    //used to hide and show overflow navigation options
    toggleNavigationOptions: function (el) {
        if (el != null) {
            var footer = document.getElementById("footer");
            var parent = el.parentElement.parentElement;
            if (parent != null) {

                var navigationOptionsTemp = parent.children;
                var navigationOptions = Array.from(navigationOptionsTemp);

                var contentBackdropAddAnimationName = "animate_addContentBackdropFromBottom";
                var contentBackdropRemoveAnimationName = "animate_removeContentBackdropFromBottom";

                //navigation options for uff behave differently
                if (window.matchMedia("(min-width: 600px)").matches) {
                    var uffNavigationSidePopup = document.querySelector(".uffNavigationSidePopup");
                    if (uffNavigationSidePopup != null) {
                        var moreOptionsArray = Array.from(uffNavigationSidePopup.children);
                        navigationOptions = navigationOptions.concat(moreOptionsArray);
                        if (uffNavigationSidePopup.style.display == "none" || uffNavigationSidePopup.style.display == "")
                            uffNavigationSidePopup.style.display = "grid";
                        else
                            uffNavigationSidePopup.style.display = "none";
                    }
                    contentBackdropAddAnimationName = "animate_addContentBackdropFromLeft";
                    contentBackdropRemoveAnimationName = "animate_removeContentBackdropFromLeft";
                }

                for (var i = 0; i < navigationOptions.length; i++) {
                    if (navigationOptions[i].tagName != "STYLE") {
                        if (navigationOptions[i].getAttribute("data-overflowOptions") == "true") {
                            if (navigationOptions[i].style.display == "none")
                                navigationOptions[i].style.display = "";
                            else
                                navigationOptions[i].style.display = "none";
                        }

                        var navigationOptionDiv = navigationOptions[i].children[0];
                        if (navigationOptionDiv.getAttribute("data-selected") == "true") {
                            if (navigationOptionDiv.classList.contains("selected")) {
                                navigationOptionDiv.classList.remove("selected");
                                el.classList.add("selected");
                                footer.classList.add("navigationPanel_Open");
                                parent.classList.add("navigationPanel_Open");

                                var contentBackdrop = document.getElementById("contentBackdrop");
                                if (contentBackdrop != null)
                                    contentBackdrop.style.animationName = contentBackdropAddAnimationName;

                            } else {
                                navigationOptionDiv.classList.add("selected");
                                el.classList.remove("selected");
                                footer.classList.remove("navigationPanel_Open");
                                parent.classList.remove("navigationPanel_Open");

                                var contentBackdrop = document.getElementById("contentBackdrop");
                                if (contentBackdrop != null)
                                    contentBackdrop.style.animationName = contentBackdropRemoveAnimationName;
                            }
                        }
                    }
                }
            }
        }
    },

    //moves overflow navigation options into left popup for uff to display differently
    setNavigationOptionsForUff: function () {
        if (document.querySelector(".navigation_panel") == null) {
            return;
        } else {
            if (window.matchMedia("(min-width: 600px)").matches) {
                var uffNavigationSidePopup = document.querySelector(".uffNavigationSidePopup");
                if (uffNavigationSidePopup != null) {
                    var moreNavigationOptions = document.querySelectorAll("[data-overflowOptions='true']");
                    for (i = 0; i < moreNavigationOptions.length; i++) {
                        uffNavigationSidePopup.appendChild(moreNavigationOptions[i]);
                    }
                }
            }
        }
    },
    /*END - navigation*/

    /*set collapsableContainers height for scrolling*/
    setCollapsableContainer: function () {
        var collapsableContainer = document.querySelector(".collapsableContainer");
        if (collapsableContainer == null)
            return;

        var screenHeight = collapsableContainer.getBoundingClientRect().height;
        collapsableContainer.style.height = screenHeight + "px";

        //dynamically set the top value of the action panel based on its header content
        var collapsableContainerHeader = document.querySelector(".collapsableContainerHeader");
        var actionPanelWrapper = document.querySelector(".actionPanelWrapper");
        if (collapsableContainerHeader != null && actionPanelWrapper != null) {
            var headerHeight = window.getComputedStyle(collapsableContainerHeader).height;
            var headerHeightVal = parseFloat(headerHeight.substr(0, headerHeight.length - 2));
            var panelHeight = (headerHeightVal - (7 * Root._unit) > 0 ? headerHeightVal - (7 * Root._unit) : (headerHeightVal - (7 * Root._maxUnit))) + "px;";
            var panelHeightUff = (headerHeightVal - (7 * Root._maxUnit)) + "px !important;";

            var style = document.getElementById("actionPanelTopStyling");
            var addToScreen = false;
            if (style == null) {
                style = document.createElement('style');
                style.type = 'text/css';
                style.id = "actionPanelTopStyling";
                addToScreen = true;
            }

            style.innerHTML = '.actionPanelWrapper.notAttachedToHeader {   top: ' + panelHeight + '  position: absolute; }';
            style.innerHTML += '@media (min-width: 500px) { .actionPanelWrapper.notAttachedToHeader {   top: ' + panelHeightUff + '}}';

            if (addToScreen)
                collapsableContainer.appendChild(style);

        } else if (actionPanelWrapper != null) {
            //default to the top if no header in container
            actionPanelWrapper.classList.add("attachedToHeader");
            actionPanelWrapper.classList.add("centreContentBigScreen");
        }

        var collapsableContainerOnScroll = function () {

            var el = document.getElementById("base-content");
            var actionPanelWrapper = el.querySelector(".actionPanelWrapper");
            var actionPanel = actionPanelWrapper.querySelector(".actionPanel");

            var scrollTop = el.scrollTop;

            var actionPanelTop = actionPanelWrapper.getAttribute("data-originalTop");
            if (actionPanelTop == null || actionPanelTop == '') {
                var actionPanelTopStr = window.getComputedStyle(actionPanelWrapper).top;
                actionPanelTop = actionPanelTopStr.substring(0, actionPanelTopStr.length - 2);
                actionPanelWrapper.setAttribute("data-originalTop", actionPanelTop);
            }
            if (actionPanel.style.animationName != "attachToHeader" && scrollTop - parseFloat(actionPanelTop) >= 0) {
                actionPanelWrapper.classList.remove("notAttachedToHeader");
                actionPanelWrapper.classList.add("attachedToHeader");
                actionPanelWrapper.classList.add("centreContentBigScreen");
                actionPanel.style.animationName = "attachToHeader";

                var panelButtonTexts = actionPanel.querySelectorAll(".panelButtonText");
                for (i = 0; i < panelButtonTexts.length; i++) {
                    panelButtonTexts[i].style.display = "none";
                }

            } else if (actionPanel.style.animationName == "attachToHeader" && scrollTop - parseFloat(actionPanelTop) < 0) {
                actionPanelWrapper.classList.remove("attachedToHeader");
                actionPanelWrapper.classList.remove("centreContentBigScreen");
                actionPanelWrapper.classList.add("notAttachedToHeader");
                actionPanel.style.animationName = "removeFromHeader";

                var panelButtonTexts = actionPanel.querySelectorAll(".panelButtonText");
                for (i = 0; i < panelButtonTexts.length; i++) {
                    panelButtonTexts[i].style.display = "";
                }
            }
        };

        var base = document.getElementById("base-content");
        if(base.getAttribute("data-scrollCollapsableContainer") == null || base.getAttribute("data-scrollCollapsableContainer") == ""){
            base.addEventListener("scroll", collapsableContainerOnScroll);
            base.setAttribute("data-scrollCollapsableContainer", "true");
        }

    },
    /*END - set collapsableContainers height for scrolling*/
    /*END - yethu phase 2*/
    /* Begin time line stories */
    slideIndex : 1,

     changeTimelineStories : function(direction,type) {
         var timeLineStoriesContainer = document.getElementById("timeLineStoriesContainer");
         var leftSwipeUiid = timeLineStoriesContainer.getAttribute("data-leftSwipeUiid");
         var rightSwipeUiid = timeLineStoriesContainer.getAttribute("data-rightSwipeUiid");
         var image = document.getElementsByClassName("myTimelineSlides");
         var storyTextContent = document.getElementsByClassName("storyTextContent");
         if(direction === 'LEFT'){
             if(type === "CLICK") {
                 var progressIDPrev = "progressbar" + (MM.slideIndex);
                 var animateProgressBarPrev = document.getElementById(progressIDPrev);
                 animateProgressBarPrev.removeAttribute("style");
             }
             MM.slideIndex--;
         }else if(direction === 'RIGHT'){
             if(type === "CLICK"){
                 var progressIDPrev = "progressbar" + (MM.slideIndex);
                 var animateProgressBarPrev = document.getElementById(progressIDPrev);
                 animateProgressBarPrev.style.animationDuration = "0.1s";
                 return;
             }
             MM.slideIndex++;
         }
         if (MM.slideIndex > image.length) {
             Form.navigate(rightSwipeUiid);
             return;
         }
         if (MM.slideIndex < 1) {
             Form.navigate(leftSwipeUiid);
             return;
         }
         var progressID = "progressbar" + MM.slideIndex;
         var animateProgressBar = document.getElementById(progressID);
         animateProgressBar.removeAttribute("style");
         void animateProgressBar.offsetWidth;

         var uploadedTimeText = document.getElementById("uploadedTimeText");
         var uploadedTime = animateProgressBar.getAttribute("data-uploadedTime");
         var duration = animateProgressBar.getAttribute("data-progressBarDuration");
         var durationToSeconds = (duration * 0.001);
         uploadedTimeText.innerHTML = uploadedTime;
         animateProgressBar.style.animationFillMode = "forwards";
         animateProgressBar.style.animationName = "progress";
         animateProgressBar.style.animationDuration = durationToSeconds+"s";
         animateProgressBar.style.animationTimingFunction = "linear";
         if (animateProgressBar.getAttribute('data-listener') !== 'true') {
             animateProgressBar.addEventListener('animationstart', function (e) {
                 var animateProgressBarAnimationEnd = e.target;
                 animateProgressBarAnimationEnd.setAttribute('data-listener', 'true');
             });
             animateProgressBar.addEventListener('animationend', function (e) {
                 MM.changeTimelineStories("RIGHT", "ANIMATE");
             });
         }
         for (var i = 0; i < image.length; i++) {
             image[i].style.display = "none";
             storyTextContent[i].style.display = "none";
         }
         image[MM.slideIndex - 1].style.display = "flex";
         storyTextContent[MM.slideIndex - 1].style.display = "block";
    },
    bindTouch : function(){

        var timeLineStoriesContainer = document.getElementById("timeLineStoriesContainer");
        var dataSwipeUpUiidArray = timeLineStoriesContainer.getAttribute("data-swipeUpUuid").split(",");
        var leftSwipeUiid = timeLineStoriesContainer.getAttribute("data-leftSwipeUiid");
        var rightSwipeUiid = timeLineStoriesContainer.getAttribute("data-rightSwipeUiid");
        var downSwipeUiid = timeLineStoriesContainer.getAttribute("data-downSwipeUiid");
        var xDown = null;
        var yDown = null;
        dataSwipeUpUiidArray.pop();
        window.oncontextmenu = function(e) {
            e.preventDefault();
            e.stopPropagation();
        };
        timeLineStoriesContainer.addEventListener('pointerdown', function (e) {
            xDown = e.clientX;
            yDown = e.clientY;
            var progressIDPrev = "progressbar" + (MM.slideIndex);
            var animateProgressBarPrev = document.getElementById(progressIDPrev);
            animateProgressBarPrev.style.animationPlayState = "paused";

        }, false);
        timeLineStoriesContainer.addEventListener('pointermove', function (e) {
            if ( ! xDown || ! yDown ) {
                return;
            }
            var xUp = e.clientX;
            var yUp = e.clientY;
            var xDiff = xDown - xUp;
            var yDiff = yDown - yUp;
            if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {
                if ( xDiff > 0 ) {
                    Form.navigate(leftSwipeUiid);
                } else {
                    Form.navigate(rightSwipeUiid);
                }
            } else {
                if ( yDiff > 0 ) {
                    Form.navigate(dataSwipeUpUiidArray[MM.slideIndex-1]);
                } else {
                    Form.navigate(downSwipeUiid);
                }
            }
            /* reset values */
            xDown = null;
            yDown = null;
        }, false);
        timeLineStoriesContainer.addEventListener('pointerup', function (e) {
            var progressIDPrev = "progressbar" + (MM.slideIndex);
            var animateProgressBarPrev = document.getElementById(progressIDPrev);
            animateProgressBarPrev.style.animationPlayState = "running";

        }, false);
    },
    /*End time line stories */

    /*function to only paste plain text from clipboard / leaves out unnecessary styling when pasting*/
    setPasteListener: function () {
        var editableDiv = document.querySelector('[contentEditable="true"]');
        if (editableDiv != null && editableDiv.getAttribute("pasteListenerAlreadyAdded") != "true") {
            editableDiv.setAttribute("pasteListenerAlreadyAdded", "true");
            editableDiv.addEventListener('paste', function (e) {
                e.preventDefault()
                var text = e.clipboardData.getData('text/plain')
                document.execCommand('insertText', false, text)
            })
        }
    },
    /*END function to only paste plain text from clipboard / leaves out unnecessary styling when pasting*/

    /*function to set listeners for the different ways the user can select text*/
    setListenersForSelectedTextOptions: function () {
        var divsToShowTextToolbar = document.querySelectorAll("[data-showMessagingTextToolbar='true']");
        for (var option = 0; option < divsToShowTextToolbar.length; option++) {
            divsToShowTextToolbar[option].addEventListener('keyup', function () {
                MM.displaySelectedTextToolbar();
            });
            divsToShowTextToolbar[option].addEventListener('touchend', function () {
                MM.displaySelectedTextToolbar();
            });
            divsToShowTextToolbar[option].addEventListener('long-press', function () {
                MM.displaySelectedTextToolbar();
            });
            divsToShowTextToolbar[option].addEventListener('mousedown', function () {
                window.addEventListener('mouseup', displayToolBarMouseup)
            });
        }

        var displayToolBarMouseup = function () {
            MM.displaySelectedTextToolbar();
            window.removeEventListener('mouseup', displayToolBarMouseup);
        };

        //adds toolbar popup to body so it can display above the header when the keyboard is on screen
        var messagingTextToolbar = document.getElementById("messagingTextToolbar");
        if(messagingTextToolbar != null) {
            document.body.appendChild(messagingTextToolbar);
        }

    },
    /*END function to set listeners for the different ways the user can select text*/

    /*function to check if text was selected then display text formatting toolbar*/
    displaySelectedTextToolbar: function () {

        //added deplay before executing code to get correct value from window.getSelection().toString()
        setTimeout(function () {
            var selectedText = "";
            if (typeof window.getSelection != "undefined") {
                selectedText = window.getSelection().toString();
            } else if (typeof document.selection != "undefined" && document.selection.type == "Text") {
                selectedText = document.selection.createRange().text;
            }
            if (selectedText && selectedText.length > 0) {
                var toolbar = document.getElementById("messagingTextToolbar");
                var selection = window.getSelection();
                if (!selection.isCollapsed) {
                    var baseContent = document.getElementById("base-content");
                    var composedMessage = document.querySelector(".composedMessage");
                    toolbar.style.left = 'calc(' + composedMessage.offsetWidth / 2 + "px + " + window.getComputedStyle(baseContent).left + ' - ' + toolbar.offsetWidth / 2 + 'px' + ')';
                    toolbar.style.display = "grid";
                    toolbar.style.top = composedMessage.offsetTop + 40 - toolbar.clientHeight + 'px';
                }
            } else {
                var toolbar = document.getElementById("messagingTextToolbar");
                if (toolbar != null) {
                    toolbar.style.display = "none";
                }
            }
        }, 0.001);
    },
    /*END function to check if text was selected then display text formatting toolbar*/

    /*functions that replace users shortcuts to correct HTML element*/
    textFormatShortCuts: function (el) {
        var key = "";
        var ev = window.event;
        if (ev) {
            key = ev.inputType;
        }

        if (key != 'insertParagraph') { //checks if user clicked enter key
            var caretPosition = MM.getCaretPosFromContentEditableDiv(el);
            MM.checkForGifLinkAndAddToScreen(el);
            var text = el.innerHTML;
            text = text.replace(MM.convertStringToRegExp('<div><br></div>'), "<br>");
            text = text.replace(MM.convertStringToRegExp('<div>'), "<br>");
            text = text.replace(MM.convertStringToRegExp('</div>'), "");
            var allowBackSpacing =  key == 'deleteContentBackward' ? 'true' : 'false';
            el.innerHTML = MM.markUpTextToHtml(text, true, allowBackSpacing);
            MM.moveCaretPosInContentEditableDiv(el, caretPosition);
        }

        MM.composedMessageConstraintsAndResize(el);
        MM.saveText(el);
    },

    checkForGifLinkAndAddToScreen: function (el) {
        var text = el.innerHTML;
        if (text.includes("https://") && text.includes(".gif")) {

            var posHttps = text.indexOf("https://");
            var posGif = text.indexOf(".gif");

            var url = text.substring(posHttps, posGif + 4);
            el.setAttribute("data-gif-url", url);
            text = text.replace(MM.convertStringToRegExp(url), "");
            el.innerHTML = text;

            var displayGif = document.getElementById("displayGif");
            if (displayGif == null) {
                if (el.getAttribute("data-gifUiid") != null) {

                    //create hidden input to submit gifurl selected by user
                    var hiddenInput = document.createElement("input");
                    hiddenInput.setAttribute("type", "hidden");
                    hiddenInput.setAttribute("value", url);
                    hiddenInput.setAttribute("name", "gifUrl");
                    el.parentElement.appendChild(hiddenInput);

                    Form.submit(el.getAttribute("data-gifUiid"));

                }
            } else {
                displayGif.querySelector("img").src = url;
            }
        }
    },

    //makes formatted html into plain text with users shortcuts for submitting
    markDownToPlainText: function (text, allowBackSpacing) {
        var shortcuts = ["*", "_", "~"];
        var openHtmlForShortcut = ["<b>", "<i>", "<s>"];
        var closeHtmlForShortcut = ["</b>", "</i>", "</s>"];

        //forced to use replace with regular expressions due to lower version ios not supporting replaceAll
        text = text.replace(MM.convertStringToRegExp('<span class="textFormatShortcutChar">'), "");
        text = text.replace(MM.convertStringToRegExp('<span style="font-family: monospace;">'), "");
        text = text.replace(MM.convertStringToRegExp('</span>'), "");

        //document.execCommand adds strike tags instead of s tags
        text = text.replace(MM.convertStringToRegExp('<strike>'), '<s>');
        text = text.replace(MM.convertStringToRegExp('</strike>'), '</s>');

        for (k = 0; k < shortcuts.length; k++) {
            if (text.search(openHtmlForShortcut[k]) > -1 && text.search(closeHtmlForShortcut[k]) > -1) {
                text = text.replace(MM.convertStringToRegExp(shortcuts[k] + openHtmlForShortcut[k]), shortcuts[k]);
                text = text.replace(MM.convertStringToRegExp(closeHtmlForShortcut[k] + shortcuts[k]), shortcuts[k]);
                if (allowBackSpacing != "true") {
                    text = text.replace(MM.convertStringToRegExp(openHtmlForShortcut[k]), shortcuts[k]);
                    text = text.replace(MM.convertStringToRegExp(closeHtmlForShortcut[k]), shortcuts[k]);
                }
            }
        }
        return text;
    },

    // marks up plain text with shortcuts to correct html tag
    markUpTextToHtml: function (text, keepShortcut, allowBackSpacing) {
        var shortcuts = ["*", "_", "~"];
        var openHtmlForShortcut = ["<b>", "<i>", "<s>"];
        var closeHtmlForShortcut = ["</b>", "</i>", "</s>"];

        text = MM.markDownToPlainText(text, allowBackSpacing);

        for (k = 0; k < shortcuts.length; k++) {
            var currentText = "";
            for (i = 0; i < text.length; i++) {
                var foundAnother = false;
                if (text[i] == shortcuts[k]) {
                    var tempText = "";
                    var j = i + 1;
                    while (!foundAnother && j < text.length) {
                        if (text[j] == shortcuts[k]) {
                            foundAnother = true;
                            i = j;
                        } else {
                            tempText += text[j];
                            j++;
                        }
                    }
                    if (foundAnother) {
                        var shortcut = keepShortcut ? "<span class='textFormatShortcutChar'>" + shortcuts[k] + "</span>" : "";
                        currentText += shortcut + openHtmlForShortcut[k] + tempText + closeHtmlForShortcut[k] + shortcut;
                    } else {
                        currentText += text[i];
                    }
                } else {
                    currentText += text[i];
                }
            }
            text = currentText;
        }

        //separate loops for monospace because its shortcut has 3 chars
        var monospaceShortCut = "```";
            var currentText = "";
            for (i = 0; i < text.length; i++) {
                var foundAnother = false;
                if (i+2 < text.length && (text[i] + text[i+1] + text[i+2]) == monospaceShortCut) {
                    i += 2;
                    var tempText = "";
                    var j = i + 1;
                    while (!foundAnother && j < text.length) {
                        if (j+2 < text.length && (text[j] + text[j+1] + text[j+2]) == monospaceShortCut) {
                            j+=2;
                            foundAnother = true;
                            i = j;
                        } else {
                            tempText += text[j];
                            j++;
                        }
                    }
                    if (foundAnother) {
                        var shortcut = keepShortcut ? "<span class='textFormatShortcutChar'>" + monospaceShortCut + "</span>" : "";
                        currentText += shortcut + '<span style="font-family: monospace;">' + tempText + '</span>' + shortcut;
                    } else {
                        currentText += monospaceShortCut;
                    }
                } else {
                    currentText += text[i];
                }
            }
            text = currentText;

            //random things that get added along the way in contenteditable div
            text = text.replace(MM.convertStringToRegExp('<font color="#40484a">'), "");
            text = text.replace(MM.convertStringToRegExp('</font>'), "");
        return text;
    },

    //user selects text and clicks on formatting from tool bar
    addTextFormatShortcutKeysAutomatically: function (el, format, textDiv) {
        var caretPosition = MM.getCaretPosFromContentEditableDiv(textDiv);
        caretPosition += 2; //cater for shortcut keys

        document.execCommand(format);
        el.parentElement.style.display = 'none';

        textDiv.innerHTML = MM.markUpTextToHtml(textDiv.innerHTML, true, "false");
        MM.composedMessageConstraintsAndResize(textDiv);
        MM.moveCaretPosInContentEditableDiv(textDiv, caretPosition);
    },
    /*END functions that replace users shortcuts to correct HTML elements*/

    /*function to add monospace formatting correctly using text format toolbar*/
    addMonospaceTextFormatAutomatically: function (el, textDiv) {
        var caretPosition = MM.getCaretPosFromContentEditableDiv(textDiv);
        caretPosition += 6;//cater for shortcut keys (```)

        el.parentElement.style.display = 'none';

        var sel = window.getSelection(); // Gets selection
        if (sel.rangeCount) {

            if(sel.toString() != null && sel.toString().length > 0) {

                // Creates a new element, and insert the selected text with the chosen font inside
                var selectedText = document.createElement('span');
                selectedText.style = "font-family: monospace;";
                selectedText.innerHTML = sel.toString();

                var range = sel.getRangeAt(0);
                range.deleteContents(); // Deletes selected text

                var textFormatShortcutChar = document.createElement('span');
                textFormatShortcutChar.innerHTML = '```';
                textFormatShortcutChar.className = "textFormatShortcutChar";
                range.insertNode(textFormatShortcutChar);

                range.insertNode(selectedText); //inserts the new element at its place

                var textFormatShortcutCharEnd = document.createElement('span');
                textFormatShortcutCharEnd.innerHTML = '```';
                textFormatShortcutCharEnd.className = "textFormatShortcutChar";
                range.insertNode(textFormatShortcutCharEnd);

                textDiv.innerHTML = MM.markUpTextToHtml(textDiv.innerHTML, true, "false");
                MM.composedMessageConstraintsAndResize(textDiv);
                MM.moveCaretPosInContentEditableDiv(textDiv, caretPosition);
            }
        }
    },
    /*END - function to add monospace formatting correctly using text format toolbar*/

    /*function to save text before formatting it to html so that it can be copied later*/
    saveCopyableText: function () {
        var elementsToConvert = document.querySelectorAll("[data-copyable-text='true']");
        elementsToConvert.forEach(function (value) {
            if (value.querySelector("[data-type='EXTERNAL']") != null) {//urldecode adds data-type='EXTERNAL' to links
                var plainText = "";
                value.querySelectorAll("[data-type='EXTERNAL']").forEach(function (element) {
                    plainText += MM.removeHtmlTags(value.querySelector("[data-type='EXTERNAL']").innerHTML) + " ";
                });
                value.setAttribute("data-plainTextWithoutFormatting", plainText);
            } else {
                var text = value.innerHTML;
                text = text.replace(MM.convertStringToRegExp('<span class="messageBubbleHighlightMentionsTextRight">'), "");
                text = text.replace(MM.convertStringToRegExp('</span>'), "");
                value.setAttribute("data-plainTextWithoutFormatting", MM.removeHtmlTags(text));
            }
        });
    },
    /*END- function to save text before formatting it to html so that it can be copied later*/

    /*function that removes text formatting shortcuts and makes it into html for display*/
    markupTextToHTML: function () {
        var elementsToConvert = document.querySelectorAll("[data-convertTextShortcutToHTML='true']");

        if (elementsToConvert.length <= 0) {
            return;
        }

        elementsToConvert.forEach(function (value) {
            if (value.getAttribute("data-formattedToHTMLAlready") != 'true') {
                var text = MM.markUpTextToHtml(value.innerHTML, false);
                value.innerHTML = text;
                value.setAttribute("data-formattedToHTMLAlready", 'true');
            }
        });

    },
    /*END function that removes text formatting shortcuts and makes it into html for display*/

    /*function to place cursor at the end of editable element*/
    placeCaretAtEnd: function (el) {
        el.focus();
        if (typeof window.getSelection != "undefined"
            && typeof document.createRange != "undefined") {
            var range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(false);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        } else if (typeof document.body.createTextRange != "undefined") {
            var textRange = document.body.createTextRange();
            textRange.moveToElementText(el);
            textRange.collapse(false);
            textRange.select();
        }
    },
    /*END function to place cursor at the end of editable element*/

    /*function to find current position of cursor in editable element*/
    getCaretPosFromContentEditableDiv: function (el) {
        var position = 0;
        var isSupported = typeof window.getSelection !== "undefined";
        if (isSupported) {
            var selection = window.getSelection();
            if (selection.rangeCount !== 0) {
                var range = window.getSelection().getRangeAt(0);
                var preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(el);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                return position = preCaretRange.toString().length;
            }
        }
    },
    /*END function to find current position of cursor in editable element*/

    /*function to move cursor to certain position in editable div*/
    moveCaretPosInContentEditableDiv: function (el, pos) {
        // Loop through all child nodes
        for (var node of el.childNodes) {
            if (node.nodeType == 3) { // we have a text node
                if (node.length >= pos) {
                    // finally add our range
                    var range = document.createRange(),
                        sel = window.getSelection();
                    range.setStart(node, pos);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    return -1; // we are done
                } else {
                    pos -= node.length;
                }
            } else {
                pos = MM.moveCaretPosInContentEditableDiv(node, pos);
                if (pos == -1) {
                    return -1; // no need to finish the for loop
                }
            }
        }
        return pos; // needed because of recursion stuff
    },

    /*END function to move cursor to certain position in editable div*/
    generateContactCard : function(cell,company, email,name, surname, work){

        var finalCard = "";
        var beginCard = "BEGIN:VCARD\nVERSION:3.0\n";
        var nameSurname = "N:"+surname+";"+name+";;;\n";
        var firstName = "FN:"+name+surname+"\n";
        var org = "ORG:"+company+"\n";
        var email = "EMAIL;type=INTERNET;type=WORK;type=pref:"+email+"\n";
        var tellCell = "TEL;type=CELL:"+cell+"\n";
        var tellWork = "TEL;type=WORK:"+work+"\n";
        var endCard = "END:VCARD";

        finalCard = beginCard + nameSurname + firstName + email +org+ tellCell+tellWork + endCard;

        var element = document.createElement('a');
        element.setAttribute('href','data:text/vcard;charset=utf-8,' + encodeURIComponent(finalCard));
        element.setAttribute('download', name);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    },

    /*function to markup any shortcuts saved in compose message*/
    markupSavedComposeText: function () {
        var messagingText = document.getElementById("messagingText");
        if(messagingText == null)
            return;

        messagingText.innerHTML = MM.markDownToPlainText(messagingText.innerHTML);
        MM.placeCaretAtEnd(messagingText);
        MM.textFormatShortCuts(messagingText);

    },

    removeHtmlTags: function (text) {
        text = text.replace(MM.convertStringToRegExp('<div><br></div>'), "<br>");
        text = text.replace(MM.convertStringToRegExp('<div>'), "<br>");
        text = text.replace(MM.convertStringToRegExp('</div>'), "");
        text = text.replace(MM.convertStringToRegExp('&nbsp;'), " ");
        text = text.replace(MM.convertStringToRegExp('<br>'), "\n");
        text = text.replace(MM.convertStringToRegExp('<font color="#40484a">'), "");
        text = text.replace(MM.convertStringToRegExp('</font>'), "");
        return text;
    },
    /*END function to markup any shortcuts saved in compose message*/
    dismissPopup : function() {
        var popOverlay = document.querySelector(".popUpBackdrop");
        var popContainer = document.querySelector(".popUpContainer");
        popOverlay.parentElement.removeChild(popOverlay);
        popContainer.parentElement.removeChild(popContainer);
    },

    /* BEGIN social share*/
    //Commented out because POC code
    socialShare : function() {
        var socialShareDataDiv = document.getElementById("socialShareDataDiv");
        var message = socialShareDataDiv.getAttribute("data-message");
        var subject = socialShareDataDiv.getAttribute("data-subject");
        var url = socialShareDataDiv.getAttribute("data-url");
        var errorUiSupport = socialShareDataDiv.getAttribute("data-errorUiSupport");
        var errorUiShare = socialShareDataDiv.getAttribute("data-errorUiShare");
        var shareData = {
            title: subject,
            text: message
           // url: url
        };
        try {
            if(navigator.canShare(shareData)){
                navigator.share(shareData)
                    .then(function () {
                        console.log('MDN shared successfully');
                    })
            }else{
                console.log('MDN shared failed');
                Form.navigate(errorUiShare);
            }

        } catch (err) {
            console.log('Error: ' + err);
            Form.navigate(errorUiSupport);
        }
    },
    /*END social share*/

    /*Transfers template*/
    setMaxHeightOnTransfersDataContainer : function() {
        var popupWrapperAccessibilitySpinner = document.querySelector(".popupWrapperAccessibilitySpinner");

        if(popupWrapperAccessibilitySpinner != null){
            popupWrapperAccessibilitySpinner.style.maxHeight = _baseContentHeight;
        }
    },
    /*End Transfers template*/

    /*threeTextNumericSelect*/
    threeTextNumericSelect: function (plusMinus, element) {

        if (document.querySelector(".ThreeTextNumericSelectContainer") == null)
            return;

        //logic to decide when to display plus, minus and trash buttons

        if (plusMinus == null) {
            //called from onload
            var bottomButtonSections = document.querySelectorAll(".bottomButtonSection");

            for (i = 0; i < bottomButtonSections.length; i++) {
                var bottomButtonSection = bottomButtonSections[i];

                var numericSelectionMin = bottomButtonSection.getAttribute("data-numericSelectionMin");
                var numericSelectionMax = bottomButtonSection.getAttribute("data-numericSelectionMax");
                var counter = bottomButtonSection.querySelector('.counterText').value;

                if (parseInt(counter) <= parseInt(numericSelectionMin)) {
                    var leftSmallIconTrash = bottomButtonSection.querySelector('.leftSmallIconTrash');
                    if (leftSmallIconTrash != null)
                        leftSmallIconTrash.style.visibility = "unset";

                } else {
                    var leftSmallIconMinus = bottomButtonSection.querySelector('.leftSmallIconMinus');
                    if (leftSmallIconMinus != null)
                        leftSmallIconMinus.style.visibility = "unset";
                }

                var rightIcon = bottomButtonSection.querySelector('.rightSmallIcon');
                if (rightIcon != null) {
                    if (parseInt(counter) >= parseInt(numericSelectionMax)) {
                        rightIcon.style.visibility = "hidden";
                    } else {
                        rightIcon.style.visibility = "unset";
                    }
                }
            }
        } else {
            //called from onclick
            if (element != null && element.parentElement != null) {
                var bottomButtonSection = element.parentElement;

                if (!bottomButtonSection.classList.contains("bottomButtonSection"))
                    bottomButtonSection = bottomButtonSection.parentElement;

                var numericSelectionMin = bottomButtonSection.getAttribute("data-numericSelectionMin");
                var numericSelectionMax = bottomButtonSection.getAttribute("data-numericSelectionMax");
                var plusKey = bottomButtonSection.getAttribute("data-plusKey");
                var minusKey = bottomButtonSection.getAttribute("data-minusKey");
                var counter = bottomButtonSection.querySelector('.counterText').value;
                var rightIcon = bottomButtonSection.querySelector('.rightSmallIcon');
                var leftSmallIconMinus = bottomButtonSection.querySelector('.leftSmallIconMinus');
                var leftSmallIconTrash = bottomButtonSection.querySelector('.leftSmallIconTrash');

                if (plusMinus == 'PLUS') {
                    counter++;
                    leftSmallIconMinus.style.visibility = "unset";
                    leftSmallIconTrash.style.visibility = "hidden";
                    if (parseInt(counter) == parseInt(numericSelectionMax)) {
                        rightIcon.style.visibility = 'hidden';

                    }
                    bottomButtonSection.querySelector('.counterText').setAttribute("name", plusKey);

                } else if(plusMinus == 'MINUS') {
                    counter--;
                    rightIcon.style.visibility = 'unset';
                    if (parseInt(counter) == parseInt(numericSelectionMin)) {
                        leftSmallIconMinus.style.visibility = "hidden";
                        leftSmallIconTrash.style.visibility = "unset";
                    }
                    bottomButtonSection.querySelector('.counterText').setAttribute("name", minusKey);
                } else {
                    bottomButtonSection.querySelector('.counterText').setAttribute("name", "");
                }
                bottomButtonSection.querySelector('.counterText').value = counter;
            }
        }
    },
    /*threeTextNumericSelect*/
};
